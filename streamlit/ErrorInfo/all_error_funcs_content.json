{
    "test-bloom-filter": {
        "test_bloom_filter_intersection": "\npub fn bloom_filter_free<T>(bloomfilter: &mut BloomFilter<T>) {\n    bloomfilter.table.clear();\n}\n\npub fn bloom_filter_intersection<T>(filter1: &BloomFilter<T>, filter2: &BloomFilter<T>) -> Option<BloomFilter<T>> {\n    if filter1.table_size != filter2.table_size || filter1.num_functions != filter2.num_functions || filter1.hash_func as *const () != filter2.hash_func as *const () {\n        return None;\n    }\n\n    let mut result = bloom_filter_new(filter1.table_size, filter1.hash_func, filter1.num_functions)?;\n\n    let array_size = (filter1.table_size + 7) / 8;\n\n    for i in 0..array_size {\n        result.table[i as usize] = filter1.table[i as usize] & filter2.table[i as usize];\n    }\n\n    Some(result)\n}\n\npub fn bloom_filter_new<T>(table_size: u32, hash_func: fn(T) -> u32, num_functions: u32) -> Option<BloomFilter<T>> {\n    if num_functions > SALTS.len() as u32 {\n        return None;\n    }\n\n    let table = vec![0u8; ((table_size + 7) / 8) as usize];\n\n    Some(BloomFilter {\n        hash_func,\n        table,\n        table_size,\n        num_functions,\n    })\n}\n\npub fn bloom_filter_query<T: Clone>(bloomfilter: &BloomFilter<T>, value: T) -> i32 {\n    let hash = (bloomfilter.hash_func)(value.clone());\n    let mut subhash: u32;\n    let mut index: usize;\n    let mut b: u8;\n    let mut bit: u8;\n\n    for _i in 0..bloomfilter.num_functions {\n        subhash = hash ^ SALTS[_i as usize];\n        index = (subhash % bloomfilter.table_size) as usize;\n        b = bloomfilter.table[index / 8];\n        bit = 1 << (index % 8);\n\n        if (b & bit) == 0 {\n            return 0;\n        }\n    }\n\n    1\n}\n\npub fn bloom_filter_insert<T: Clone>(bloomfilter: &mut BloomFilter<T>, value: T) {\n    let hash = (bloomfilter.hash_func)(value.clone());\n    let mut subhash;\n    let mut index;\n    let mut i: u32 = 0;\n    let mut b: u8;\n\n    while i < bloomfilter.num_functions {\n        subhash = hash ^ SALTS[i as usize];\n        index = subhash % bloomfilter.table_size;\n        b = 1 << (index % 8);\n        bloomfilter.table[(index / 8) as usize] |= b;\n        i += 1;\n    }\n}\n\npub struct BloomFilter<T> {\n    pub hash_func: fn(T) -> u32,\n    pub table: Vec<u8>,\n    pub table_size: u32,\n    pub num_functions: u32,\n}\n\npub const SALTS: [u32; 64] = [\n    0x1953c322, 0x588ccf17, 0x64bf600c, 0xa6be3f3d,\n    0x341a02ea, 0x15b03217, 0x3b062858, 0x5956fd06,\n    0x18b5624f, 0xe3be0b46, 0x20ffcd5c, 0xa35dfd2b,\n    0x1fc4a9bf, 0x57c45d5c, 0xa8661c4a, 0x4f1b74d2,\n    0x5a6dde13, 0x3b18dac6, 0x05a8afbf, 0xbbda2fe2,\n    0xa2520d78, 0xe7934849, 0xd541bc75, 0x09a55b57,\n    0x9b345ae2, 0xfc2d26af, 0x38679cef, 0x81bd1e0d,\n    0x654681ae, 0x4b3d87ad, 0xd5ff10fb, 0x23b32f67,\n    0xafc7e366, 0xdd955ead, 0xe7c34b1c, 0xfeace0a6,\n    0xeb16f09d, 0x3c57a72d, 0x2c8294c5, 0xba92662a,\n    0xcd5b2d14, 0x743936c8, 0x2489beff, 0xc6c56e00,\n    0x74a4f606, 0xb244a94a, 0x5edfc423, 0xf1901934,\n    0x24af7691, 0xf6c98b25, 0xea25af46, 0x76d5f2e6,\n    0x5e33cdf2, 0x445eb357, 0x88556bd2, 0x70d1da7a,\n    0x54449368, 0x381020bc, 0x1c0520bf, 0xf7e44942,\n    0xa27e2a58, 0x66866fc5, 0x12519ce7, 0x437a8456\n];\n\npub fn test_bloom_filter_intersection() {\n    let mut filter1 = bloom_filter_new(128, string_hash, 4).unwrap();\n    let mut filter2 = bloom_filter_new(128, string_hash, 4).unwrap();\n\n    bloom_filter_insert(&mut filter1, \"test 1\");\n    bloom_filter_insert(&mut filter1, \"test 2\");\n\n    bloom_filter_insert(&mut filter2, \"test 1\");\n\n    assert_eq!(bloom_filter_query(&filter2, \"test 2\"), 0);\n\n    let result = bloom_filter_intersection(&filter1, &filter2).unwrap();\n\n    assert_ne!(bloom_filter_query(&result, \"test 1\"), 0);\n    assert_eq!(bloom_filter_query(&result, \"test 2\"), 0);\n\n    bloom_filter_free(&mut result);\n    bloom_filter_free(&mut filter1);\n    bloom_filter_free(&mut filter2);\n}\n\npub fn string_hash(data: &str) -> u32 {\n    let mut hash: u32 = 0;\n    for c in data.chars() {\n        hash = hash.wrapping_mul(31).wrapping_add(c as u32);\n    }\n    hash\n}\n\nfn main() {\n}\n\n //编译报错信息：error[E0596]: cannot borrow `result` as mutable, as it is not declared as mutable\n   --> ../tmp/temp.rs:116:23\n    |\n116 |     bloom_filter_free(&mut result);\n    |                       ^^^^^^^^^^^ cannot borrow as mutable\n    |\n"
    },
    "binomial-heap": {
        "binomial_heap_insert": "pub fn binomial_tree_ref(tree: &mut Option<Rc<RefCell<BinomialTree>>>) {\n    if let Some(t) = tree {\n        t.borrow_mut().refcount += 1;\n    }\n}\n\npub fn binomial_tree_unref(tree: Option<Rc<RefCell<BinomialTree>>>) {\n    if let Some(tree_ref) = tree {\n        let mut tree_borrowed = tree_ref.borrow_mut();\n        tree_borrowed.refcount -= 1;\n\n        if tree_borrowed.refcount == 0 {\n            for subtree in &tree_borrowed.subtrees {\n                binomial_tree_unref(subtree.clone());\n            }\n            tree_borrowed.subtrees.clear();\n        }\n    }\n}\n\npub fn binomial_heap_merge_undo(new_roots: Vec<Option<Rc<RefCell<BinomialTree>>>>, count: usize) {\n    for i in 0..count {\n        binomial_tree_unref(new_roots.get(i).cloned().flatten());\n    }\n}\n\npub fn binomial_tree_merge(heap: &BinomialHeap, tree1: Rc<RefCell<BinomialTree>>, tree2: Rc<RefCell<BinomialTree>>) -> Option<Rc<RefCell<BinomialTree>>> {\n    let mut tree1 = tree1;\n    let mut tree2 = tree2;\n\n    if binomial_heap_cmp(heap, tree1.borrow().value.clone(), tree2.borrow().value.clone()) > 0 {\n        std::mem::swap(&mut tree1, &mut tree2);\n    }\n\n    let mut new_tree = Rc::new(RefCell::new(BinomialTree {\n        value: tree1.borrow().value.clone(),\n        order: tree1.borrow().order + 1,\n        refcount: 0,\n        subtrees: vec![None; tree1.borrow().order as usize + 1],\n    }));\n\n    for i in 0..tree1.borrow().order as usize {\n        new_tree.borrow_mut().subtrees[i] = tree1.borrow().subtrees[i].clone();\n    }\n    new_tree.borrow_mut().subtrees[tree1.borrow().order as usize] = Some(tree2.clone());\n\n    for subtree in new_tree.borrow().subtrees.iter() {\n        if let Some(subtree) = subtree {\n            binomial_tree_ref(&mut Some(subtree.clone()));\n        }\n    }\n\n    Some(new_tree)\n}\n\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Clone)]\npub struct BinomialHeapType;\n\nimpl PartialEq for BinomialHeapType {\n    fn eq(&self, _other: &Self) -> bool {\n        true\n    }\n}\n\nimpl Eq for BinomialHeapType {}\n\npub struct BinomialHeap {\n    pub heap_type: BinomialHeapType,\n    pub compare_func: Box<dyn Fn(BinomialHeapValue, BinomialHeapValue) -> i32>,\n    pub num_values: u32,\n    pub roots: Vec<Option<Rc<RefCell<BinomialTree>>>>,\n    pub roots_length: u32,\n}\n\npub struct BinomialTree {\n    pub value: BinomialHeapValue,\n    pub order: u16,\n    pub refcount: u16,\n    pub subtrees: Vec<Option<Rc<RefCell<BinomialTree>>>>,\n}\n\n#[derive(Clone)]\npub struct BinomialHeapValue(i32);\n\npub type BinomialHeapCompareFunc = Box<dyn Fn(BinomialHeapValue, BinomialHeapValue) -> i32>;\n\npub fn binomial_heap_merge(heap: &mut BinomialHeap, other: &BinomialHeap) -> i32 {\n    let max = if heap.roots_length > other.roots_length {\n        heap.roots_length + 1\n    } else {\n        other.roots_length + 1\n    };\n\n    let mut new_roots = vec![None; max as usize];\n    let mut new_roots_length = 0;\n    let mut carry: Option<Rc<RefCell<BinomialTree>>> = None;\n    let mut new_carry: Option<Rc<RefCell<BinomialTree>>>;\n\n    for i in 0..max {\n        let mut vals = vec![None; 3];\n        let mut num_vals = 0;\n\n        if i < heap.roots_length && heap.roots[i as usize].is_some() {\n            vals[num_vals] = heap.roots[i as usize].clone();\n            num_vals += 1;\n        }\n\n        if i < other.roots_length && other.roots[i as usize].is_some() {\n            vals[num_vals] = other.roots[i as usize].clone();\n            num_vals += 1;\n        }\n\n        if carry.is_some() {\n            vals[num_vals] = carry.clone();\n            num_vals += 1;\n        }\n\n        if (num_vals & 1) != 0 {\n            new_roots[i as usize] = vals[num_vals - 1].clone();\n            if let Some(ref mut tree) = new_roots[i as usize] {\n                binomial_tree_ref(&mut Some(tree.clone()));\n            }\n            new_roots_length = i + 1;\n        } else {\n            new_roots[i as usize] = None;\n        }\n\n        if (num_vals & 2) != 0 {\n            new_carry = binomial_tree_merge(heap, vals[0].as_ref().unwrap().clone(), vals[1].as_ref().unwrap().clone());\n\n            if new_carry.is_none() {\n                binomial_heap_merge_undo(new_roots.clone(), i as usize);\n                binomial_tree_unref(carry);\n                return 0;\n            }\n        } else {\n            new_carry = None;\n        }\n\n        binomial_tree_unref(carry);\n        carry = new_carry;\n        if let Some(ref mut tree) = carry {\n            binomial_tree_ref(&mut Some(tree.clone()));\n        }\n    }\n\n    for i in 0..heap.roots_length {\n        if let Some(ref tree) = heap.roots[i as usize] {\n            binomial_tree_unref(Some(tree.clone()));\n        }\n    }\n\n    heap.roots = new_roots;\n    heap.roots_length = new_roots_length as u32;\n\n    1\n}\n\npub fn binomial_heap_cmp(heap: &BinomialHeap, data1: BinomialHeapValue, data2: BinomialHeapValue) -> i32 {\n    if heap.heap_type == BinomialHeapType {\n        return (heap.compare_func)(data1.clone(), data2.clone());\n    } else {\n        return -((heap.compare_func)(data1.clone(), data2.clone()));\n    }\n}\n\npub fn binomial_heap_insert(heap: &mut BinomialHeap, value: BinomialHeapValue) -> i32 {\n    let new_tree = Rc::new(RefCell::new(BinomialTree {\n        value: value.clone(),\n        order: 0,\n        refcount: 1,\n        subtrees: vec![None; 1],\n    }));\n\n    let fake_heap = BinomialHeap {\n        heap_type: heap.heap_type.clone(),\n        compare_func: heap.compare_func.clone(),\n        num_values: 1,\n        roots: vec![Some(new_tree.clone())],\n        roots_length: 1,\n    };\n\n    let result = binomial_heap_merge(heap, &fake_heap);\n\n    if result != 0 {\n        heap.num_values += 1;\n    }\n\n    binomial_tree_unref(Some(new_tree));\n\n    result\n}\n\nfn main(){}\n //编译报错信息：error[E0599]: the method `clone` exists for struct `Box<dyn Fn(BinomialHeapValue, BinomialHeapValue) -> i32>`, but its trait bounds were not satisfied\n   --> ../tmp/temp.rs:180:41\n    |\n180 |           compare_func: heap.compare_func.clone(),\n    |                                           ^^^^^ method cannot be called due to unsatisfied trait bounds\n    |\n",
        "binomial_heap_pop": "pub fn binomial_tree_ref(tree: &mut Option<Rc<RefCell<BinomialTree>>>) {\n    if let Some(t) = tree {\n        t.borrow_mut().refcount += 1;\n    }\n}\n\npub fn binomial_tree_unref(tree: Option<Rc<RefCell<BinomialTree>>>) {\n    if let Some(tree_ref) = tree {\n        let mut tree_borrowed = tree_ref.borrow_mut();\n        tree_borrowed.refcount -= 1;\n\n        if tree_borrowed.refcount == 0 {\n            for subtree in &tree_borrowed.subtrees {\n                binomial_tree_unref(subtree.clone());\n            }\n            tree_borrowed.subtrees.clear();\n        }\n    }\n}\n\npub fn binomial_heap_merge_undo(new_roots: Vec<Option<Rc<RefCell<BinomialTree>>>>, count: usize) {\n    for i in 0..count {\n        binomial_tree_unref(new_roots.get(i).cloned().flatten());\n    }\n}\n\npub fn binomial_tree_merge(heap: &BinomialHeap, tree1: Rc<RefCell<BinomialTree>>, tree2: Rc<RefCell<BinomialTree>>) -> Option<Rc<RefCell<BinomialTree>>> {\n    let mut tree1 = tree1;\n    let mut tree2 = tree2;\n\n    if binomial_heap_cmp(heap, tree1.borrow().value.clone(), tree2.borrow().value.clone()) > 0 {\n        std::mem::swap(&mut tree1, &mut tree2);\n    }\n\n    let mut new_tree = Rc::new(RefCell::new(BinomialTree {\n        value: tree1.borrow().value.clone(),\n        order: tree1.borrow().order + 1,\n        refcount: 0,\n        subtrees: vec![None; tree1.borrow().order as usize + 1],\n    }));\n\n    for i in 0..tree1.borrow().order as usize {\n        new_tree.borrow_mut().subtrees[i] = tree1.borrow().subtrees[i].clone();\n    }\n    new_tree.borrow_mut().subtrees[tree1.borrow().order as usize] = Some(tree2.clone());\n\n    for subtree in new_tree.borrow().subtrees.iter() {\n        if let Some(subtree) = subtree {\n            binomial_tree_ref(&mut Some(subtree.clone()));\n        }\n    }\n\n    Some(new_tree)\n}\n\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\n#[derive(Clone)]\npub struct BinomialHeapType;\n\nimpl PartialEq for BinomialHeapType {\n    fn eq(&self, _other: &Self) -> bool {\n        true\n    }\n}\n\nimpl Eq for BinomialHeapType {}\n\npub struct BinomialHeap {\n    pub heap_type: BinomialHeapType,\n    pub compare_func: BinomialHeapCompareFunc,\n    pub num_values: u32,\n    pub roots: Vec<Option<Rc<RefCell<BinomialTree>>>>,\n    pub roots_length: u32,\n}\n\npub struct BinomialTree {\n    pub value: BinomialHeapValue,\n    pub order: u16,\n    pub refcount: u16,\n    pub subtrees: Vec<Option<Rc<RefCell<BinomialTree>>>>,\n}\n\n#[derive(Clone)]\npub struct BinomialHeapValue(i32);\n\npub type BinomialHeapCompareFunc = Box<dyn Fn(BinomialHeapValue, BinomialHeapValue) -> i32>;\n\npub fn binomial_heap_merge(heap: &mut BinomialHeap, other: &BinomialHeap) -> i32 {\n    let max = if heap.roots_length > other.roots_length {\n        heap.roots_length + 1\n    } else {\n        other.roots_length + 1\n    };\n\n    let mut new_roots = vec![None; max as usize];\n    let mut new_roots_length = 0;\n    let mut carry: Option<Rc<RefCell<BinomialTree>>> = None;\n    let mut new_carry: Option<Rc<RefCell<BinomialTree>>>;\n\n    for i in 0..max {\n        let mut vals = vec![None; 3];\n        let mut num_vals = 0;\n\n        if i < heap.roots_length && heap.roots[i as usize].is_some() {\n            vals[num_vals] = heap.roots[i as usize].clone();\n            num_vals += 1;\n        }\n\n        if i < other.roots_length && other.roots[i as usize].is_some() {\n            vals[num_vals] = other.roots[i as usize].clone();\n            num_vals += 1;\n        }\n\n        if carry.is_some() {\n            vals[num_vals] = carry.clone();\n            num_vals += 1;\n        }\n\n        if (num_vals & 1) != 0 {\n            new_roots[i as usize] = vals[num_vals - 1].clone();\n            if let Some(ref mut tree) = new_roots[i as usize] {\n                binomial_tree_ref(&mut Some(tree.clone()));\n            }\n            new_roots_length = i + 1;\n        } else {\n            new_roots[i as usize] = None;\n        }\n\n        if (num_vals & 2) != 0 {\n            new_carry = binomial_tree_merge(heap, vals[0].as_ref().unwrap().clone(), vals[1].as_ref().unwrap().clone());\n\n            if new_carry.is_none() {\n                binomial_heap_merge_undo(new_roots.clone(), i as usize);\n                binomial_tree_unref(carry);\n                return 0;\n            }\n        } else {\n            new_carry = None;\n        }\n\n        binomial_tree_unref(carry);\n        carry = new_carry;\n        if let Some(ref mut tree) = carry {\n            binomial_tree_ref(&mut Some(tree.clone()));\n        }\n    }\n\n    for i in 0..heap.roots_length {\n        if let Some(ref tree) = heap.roots[i as usize] {\n            binomial_tree_unref(Some(tree.clone()));\n        }\n    }\n\n    heap.roots = new_roots;\n    heap.roots_length = new_roots_length as u32;\n\n    1\n}\n\npub fn binomial_heap_cmp(heap: &BinomialHeap, data1: BinomialHeapValue, data2: BinomialHeapValue) -> i32 {\n    if heap.heap_type == BinomialHeapType {\n        return (heap.compare_func)(data1.clone(), data2.clone());\n    } else {\n        return -((heap.compare_func)(data1.clone(), data2.clone()));\n    }\n}\n\npub fn binomial_heap_pop(heap: &mut BinomialHeap) -> Option<BinomialHeapValue> {\n    if heap.num_values == 0 {\n        return None;\n    }\n\n    let mut least_index = None;\n\n    for i in 0..heap.roots_length {\n        if let Some(ref tree) = heap.roots[i as usize] {\n            if least_index.is_none() || binomial_heap_cmp(heap, tree.borrow().value.clone(), heap.roots[least_index.unwrap() as usize].as_ref().unwrap().borrow().value.clone()) < 0 {\n                least_index = Some(i);\n            }\n        }\n    }\n\n    if let Some(least_index) = least_index {\n        let least_tree = heap.roots[least_index as usize].take().unwrap();\n\n        let mut fake_heap = BinomialHeap {\n            heap_type: heap.heap_type.clone(),\n            compare_func: heap.compare_func.clone(),\n            num_values: 0,\n            roots: least_tree.borrow().subtrees.clone(),\n            roots_length: least_tree.borrow().order as u32,\n        };\n\n        if binomial_heap_merge(heap, &fake_heap) != 0 {\n            let result = least_tree.borrow().value.clone();\n            binomial_tree_unref(Some(least_tree));\n            heap.num_values -= 1;\n            return Some(result);\n        } else {\n            heap.roots[least_index as usize] = Some(least_tree);\n        }\n    }\n\n    None\n}\n\nfn main(){}\n //编译报错信息：error[E0599]: the method `clone` exists for struct `Box<dyn Fn(BinomialHeapValue, BinomialHeapValue) -> i32>`, but its trait bounds were not satisfied\n   --> ../tmp/temp.rs:190:45\n    |\n190 |               compare_func: heap.compare_func.clone(),\n    |                                               ^^^^^ method cannot be called due to unsatisfied trait bounds\n    |\n"
    },
    "test-binomial-heap": {
        "generate_heap": "use std::rc::Rc;\nuse std::cell::RefCell;\n\npub fn binomial_tree_ref(tree: &mut Option<Rc<RefCell<BinomialTree>>>) {\n    if let Some(t) = tree {\n        t.borrow_mut().refcount += 1;\n    }\n}\n\npub fn binomial_tree_unref(tree: Option<Rc<RefCell<BinomialTree>>>) {\n    if let Some(tree_ref) = tree {\n        let mut tree_borrowed = tree_ref.borrow_mut();\n        tree_borrowed.refcount -= 1;\n\n        if tree_borrowed.refcount == 0 {\n            for subtree in &tree_borrowed.subtrees {\n                binomial_tree_unref(subtree.clone());\n            }\n            tree_borrowed.subtrees.clear();\n        }\n    }\n}\n\npub fn binomial_heap_merge_undo(new_roots: Vec<Option<Rc<RefCell<BinomialTree>>>>, count: usize) {\n    for i in 0..count {\n        binomial_tree_unref(new_roots.get(i).cloned().flatten());\n    }\n}\n\npub fn binomial_tree_merge(heap: &BinomialHeap, tree1: Rc<RefCell<BinomialTree>>, tree2: Rc<RefCell<BinomialTree>>) -> Option<Rc<RefCell<BinomialTree>>> {\n    let mut tree1 = tree1;\n    let mut tree2 = tree2;\n\n    if binomial_heap_cmp(heap, tree1.borrow().value.clone(), tree2.borrow().value.clone()) > 0 {\n        std::mem::swap(&mut tree1, &mut tree2);\n    }\n\n    let mut new_tree = Rc::new(RefCell::new(BinomialTree {\n        value: tree1.borrow().value.clone(),\n        order: tree1.borrow().order + 1,\n        refcount: 0,\n        subtrees: vec![None; tree1.borrow().order as usize + 1],\n    }));\n\n    for i in 0..tree1.borrow().order as usize {\n        new_tree.borrow_mut().subtrees[i] = tree1.borrow().subtrees[i].clone();\n    }\n    new_tree.borrow_mut().subtrees[tree1.borrow().order as usize] = Some(tree2.clone());\n\n    for subtree in new_tree.borrow().subtrees.iter() {\n        if let Some(subtree) = subtree {\n            binomial_tree_ref(&mut Some(subtree.clone()));\n        }\n    }\n\n    Some(new_tree)\n}\n\npub struct BinomialHeapType;\n\nimpl Clone for BinomialHeapType {\n    fn clone(&self) -> Self {\n        BinomialHeapType\n    }\n}\n\nimpl PartialEq for BinomialHeapType {\n    fn eq(&self, _other: &Self) -> bool {\n        true\n    }\n}\n\nimpl Eq for BinomialHeapType {}\n\npub struct BinomialHeap {\n    pub heap_type: BinomialHeapType,\n    pub compare_func: BinomialHeapCompareFunc,\n    pub num_values: u32,\n    pub roots: Vec<Option<Rc<RefCell<BinomialTree>>>>,\n    pub roots_length: u32,\n}\n\npub struct BinomialTree {\n    pub value: BinomialHeapValue,\n    pub order: u16,\n    pub refcount: u16,\n    pub subtrees: Vec<Option<Rc<RefCell<BinomialTree>>>>,\n}\n\n#[derive(Clone)]\npub struct BinomialHeapValue(i32);\n\npub type BinomialHeapCompareFunc = Box<dyn Fn(BinomialHeapValue, BinomialHeapValue) -> i32>;\n\npub fn binomial_heap_new(heap_type: BinomialHeapType, compare_func: BinomialHeapCompareFunc) -> Option<BinomialHeap> {\n    let mut new_heap = BinomialHeap {\n        heap_type,\n        compare_func,\n        num_values: 0,\n        roots: Vec::new(),\n        roots_length: 0,\n    };\n\n    Some(new_heap)\n}\n\npub fn binomial_heap_merge(heap: &mut BinomialHeap, other: &BinomialHeap) -> i32 {\n    let max = if heap.roots_length > other.roots_length {\n        heap.roots_length + 1\n    } else {\n        other.roots_length + 1\n    };\n\n    let mut new_roots = vec![None; max as usize];\n    let mut new_roots_length = 0;\n    let mut carry: Option<Rc<RefCell<BinomialTree>>> = None;\n    let mut new_carry: Option<Rc<RefCell<BinomialTree>>>;\n\n    for i in 0..max {\n        let mut vals = vec![None; 3];\n        let mut num_vals = 0;\n\n        if i < heap.roots_length && heap.roots[i as usize].is_some() {\n            vals[num_vals] = heap.roots[i as usize].clone();\n            num_vals += 1;\n        }\n\n        if i < other.roots_length && other.roots[i as usize].is_some() {\n            vals[num_vals] = other.roots[i as usize].clone();\n            num_vals += 1;\n        }\n\n        if carry.is_some() {\n            vals[num_vals] = carry.clone();\n            num_vals += 1;\n        }\n\n        if (num_vals & 1) != 0 {\n            new_roots[i as usize] = vals[num_vals - 1].clone();\n            if let Some(ref mut tree) = new_roots[i as usize] {\n                binomial_tree_ref(&mut Some(tree.clone()));\n            }\n            new_roots_length = i + 1;\n        } else {\n            new_roots[i as usize] = None;\n        }\n\n        if (num_vals & 2) != 0 {\n            new_carry = binomial_tree_merge(heap, vals[0].as_ref().unwrap().clone(), vals[1].as_ref().unwrap().clone());\n\n            if new_carry.is_none() {\n                binomial_heap_merge_undo(new_roots.clone(), i as usize);\n                binomial_tree_unref(carry);\n                return 0;\n            }\n        } else {\n            new_carry = None;\n        }\n\n        binomial_tree_unref(carry);\n        carry = new_carry;\n        if let Some(ref mut tree) = carry {\n            binomial_tree_ref(&mut Some(tree.clone()));\n        }\n    }\n\n    for i in 0..heap.roots_length {\n        if let Some(ref tree) = heap.roots[i as usize] {\n            binomial_tree_unref(Some(tree.clone()));\n        }\n    }\n\n    heap.roots = new_roots;\n    heap.roots_length = new_roots_length as u32;\n\n    1\n}\n\npub fn binomial_heap_cmp(heap: &BinomialHeap, data1: BinomialHeapValue, data2: BinomialHeapValue) -> i32 {\n    if heap.heap_type == BinomialHeapType {\n        return (heap.compare_func)(data1.clone(), data2.clone());\n    } else {\n        return -((heap.compare_func)(data1.clone(), data2.clone()));\n    }\n}\n\npub fn generate_heap() -> Option<BinomialHeap> {\n    let mut heap = binomial_heap_new(BinomialHeapType, Box::new(int_compare));\n\n    if let Some(ref mut heap) = heap {\n        for i in 0..NUM_TEST_VALUES {\n            unsafe { test_array[i] = i as i32; }\n            if i != TEST_VALUE {\n                assert!(binomial_heap_insert(heap, BinomialHeapValue(unsafe { test_array[i] })) != 0);\n            }\n        }\n    }\n\n    heap\n}\n\npub fn binomial_heap_insert(heap: &mut BinomialHeap, value: BinomialHeapValue) -> i32 {\n    let mut fake_heap = BinomialHeap {\n        heap_type: heap.heap_type.clone(),\n        compare_func: heap.compare_func.clone(),\n        num_values: 1,\n        roots: vec![None; 1],\n        roots_length: 1,\n    };\n\n    let new_tree = Rc::new(RefCell::new(BinomialTree {\n        value: value.clone(),\n        order: 0,\n        refcount: 1,\n        subtrees: Vec::new(),\n    }));\n\n    fake_heap.roots[0] = Some(new_tree.clone());\n\n    let result = binomial_heap_merge(heap, &fake_heap);\n\n    if result != 0 {\n        heap.num_values += 1;\n    }\n\n    binomial_tree_unref(Some(new_tree));\n\n    result\n}\n\npub const NUM_TEST_VALUES: usize = 10000;\npub const TEST_VALUE: usize = NUM_TEST_VALUES / 2;\npub static mut test_array: [i32; NUM_TEST_VALUES] = [0; NUM_TEST_VALUES];\n\npub fn int_compare(value1: BinomialHeapValue, value2: BinomialHeapValue) -> i32 {\n    if value1.0 < value2.0 {\n        -1\n    } else if value1.0 > value2.0 {\n        1\n    } else {\n        0\n    }\n}\n\nfn main(){}\n //编译报错信息：error[E0599]: the method `clone` exists for struct `Box<dyn Fn(BinomialHeapValue, BinomialHeapValue) -> i32>`, but its trait bounds were not satisfied\n   --> ../tmp/temp.rs:205:41\n    |\n205 |           compare_func: heap.compare_func.clone(),\n    |                                           ^^^^^ method cannot be called due to unsatisfied trait bounds\n    |\n",
        "verify_heap": "use std::rc::Rc;\nuse std::cell::RefCell;\n\npub fn binomial_tree_ref(tree: &mut Option<Rc<RefCell<BinomialTree>>>) {\n    if let Some(t) = tree {\n        t.borrow_mut().refcount += 1;\n    }\n}\n\npub fn binomial_tree_unref(tree: Option<Rc<RefCell<BinomialTree>>>) {\n    if let Some(tree_ref) = tree {\n        let mut tree_borrowed = tree_ref.borrow_mut();\n        tree_borrowed.refcount -= 1;\n\n        if tree_borrowed.refcount == 0 {\n            for subtree in &tree_borrowed.subtrees {\n                binomial_tree_unref(subtree.clone());\n            }\n            tree_borrowed.subtrees.clear();\n        }\n    }\n}\n\npub fn binomial_heap_num_entries(heap: &BinomialHeap) -> u32 {\n    heap.num_values\n}\n\npub fn binomial_heap_merge_undo(new_roots: Vec<Option<Rc<RefCell<BinomialTree>>>>, count: usize) {\n    for i in 0..count {\n        binomial_tree_unref(new_roots.get(i).cloned().flatten());\n    }\n}\n\npub fn binomial_tree_merge(heap: &BinomialHeap, tree1: Rc<RefCell<BinomialTree>>, tree2: Rc<RefCell<BinomialTree>>) -> Option<Rc<RefCell<BinomialTree>>> {\n    let mut tree1 = tree1;\n    let mut tree2 = tree2;\n\n    if binomial_heap_cmp(heap, tree1.borrow().value.clone(), tree2.borrow().value.clone()) > 0 {\n        std::mem::swap(&mut tree1, &mut tree2);\n    }\n\n    let mut new_tree = Rc::new(RefCell::new(BinomialTree {\n        value: tree1.borrow().value.clone(),\n        order: tree1.borrow().order + 1,\n        refcount: 0,\n        subtrees: vec![None; tree1.borrow().order as usize + 1],\n    }));\n\n    for i in 0..tree1.borrow().order as usize {\n        new_tree.borrow_mut().subtrees[i] = tree1.borrow().subtrees[i].clone();\n    }\n    new_tree.borrow_mut().subtrees[tree1.borrow().order as usize] = Some(tree2.clone());\n\n    for subtree in new_tree.borrow().subtrees.iter() {\n        if let Some(subtree) = subtree {\n            binomial_tree_ref(&mut Some(subtree.clone()));\n        }\n    }\n\n    Some(new_tree)\n}\n\n#[derive(Clone, PartialEq, Eq)]\npub struct BinomialHeapType;\n\npub struct BinomialHeap {\n    pub heap_type: BinomialHeapType,\n    pub compare_func: BinomialHeapCompareFunc,\n    pub num_values: u32,\n    pub roots: Vec<Option<Rc<RefCell<BinomialTree>>>>,\n    pub roots_length: u32,\n}\n\npub struct BinomialTree {\n    pub value: BinomialHeapValue,\n    pub order: u16,\n    pub refcount: u16,\n    pub subtrees: Vec<Option<Rc<RefCell<BinomialTree>>>>,\n}\n\n#[derive(Clone, PartialEq, Debug)]\npub struct BinomialHeapValue(i32);\n\npub type BinomialHeapCompareFunc = Box<dyn Fn(BinomialHeapValue, BinomialHeapValue) -> i32>;\n\npub fn binomial_heap_merge(heap: &mut BinomialHeap, other: &BinomialHeap) -> i32 {\n    let max = if heap.roots_length > other.roots_length {\n        heap.roots_length + 1\n    } else {\n        other.roots_length + 1\n    };\n\n    let mut new_roots = vec![None; max as usize];\n    let mut new_roots_length = 0;\n    let mut carry: Option<Rc<RefCell<BinomialTree>>> = None;\n    let mut new_carry: Option<Rc<RefCell<BinomialTree>>>;\n\n    for i in 0..max {\n        let mut vals = vec![None; 3];\n        let mut num_vals = 0;\n\n        if i < heap.roots_length && heap.roots[i as usize].is_some() {\n            vals[num_vals] = heap.roots[i as usize].clone();\n            num_vals += 1;\n        }\n\n        if i < other.roots_length && other.roots[i as usize].is_some() {\n            vals[num_vals] = other.roots[i as usize].clone();\n            num_vals += 1;\n        }\n\n        if carry.is_some() {\n            vals[num_vals] = carry.clone();\n            num_vals += 1;\n        }\n\n        if (num_vals & 1) != 0 {\n            new_roots[i as usize] = vals[num_vals - 1].clone();\n            if let Some(ref mut tree) = new_roots[i as usize] {\n                binomial_tree_ref(&mut Some(tree.clone()));\n            }\n            new_roots_length = i + 1;\n        } else {\n            new_roots[i as usize] = None;\n        }\n\n        if (num_vals & 2) != 0 {\n            new_carry = binomial_tree_merge(heap, vals[0].as_ref().unwrap().clone(), vals[1].as_ref().unwrap().clone());\n\n            if new_carry.is_none() {\n                binomial_heap_merge_undo(new_roots.clone(), i as usize);\n                binomial_tree_unref(carry);\n                return 0;\n            }\n        } else {\n            new_carry = None;\n        }\n\n        binomial_tree_unref(carry);\n        carry = new_carry;\n        if let Some(ref mut tree) = carry {\n            binomial_tree_ref(&mut Some(tree.clone()));\n        }\n    }\n\n    for i in 0..heap.roots_length {\n        if let Some(ref tree) = heap.roots[i as usize] {\n            binomial_tree_unref(Some(tree.clone()));\n        }\n    }\n\n    heap.roots = new_roots;\n    heap.roots_length = new_roots_length as u32;\n\n    1\n}\n\npub fn binomial_heap_cmp(heap: &BinomialHeap, data1: BinomialHeapValue, data2: BinomialHeapValue) -> i32 {\n    if heap.heap_type == BinomialHeapType {\n        return (heap.compare_func)(data1.clone(), data2.clone());\n    } else {\n        return -((heap.compare_func)(data1.clone(), data2.clone()));\n    }\n}\n\npub fn verify_heap(heap: &mut BinomialHeap) {\n    let mut num_vals = binomial_heap_num_entries(heap);\n    assert_eq!(num_vals, NUM_TEST_VALUES - 1);\n\n    for i in 0..NUM_TEST_VALUES {\n        if i == TEST_VALUE {\n            continue;\n        }\n\n        let val = binomial_heap_pop(heap);\n        assert_eq!(val, Some(BinomialHeapValue(i as i32)));\n\n        num_vals -= 1;\n        assert_eq!(binomial_heap_num_entries(heap), num_vals);\n    }\n}\n\npub fn binomial_heap_pop(heap: &mut BinomialHeap) -> Option<BinomialHeapValue> {\n    if heap.num_values == 0 {\n        return None;\n    }\n\n    let mut least_index = u32::MAX;\n\n    for i in 0..heap.roots_length {\n        if let Some(_) = heap.roots[i as usize] {\n            if least_index == u32::MAX || binomial_heap_cmp(heap, heap.roots[i as usize].as_ref().unwrap().borrow().value.clone(), heap.roots[least_index as usize].as_ref().unwrap().borrow().value.clone()) < 0 {\n                least_index = i;\n            }\n        }\n    }\n\n    let least_tree = heap.roots[least_index as usize].take();\n\n    let mut fake_heap = BinomialHeap {\n        heap_type: heap.heap_type.clone(),\n        compare_func: heap.compare_func.clone(),\n        num_values: 0,\n        roots: least_tree.as_ref().unwrap().borrow().subtrees.clone(),\n        roots_length: least_tree.as_ref().unwrap().borrow().order,\n    };\n\n    if binomial_heap_merge(heap, &mut fake_heap) == 1 {\n        let result = least_tree.as_ref().unwrap().borrow().value.clone();\n        binomial_tree_unref(least_tree);\n\n        heap.num_values -= 1;\n\n        Some(result)\n    } else {\n        heap.roots[least_index as usize] = least_tree;\n\n        None\n    }\n}\n\npub const NUM_TEST_VALUES: u32 = 10000;\npub const TEST_VALUE: u32 = NUM_TEST_VALUES / 2;\n\nfn main(){}\n //编译报错信息：error[E0599]: the method `clone` exists for struct `Box<dyn Fn(BinomialHeapValue, BinomialHeapValue) -> i32>`, but its trait bounds were not satisfied\n   --> ../tmp/temp.rs:202:41\n    |\n202 |           compare_func: heap.compare_func.clone(),\n    |                                           ^^^^^ method cannot be called due to unsatisfied trait bounds\n    |\n",
        "test_insert_out_of_memory": "use std::rc::Rc;\nuse std::cell::RefCell;\n\npub struct BinomialHeapType;\n\nimpl PartialEq for BinomialHeapType {\n    fn eq(&self, _other: &Self) -> bool {\n        true\n    }\n}\n\nimpl Eq for BinomialHeapType {}\n\npub struct BinomialHeap {\n    pub heap_type: BinomialHeapType,\n    pub compare_func: BinomialHeapCompareFunc,\n    pub num_values: u32,\n    pub roots: Vec<Option<Rc<RefCell<BinomialTree>>>>,\n    pub roots_length: u32,\n}\n\npub struct BinomialTree {\n    pub value: BinomialHeapValue,\n    pub order: u16,\n    pub refcount: u16,\n    pub subtrees: Vec<Option<Rc<RefCell<BinomialTree>>>>,\n}\n\n#[derive(Clone)]\npub struct BinomialHeapValue(i32);\n\npub type BinomialHeapCompareFunc = Box<dyn Fn(BinomialHeapValue, BinomialHeapValue) -> i32>;\n\npub const NUM_TEST_VALUES: usize = 10000;\npub const TEST_VALUE: usize = NUM_TEST_VALUES / 2;\npub const BINOMIAL_HEAP_TYPE_MIN: BinomialHeapType = BinomialHeapType;\n\npub fn binomial_tree_ref(tree: &mut Option<Rc<RefCell<BinomialTree>>>) {\n    if let Some(t) = tree {\n        t.borrow_mut().refcount += 1;\n    }\n}\n\npub fn binomial_heap_new(heap_type: BinomialHeapType, compare_func: BinomialHeapCompareFunc) -> Option<BinomialHeap> {\n    let mut new_heap = BinomialHeap {\n        heap_type,\n        compare_func,\n        num_values: 0,\n        roots: Vec::new(),\n        roots_length: 0,\n    };\n\n    Some(new_heap)\n}\n\npub fn binomial_tree_unref(tree: Option<Rc<RefCell<BinomialTree>>>) {\n    if let Some(tree_ref) = tree {\n        let mut tree_borrowed = tree_ref.borrow_mut();\n        tree_borrowed.refcount -= 1;\n\n        if tree_borrowed.refcount == 0 {\n            for subtree in &tree_borrowed.subtrees {\n                binomial_tree_unref(subtree.clone());\n            }\n            tree_borrowed.subtrees.clear();\n        }\n    }\n}\n\npub fn binomial_heap_num_entries(heap: &BinomialHeap) -> u32 {\n    heap.num_values\n}\n\npub fn binomial_heap_merge_undo(new_roots: Vec<Option<Rc<RefCell<BinomialTree>>>>, count: usize) {\n    for i in 0..count {\n        binomial_tree_unref(new_roots.get(i).cloned().flatten());\n    }\n}\n\npub fn binomial_tree_merge(heap: &BinomialHeap, tree1: Rc<RefCell<BinomialTree>>, tree2: Rc<RefCell<BinomialTree>>) -> Option<Rc<RefCell<BinomialTree>>> {\n    let mut tree1 = tree1;\n    let mut tree2 = tree2;\n\n    if binomial_heap_cmp(heap, tree1.borrow().value.clone(), tree2.borrow().value.clone()) > 0 {\n        std::mem::swap(&mut tree1, &mut tree2);\n    }\n\n    let mut new_tree = Rc::new(RefCell::new(BinomialTree {\n        value: tree1.borrow().value.clone(),\n        order: tree1.borrow().order + 1,\n        refcount: 0,\n        subtrees: vec![None; tree1.borrow().order as usize + 1],\n    }));\n\n    for i in 0..tree1.borrow().order as usize {\n        new_tree.borrow_mut().subtrees[i] = tree1.borrow().subtrees[i].clone();\n    }\n    new_tree.borrow_mut().subtrees[tree1.borrow().order as usize] = Some(tree2.clone());\n\n    for subtree in new_tree.borrow().subtrees.iter() {\n        if let Some(subtree) = subtree {\n            binomial_tree_ref(&mut Some(subtree.clone()));\n        }\n    }\n\n    Some(new_tree)\n}\n\npub fn binomial_heap_free(heap: BinomialHeap) {\n    let mut heap = heap;\n    for root in heap.roots.drain(..) {\n        binomial_tree_unref(root);\n    }\n}\n\npub fn binomial_heap_merge(heap: &mut BinomialHeap, other: &BinomialHeap) -> i32 {\n    let max = if heap.roots_length > other.roots_length {\n        heap.roots_length + 1\n    } else {\n        other.roots_length + 1\n    };\n\n    let mut new_roots = vec![None; max as usize];\n    let mut new_roots_length = 0;\n    let mut carry: Option<Rc<RefCell<BinomialTree>>> = None;\n    let mut new_carry: Option<Rc<RefCell<BinomialTree>>>;\n\n    for i in 0..max {\n        let mut vals = vec![None; 3];\n        let mut num_vals = 0;\n\n        if i < heap.roots_length && heap.roots[i as usize].is_some() {\n            vals[num_vals] = heap.roots[i as usize].clone();\n            num_vals += 1;\n        }\n\n        if i < other.roots_length && other.roots[i as usize].is_some() {\n            vals[num_vals] = other.roots[i as usize].clone();\n            num_vals += 1;\n        }\n\n        if carry.is_some() {\n            vals[num_vals] = carry.clone();\n            num_vals += 1;\n        }\n\n        if (num_vals & 1) != 0 {\n            new_roots[i as usize] = vals[num_vals - 1].clone();\n            if let Some(ref mut tree) = new_roots[i as usize] {\n                binomial_tree_ref(&mut Some(tree.clone()));\n            }\n            new_roots_length = i + 1;\n        } else {\n            new_roots[i as usize] = None;\n        }\n\n        if (num_vals & 2) != 0 {\n            new_carry = binomial_tree_merge(heap, vals[0].as_ref().unwrap().clone(), vals[1].as_ref().unwrap().clone());\n\n            if new_carry.is_none() {\n                binomial_heap_merge_undo(new_roots.clone(), i as usize);\n                binomial_tree_unref(carry);\n                return 0;\n            }\n        } else {\n            new_carry = None;\n        }\n\n        binomial_tree_unref(carry);\n        carry = new_carry;\n        if let Some(ref mut tree) = carry {\n            binomial_tree_ref(&mut Some(tree.clone()));\n        }\n    }\n\n    for i in 0..heap.roots_length {\n        if let Some(ref tree) = heap.roots[i as usize] {\n            binomial_tree_unref(Some(tree.clone()));\n        }\n    }\n\n    heap.roots = new_roots;\n    heap.roots_length = new_roots_length as u32;\n\n    1\n}\n\npub fn binomial_heap_cmp(heap: &BinomialHeap, data1: BinomialHeapValue, data2: BinomialHeapValue) -> i32 {\n    if heap.heap_type == BinomialHeapType {\n        return (heap.compare_func)(data1.clone(), data2.clone());\n    } else {\n        return -((heap.compare_func)(data1.clone(), data2.clone()));\n    }\n}\n\npub fn test_insert_out_of_memory() {\n    let mut i = 0;\n    while i < 6 {\n        let mut heap = generate_heap();\n\n        unsafe {\n            test_array[TEST_VALUE] = BinomialHeapValue(TEST_VALUE);\n        }\n        assert!(binomial_heap_insert(&mut heap, unsafe { test_array[TEST_VALUE].clone() }) == 0);\n\n        verify_heap(&heap);\n\n        binomial_heap_free(heap);\n        i += 1;\n    }\n}\n\npub fn generate_heap() -> BinomialHeap {\n    let mut heap = binomial_heap_new(BINOMIAL_HEAP_TYPE_MIN, Box::new(int_compare)).unwrap();\n    let mut i = 0;\n    while i < NUM_TEST_VALUES {\n        unsafe {\n            test_array[i] = BinomialHeapValue(i as i32);\n        }\n        if i != TEST_VALUE {\n            assert!(binomial_heap_insert(&mut heap, unsafe { test_array[i].clone() }) != 0);\n        }\n        i += 1;\n    }\n    heap\n}\n\npub fn binomial_heap_pop(heap: &mut BinomialHeap) -> BinomialHeapValue {\n    if heap.num_values == 0 {\n        return BinomialHeapValue(0);\n    }\n\n    let mut least_index = u32::MAX;\n    for i in 0..heap.roots_length as usize {\n        if let Some(tree) = &heap.roots[i] {\n            if least_index == u32::MAX || binomial_heap_cmp(heap, tree.borrow().value.clone(), heap.roots[least_index as usize].as_ref().unwrap().borrow().value.clone()) < 0 {\n                least_index = i as u32;\n            }\n        }\n    }\n\n    let least_tree = heap.roots[least_index as usize].take().unwrap();\n    let mut fake_heap = BinomialHeap {\n        heap_type: heap.heap_type.clone(),\n        compare_func: heap.compare_func.clone(),\n        num_values: 0,\n        roots: least_tree.borrow().subtrees.clone(),\n        roots_length: least_tree.borrow().order,\n    };\n\n    if binomial_heap_merge(heap, &mut fake_heap) != 0 {\n        let result = least_tree.borrow().value.clone();\n        binomial_tree_unref(Some(least_tree));\n        heap.num_values -= 1;\n        result\n    } else {\n        heap.roots[least_index as usize] = Some(least_tree);\n        BinomialHeapValue(0)\n    }\n}\n\npub fn verify_heap(heap: &BinomialHeap) {\n    let mut num_vals = binomial_heap_num_entries(heap);\n    assert!(num_vals == NUM_TEST_VALUES as u32 - 1);\n\n    for i in 0..NUM_TEST_VALUES {\n        if i == TEST_VALUE {\n            continue;\n        }\n\n        let val = binomial_heap_pop(&mut heap.clone());\n        assert!(val.0 == i as i32);\n\n        num_vals -= 1;\n        assert!(binomial_heap_num_entries(heap) == num_vals);\n    }\n}\n\npub fn binomial_heap_insert(heap: &mut BinomialHeap, value: BinomialHeapValue) -> i32 {\n    let new_tree = Rc::new(RefCell::new(BinomialTree {\n        value: value.clone(),\n        order: 0,\n        refcount: 1,\n        subtrees: vec![],\n    }));\n\n    let mut fake_heap = BinomialHeap {\n        heap_type: heap.heap_type.clone(),\n        compare_func: heap.compare_func.clone(),\n        num_values: 1,\n        roots: vec![Some(new_tree.clone())],\n        roots_length: 1,\n    };\n\n    let result = binomial_heap_merge(heap, &mut fake_heap);\n    if result != 0 {\n        heap.num_values += 1;\n    }\n\n    binomial_tree_unref(Some(new_tree));\n    result\n}\n\npub fn int_compare(value1: BinomialHeapValue, value2: BinomialHeapValue) -> i32 {\n    if value1.0 < value2.0 {\n        -1\n    } else if value1.0 > value2.0 {\n        1\n    } else {\n        0\n    }\n}\n\npub static mut test_array: [BinomialHeapValue; NUM_TEST_VALUES] = [BinomialHeapValue(0); NUM_TEST_VALUES];\n\nfn main(){}\n //编译报错信息：error[E0277]: the trait bound `BinomialHeapValue: Copy` is not satisfied\n   --> ../tmp/temp.rs:314:68\n    |\n314 | pub static mut test_array: [BinomialHeapValue; NUM_TEST_VALUES] = [BinomialHeapValue(0); NUM_TEST_VALUES];\n    |                                                                    ^^^^^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `BinomialHeapValue`\n    |\n",
        "test_pop_out_of_memory": "use std::rc::Rc;\nuse std::cell::RefCell;\n\npub struct BinomialHeapType;\n\nimpl PartialEq for BinomialHeapType {\n    fn eq(&self, _other: &Self) -> bool {\n        true\n    }\n}\n\nimpl Eq for BinomialHeapType {}\n\npub struct BinomialHeap {\n    pub heap_type: BinomialHeapType,\n    pub compare_func: BinomialHeapCompareFunc,\n    pub num_values: u32,\n    pub roots: Vec<Option<Rc<RefCell<BinomialTree>>>>,\n    pub roots_length: u32,\n}\n\npub struct BinomialTree {\n    pub value: BinomialHeapValue,\n    pub order: u16,\n    pub refcount: u16,\n    pub subtrees: Vec<Option<Rc<RefCell<BinomialTree>>>>,\n}\n\n#[derive(Clone)]\npub struct BinomialHeapValue(i32);\n\npub type BinomialHeapCompareFunc = Box<dyn Fn(BinomialHeapValue, BinomialHeapValue) -> i32>;\n\npub const BINOMIAL_HEAP_TYPE_MIN: BinomialHeapType = BinomialHeapType;\n\npub fn binomial_tree_ref(tree: &mut Option<Rc<RefCell<BinomialTree>>>) {\n    if let Some(t) = tree {\n        t.borrow_mut().refcount += 1;\n    }\n}\n\npub fn binomial_heap_new(heap_type: BinomialHeapType, compare_func: BinomialHeapCompareFunc) -> Option<BinomialHeap> {\n    let mut new_heap = BinomialHeap {\n        heap_type,\n        compare_func,\n        num_values: 0,\n        roots: Vec::new(),\n        roots_length: 0,\n    };\n\n    Some(new_heap)\n}\n\npub fn binomial_tree_unref(tree: Option<Rc<RefCell<BinomialTree>>>) {\n    if let Some(tree_ref) = tree {\n        let mut tree_borrowed = tree_ref.borrow_mut();\n        tree_borrowed.refcount -= 1;\n\n        if tree_borrowed.refcount == 0 {\n            for subtree in &tree_borrowed.subtrees {\n                binomial_tree_unref(subtree.clone());\n            }\n            tree_borrowed.subtrees.clear();\n        }\n    }\n}\n\npub fn binomial_heap_merge_undo(new_roots: Vec<Option<Rc<RefCell<BinomialTree>>>>, count: usize) {\n    for i in 0..count {\n        binomial_tree_unref(new_roots.get(i).cloned().flatten());\n    }\n}\n\npub fn binomial_tree_merge(heap: &BinomialHeap, tree1: Rc<RefCell<BinomialTree>>, tree2: Rc<RefCell<BinomialTree>>) -> Option<Rc<RefCell<BinomialTree>>> {\n    let mut tree1 = tree1;\n    let mut tree2 = tree2;\n\n    // Order tree1 and tree2 so that tree1 is the tree with the smallest root\n    if binomial_heap_cmp(heap, tree1.borrow().value.clone(), tree2.borrow().value.clone()) > 0 {\n        std::mem::swap(&mut tree1, &mut tree2);\n    }\n\n    // Allocate a new tree\n    let mut new_tree = Rc::new(RefCell::new(BinomialTree {\n        value: tree1.borrow().value.clone(),\n        order: tree1.borrow().order + 1,\n        refcount: 0,\n        subtrees: vec![None; tree1.borrow().order as usize + 1],\n    }));\n\n    // Copy subtrees of the smallest tree. The last entry in the array is the larger tree\n    for i in 0..tree1.borrow().order as usize {\n        new_tree.borrow_mut().subtrees[i] = tree1.borrow().subtrees[i].clone();\n    }\n    new_tree.borrow_mut().subtrees[tree1.borrow().order as usize] = Some(tree2.clone());\n\n    // Add a reference to each of the subtrees we have referenced\n    for subtree in new_tree.borrow().subtrees.iter() {\n        if let Some(subtree) = subtree {\n            binomial_tree_ref(&mut Some(subtree.clone()));\n        }\n    }\n\n    Some(new_tree)\n}\n\npub fn binomial_heap_free(heap: BinomialHeap) {\n    let mut heap = heap;\n    for root in heap.roots.drain(..) {\n        binomial_tree_unref(root);\n    }\n}\n\npub fn binomial_heap_merge(heap: &mut BinomialHeap, other: &BinomialHeap) -> i32 {\n    let max = if heap.roots_length > other.roots_length {\n        heap.roots_length + 1\n    } else {\n        other.roots_length + 1\n    };\n\n    let mut new_roots = vec![None; max as usize];\n    let mut new_roots_length = 0;\n    let mut carry: Option<Rc<RefCell<BinomialTree>>> = None;\n    let mut new_carry: Option<Rc<RefCell<BinomialTree>>>;\n\n    for i in 0..max {\n        let mut vals = vec![None; 3];\n        let mut num_vals = 0;\n\n        if i < heap.roots_length && heap.roots[i as usize].is_some() {\n            vals[num_vals] = heap.roots[i as usize].clone();\n            num_vals += 1;\n        }\n\n        if i < other.roots_length && other.roots[i as usize].is_some() {\n            vals[num_vals] = other.roots[i as usize].clone();\n            num_vals += 1;\n        }\n\n        if carry.is_some() {\n            vals[num_vals] = carry.clone();\n            num_vals += 1;\n        }\n\n        if (num_vals & 1) != 0 {\n            new_roots[i as usize] = vals[num_vals - 1].clone();\n            if let Some(ref mut tree) = new_roots[i as usize] {\n                binomial_tree_ref(&mut Some(tree.clone()));\n            }\n            new_roots_length = i + 1;\n        } else {\n            new_roots[i as usize] = None;\n        }\n\n        if (num_vals & 2) != 0 {\n            new_carry = binomial_tree_merge(heap, vals[0].as_ref().unwrap().clone(), vals[1].as_ref().unwrap().clone());\n\n            if new_carry.is_none() {\n                binomial_heap_merge_undo(new_roots.clone(), i as usize);\n                binomial_tree_unref(carry);\n                return 0;\n            }\n        } else {\n            new_carry = None;\n        }\n\n        binomial_tree_unref(carry);\n        carry = new_carry;\n        if let Some(ref mut tree) = carry {\n            binomial_tree_ref(&mut Some(tree.clone()));\n        }\n    }\n\n    for i in 0..heap.roots_length {\n        if let Some(ref tree) = heap.roots[i as usize] {\n            binomial_tree_unref(Some(tree.clone()));\n        }\n    }\n\n    heap.roots = new_roots;\n    heap.roots_length = new_roots_length as u32;\n\n    1\n}\n\npub fn binomial_heap_cmp(heap: &BinomialHeap, data1: BinomialHeapValue, data2: BinomialHeapValue) -> i32 {\n    if heap.heap_type == BinomialHeapType {\n        return (heap.compare_func)(data1.clone(), data2.clone());\n    } else {\n        return -((heap.compare_func)(data1.clone(), data2.clone()));\n    }\n}\n\npub fn test_pop_out_of_memory() {\n    let mut heap: Option<BinomialHeap>;\n\n    for _ in 0..6 {\n        heap = generate_heap();\n\n        assert!(binomial_heap_pop(&mut heap.unwrap()).is_none());\n\n        binomial_heap_free(heap.unwrap());\n    }\n}\n\npub fn binomial_heap_pop(heap: &mut BinomialHeap) -> Option<BinomialHeapValue> {\n    if heap.num_values == 0 {\n        return None;\n    }\n\n    let mut least_index = None;\n\n    for (i, root) in heap.roots.iter().enumerate() {\n        if let Some(tree) = root {\n            if least_index.is_none() || binomial_heap_cmp(heap, tree.borrow().value.clone(), heap.roots[least_index.unwrap()].as_ref().unwrap().borrow().value.clone()) < 0 {\n                least_index = Some(i);\n            }\n        }\n    }\n\n    let least_index = match least_index {\n        Some(index) => index,\n        None => return None,\n    };\n\n    let least_tree = heap.roots[least_index].take().unwrap();\n\n    let mut fake_heap = BinomialHeap {\n        heap_type: heap.heap_type.clone(),\n        compare_func: heap.compare_func.clone(),\n        num_values: 0,\n        roots: least_tree.borrow().subtrees.clone(),\n        roots_length: least_tree.borrow().order as u32,\n    };\n\n    if binomial_heap_merge(heap, &mut fake_heap) == 1 {\n        let result = least_tree.borrow().value.clone();\n        binomial_tree_unref(Some(least_tree));\n        heap.num_values -= 1;\n        Some(result)\n    } else {\n        heap.roots[least_index] = Some(least_tree);\n        None\n    }\n}\n\npub fn generate_heap() -> Option<BinomialHeap> {\n    let mut heap = binomial_heap_new(BINOMIAL_HEAP_TYPE_MIN, Box::new(int_compare));\n\n    for i in 0..NUM_TEST_VALUES {\n        unsafe { TEST_ARRAY[i] = BinomialHeapValue(i as i32); }\n        if i != TEST_VALUE {\n            assert!(binomial_heap_insert(&mut heap.as_mut().unwrap(), unsafe { TEST_ARRAY[i].clone() }) != 0);\n        }\n    }\n\n    heap\n}\n\npub fn binomial_heap_insert(heap: &mut BinomialHeap, value: BinomialHeapValue) -> i32 {\n    let new_tree = Rc::new(RefCell::new(BinomialTree {\n        value,\n        order: 0,\n        refcount: 1,\n        subtrees: Vec::new(),\n    }));\n\n    let mut fake_heap = BinomialHeap {\n        heap_type: heap.heap_type.clone(),\n        compare_func: heap.compare_func.clone(),\n        num_values: 1,\n        roots: vec![Some(new_tree.clone())],\n        roots_length: 1,\n    };\n\n    let result = binomial_heap_merge(heap, &mut fake_heap);\n\n    if result != 0 {\n        heap.num_values += 1;\n    }\n\n    binomial_tree_unref(Some(new_tree));\n\n    result\n}\n\npub const NUM_TEST_VALUES: usize = 10000;\npub const TEST_VALUE: usize = NUM_TEST_VALUES / 2;\npub static mut TEST_ARRAY: [BinomialHeapValue; NUM_TEST_VALUES] = [BinomialHeapValue(0); NUM_TEST_VALUES];\n\npub fn int_compare(value1: BinomialHeapValue, value2: BinomialHeapValue) -> i32 {\n    value1.0.cmp(&value2.0) as i32\n}\n\nfn main(){}\n //编译报错信息：error[E0277]: the trait bound `BinomialHeapValue: Copy` is not satisfied\n   --> ../tmp/temp.rs:289:68\n    |\n289 | pub static mut TEST_ARRAY: [BinomialHeapValue; NUM_TEST_VALUES] = [BinomialHeapValue(0); NUM_TEST_VALUES];\n    |                                                                    ^^^^^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `BinomialHeapValue`\n    |\n",
        "test_binomial_heap_insert": "use std::rc::Rc;\nuse std::cell::RefCell;\n\npub struct BinomialHeapType;\n\nimpl PartialEq for BinomialHeapType {\n    fn eq(&self, _other: &Self) -> bool {\n        true\n    }\n}\n\nimpl Eq for BinomialHeapType {}\n\nimpl Clone for BinomialHeapType {\n    fn clone(&self) -> Self {\n        BinomialHeapType\n    }\n}\n\npub struct BinomialHeap {\n    pub heap_type: BinomialHeapType,\n    pub compare_func: BinomialHeapCompareFunc<BinomialHeapValue>,\n    pub num_values: u32,\n    pub roots: Vec<Option<Rc<RefCell<BinomialTree>>>>,\n    pub roots_length: u32,\n}\n\npub struct BinomialTree {\n    pub value: BinomialHeapValue,\n    pub order: u16,\n    pub refcount: u16,\n    pub subtrees: Vec<Option<Rc<RefCell<BinomialTree>>>>,\n}\n\n#[derive(Clone)]\npub struct BinomialHeapValue(i32);\n\npub type BinomialHeapCompareFunc<T> = Box<dyn Fn(T, T) -> i32>;\n\npub const NUM_TEST_VALUES: usize = 10000;\n\npub const BINOMIAL_HEAP_TYPE_MIN: BinomialHeapType = BinomialHeapType;\n\npub fn binomial_heap_num_entries(heap: &BinomialHeap) -> u32 {\n    heap.num_values\n}\n\npub fn binomial_heap_new(heap_type: BinomialHeapType, compare_func: BinomialHeapCompareFunc<BinomialHeapValue>) -> Option<BinomialHeap> {\n    let mut new_heap = BinomialHeap {\n        heap_type,\n        compare_func,\n        num_values: 0,\n        roots: Vec::new(),\n        roots_length: 0,\n    };\n\n    Some(new_heap)\n}\n\npub fn binomial_tree_ref(tree: &mut Option<Rc<RefCell<BinomialTree>>>) {\n    if let Some(t) = tree {\n        t.borrow_mut().refcount += 1;\n    }\n}\n\npub fn binomial_tree_unref(tree: Option<Rc<RefCell<BinomialTree>>>) {\n    if let Some(tree_ref) = tree {\n        let mut tree_borrowed = tree_ref.borrow_mut();\n        tree_borrowed.refcount -= 1;\n\n        if tree_borrowed.refcount == 0 {\n            for subtree in &tree_borrowed.subtrees {\n                binomial_tree_unref(subtree.clone());\n            }\n            tree_borrowed.subtrees.clear();\n        }\n    }\n}\n\npub fn binomial_heap_merge_undo(new_roots: Vec<Option<Rc<RefCell<BinomialTree>>>>, count: usize) {\n    for i in 0..count {\n        binomial_tree_unref(new_roots.get(i).cloned().flatten());\n    }\n}\n\npub fn binomial_tree_merge(heap: &BinomialHeap, tree1: Rc<RefCell<BinomialTree>>, tree2: Rc<RefCell<BinomialTree>>) -> Option<Rc<RefCell<BinomialTree>>> {\n    let mut tree1 = tree1;\n    let mut tree2 = tree2;\n\n    if binomial_heap_cmp(heap, tree1.borrow().value.clone(), tree2.borrow().value.clone()) > 0 {\n        std::mem::swap(&mut tree1, &mut tree2);\n    }\n\n    let mut new_tree = Rc::new(RefCell::new(BinomialTree {\n        value: tree1.borrow().value.clone(),\n        order: tree1.borrow().order + 1,\n        refcount: 0,\n        subtrees: vec![None; tree1.borrow().order as usize + 1],\n    }));\n\n    for i in 0..tree1.borrow().order as usize {\n        new_tree.borrow_mut().subtrees[i] = tree1.borrow().subtrees[i].clone();\n    }\n    new_tree.borrow_mut().subtrees[tree1.borrow().order as usize] = Some(tree2.clone());\n\n    for subtree in new_tree.borrow().subtrees.iter() {\n        if let Some(subtree) = subtree {\n            binomial_tree_ref(&mut Some(subtree.clone()));\n        }\n    }\n\n    Some(new_tree)\n}\n\npub fn binomial_heap_free(heap: BinomialHeap) {\n    let mut heap = heap;\n    for root in heap.roots.drain(..) {\n        binomial_tree_unref(root);\n    }\n}\n\npub fn binomial_heap_merge(heap: &mut BinomialHeap, other: &BinomialHeap) -> i32 {\n    let max = if heap.roots_length > other.roots_length {\n        heap.roots_length + 1\n    } else {\n        other.roots_length + 1\n    };\n\n    let mut new_roots = vec![None; max as usize];\n    let mut new_roots_length = 0;\n    let mut carry: Option<Rc<RefCell<BinomialTree>>> = None;\n    let mut new_carry: Option<Rc<RefCell<BinomialTree>>>;\n\n    for i in 0..max {\n        let mut vals = vec![None; 3];\n        let mut num_vals = 0;\n\n        if i < heap.roots_length && heap.roots[i as usize].is_some() {\n            vals[num_vals] = heap.roots[i as usize].clone();\n            num_vals += 1;\n        }\n\n        if i < other.roots_length && other.roots[i as usize].is_some() {\n            vals[num_vals] = other.roots[i as usize].clone();\n            num_vals += 1;\n        }\n\n        if carry.is_some() {\n            vals[num_vals] = carry.clone();\n            num_vals += 1;\n        }\n\n        if (num_vals & 1) != 0 {\n            new_roots[i as usize] = vals[num_vals - 1].clone();\n            if let Some(ref mut tree) = new_roots[i as usize] {\n                binomial_tree_ref(&mut Some(tree.clone()));\n            }\n            new_roots_length = i + 1;\n        } else {\n            new_roots[i as usize] = None;\n        }\n\n        if (num_vals & 2) != 0 {\n            new_carry = binomial_tree_merge(heap, vals[0].as_ref().unwrap().clone(), vals[1].as_ref().unwrap().clone());\n\n            if new_carry.is_none() {\n                binomial_heap_merge_undo(new_roots.clone(), i as usize);\n                binomial_tree_unref(carry);\n                return 0;\n            }\n        } else {\n            new_carry = None;\n        }\n\n        binomial_tree_unref(carry);\n        carry = new_carry;\n        if let Some(ref mut tree) = carry {\n            binomial_tree_ref(&mut Some(tree.clone()));\n        }\n    }\n\n    for i in 0..heap.roots_length {\n        if let Some(ref tree) = heap.roots[i as usize] {\n            binomial_tree_unref(Some(tree.clone()));\n        }\n    }\n\n    heap.roots = new_roots;\n    heap.roots_length = new_roots_length as u32;\n\n    1\n}\n\npub fn binomial_heap_cmp(heap: &BinomialHeap, data1: BinomialHeapValue, data2: BinomialHeapValue) -> i32 {\n    if heap.heap_type == BinomialHeapType {\n        return (heap.compare_func)(data1.clone(), data2.clone());\n    } else {\n        return -((heap.compare_func)(data1.clone(), data2.clone()));\n    }\n}\n\npub fn test_binomial_heap_insert() {\n    let mut heap = binomial_heap_new(BINOMIAL_HEAP_TYPE_MIN, Box::new(int_compare)).unwrap();\n    let mut test_array = vec![0; NUM_TEST_VALUES];\n\n    for i in 0..NUM_TEST_VALUES {\n        test_array[i] = i as i32;\n        assert!(binomial_heap_insert(&mut heap, BinomialHeapValue(test_array[i])) != 0);\n    }\n    assert!(binomial_heap_num_entries(&heap) == NUM_TEST_VALUES as u32);\n\n    binomial_heap_free(heap);\n}\n\npub fn binomial_heap_insert(heap: &mut BinomialHeap, value: BinomialHeapValue) -> i32 {\n    let mut new_tree = Rc::new(RefCell::new(BinomialTree {\n        value,\n        order: 0,\n        refcount: 1,\n        subtrees: Vec::new(),\n    }));\n\n    let mut fake_heap = BinomialHeap {\n        heap_type: heap.heap_type.clone(),\n        compare_func: heap.compare_func.clone(),\n        num_values: 1,\n        roots: vec![Some(new_tree.clone())],\n        roots_length: 1,\n    };\n\n    let result = binomial_heap_merge(heap, &mut fake_heap);\n\n    if result != 0 {\n        heap.num_values += 1;\n    }\n\n    binomial_tree_unref(Some(new_tree));\n\n    result\n}\n\npub fn int_compare(value1: BinomialHeapValue, value2: BinomialHeapValue) -> i32 {\n    value1.0.cmp(&value2.0) as i32\n}\n\nfn main(){}\n //编译报错信息：error[E0599]: the method `clone` exists for struct `Box<dyn Fn(BinomialHeapValue, BinomialHeapValue) -> i32>`, but its trait bounds were not satisfied\n   --> ../tmp/temp.rs:225:41\n    |\n225 |           compare_func: heap.compare_func.clone(),\n    |                                           ^^^^^ method cannot be called due to unsatisfied trait bounds\n    |\n",
        "test_max_heap": "use std::rc::Rc;\nuse std::cell::RefCell;\n\npub struct BinomialHeapType;\n\nimpl PartialEq for BinomialHeapType {\n    fn eq(&self, _other: &Self) -> bool {\n        true\n    }\n}\n\nimpl Eq for BinomialHeapType {}\nimpl Clone for BinomialHeapType {\n    fn clone(&self) -> Self {\n        BinomialHeapType\n    }\n}\n\npub struct BinomialHeap {\n    pub heap_type: BinomialHeapType,\n    pub compare_func: BinomialHeapCompareFunc,\n    pub num_values: u32,\n    pub roots: Vec<Option<Rc<RefCell<BinomialTree>>>>,\n    pub roots_length: u32,\n}\n\npub struct BinomialTree {\n    pub value: BinomialHeapValue,\n    pub order: u16,\n    pub refcount: u16,\n    pub subtrees: Vec<Option<Rc<RefCell<BinomialTree>>>>,\n}\n\n#[derive(Clone, PartialEq, Eq, Debug)]\npub struct BinomialHeapValue(pub i32);\n\npub type BinomialHeapCompareFunc = Box<dyn Fn(BinomialHeapValue, BinomialHeapValue) -> i32>;\n\npub const NUM_TEST_VALUES: usize = 10000;\n\npub const BINOMIAL_HEAP_TYPE_MIN: BinomialHeapType = BinomialHeapType;\npub fn binomial_heap_num_entries(heap: &BinomialHeap) -> u32 {\n    heap.num_values\n}\n\npub fn binomial_heap_merge_undo(new_roots: Vec<Option<Rc<RefCell<BinomialTree>>>>, count: usize) {\n    for i in 0..count {\n        binomial_tree_unref(new_roots.get(i).cloned().flatten());\n    }\n}\n\npub fn binomial_tree_merge(heap: &BinomialHeap, tree1: Rc<RefCell<BinomialTree>>, tree2: Rc<RefCell<BinomialTree>>) -> Option<Rc<RefCell<BinomialTree>>> {\n    let mut tree1 = tree1;\n    let mut tree2 = tree2;\n\n    if binomial_heap_cmp(heap, tree1.borrow().value.clone(), tree2.borrow().value.clone()) > 0 {\n        std::mem::swap(&mut tree1, &mut tree2);\n    }\n\n    let mut new_tree = Rc::new(RefCell::new(BinomialTree {\n        value: tree1.borrow().value.clone(),\n        order: tree1.borrow().order + 1,\n        refcount: 0,\n        subtrees: vec![None; tree1.borrow().order as usize + 1],\n    }));\n\n    for i in 0..tree1.borrow().order as usize {\n        new_tree.borrow_mut().subtrees[i] = tree1.borrow().subtrees[i].clone();\n    }\n    new_tree.borrow_mut().subtrees[tree1.borrow().order as usize] = Some(tree2.clone());\n\n    for subtree in new_tree.borrow().subtrees.iter() {\n        if let Some(subtree) = subtree {\n            binomial_tree_ref(&mut Some(subtree.clone()));\n        }\n    }\n\n    Some(new_tree)\n}\n\npub fn binomial_heap_free(heap: BinomialHeap) {\n    let mut heap = heap;\n    for root in heap.roots.drain(..) {\n        binomial_tree_unref(root);\n    }\n}\n\npub fn binomial_heap_merge(heap: &mut BinomialHeap, other: &BinomialHeap) -> i32 {\n    let max = if heap.roots_length > other.roots_length {\n        heap.roots_length + 1\n    } else {\n        other.roots_length + 1\n    };\n\n    let mut new_roots = vec![None; max as usize];\n    let mut new_roots_length = 0;\n    let mut carry: Option<Rc<RefCell<BinomialTree>>> = None;\n    let mut new_carry: Option<Rc<RefCell<BinomialTree>>>;\n\n    for i in 0..max {\n        let mut vals = vec![None; 3];\n        let mut num_vals = 0;\n\n        if i < heap.roots_length && heap.roots[i as usize].is_some() {\n            vals[num_vals] = heap.roots[i as usize].clone();\n            num_vals += 1;\n        }\n\n        if i < other.roots_length && other.roots[i as usize].is_some() {\n            vals[num_vals] = other.roots[i as usize].clone();\n            num_vals += 1;\n        }\n\n        if carry.is_some() {\n            vals[num_vals] = carry.clone();\n            num_vals += 1;\n        }\n\n        if (num_vals & 1) != 0 {\n            new_roots[i as usize] = vals[num_vals - 1].clone();\n            if let Some(ref mut tree) = new_roots[i as usize] {\n                binomial_tree_ref(&mut Some(tree.clone()));\n            }\n            new_roots_length = i + 1;\n        } else {\n            new_roots[i as usize] = None;\n        }\n\n        if (num_vals & 2) != 0 {\n            new_carry = binomial_tree_merge(heap, vals[0].as_ref().unwrap().clone(), vals[1].as_ref().unwrap().clone());\n\n            if new_carry.is_none() {\n                binomial_heap_merge_undo(new_roots.clone(), i as usize);\n                binomial_tree_unref(carry);\n                return 0;\n            }\n        } else {\n            new_carry = None;\n        }\n\n        binomial_tree_unref(carry);\n        carry = new_carry;\n        if let Some(ref mut tree) = carry {\n            binomial_tree_ref(&mut Some(tree.clone()));\n        }\n    }\n\n    for i in 0..heap.roots_length {\n        if let Some(ref tree) = heap.roots[i as usize] {\n            binomial_tree_unref(Some(tree.clone()));\n        }\n    }\n\n    heap.roots = new_roots;\n    heap.roots_length = new_roots_length as u32;\n\n    1\n}\n\npub fn binomial_heap_cmp(heap: &BinomialHeap, data1: BinomialHeapValue, data2: BinomialHeapValue) -> i32 {\n    if heap.heap_type == BinomialHeapType {\n        return (heap.compare_func)(data1.clone(), data2.clone());\n    } else {\n        return -((heap.compare_func)(data1.clone(), data2.clone()));\n    }\n}\n\npub fn test_max_heap() {\n    let mut heap = binomial_heap_new(BINOMIAL_HEAP_TYPE_MIN, Box::new(int_compare)).unwrap();\n\n    for i in 0..NUM_TEST_VALUES {\n        unsafe { test_array[i] = i as i32; }\n        assert!(binomial_heap_insert(&mut heap, BinomialHeapValue(unsafe { test_array[i] })) != 0);\n    }\n\n    let mut i = NUM_TEST_VALUES;\n    while binomial_heap_num_entries(&heap) > 0 {\n        let val = binomial_heap_pop(&mut heap);\n\n        assert_eq!(val, BinomialHeapValue((i - 1) as i32));\n        i = val.0 as usize;\n    }\n\n    let val = binomial_heap_pop(&mut heap);\n    assert_eq!(val, BINOMIAL_HEAP_NULL);\n\n    binomial_heap_free(heap);\n}\n\npub fn binomial_heap_pop(heap: &mut BinomialHeap) -> BinomialHeapValue {\n    if heap.num_values == 0 {\n        return BINOMIAL_HEAP_NULL;\n    }\n\n    let mut least_index = u32::MAX;\n\n    for i in 0..heap.roots_length {\n        if let Some(tree) = &heap.roots[i as usize] {\n            if least_index == u32::MAX || binomial_heap_cmp(heap, tree.borrow().value.clone(), heap.roots[least_index as usize].as_ref().unwrap().borrow().value.clone()) < 0 {\n                least_index = i;\n            }\n        }\n    }\n\n    let least_tree = heap.roots[least_index as usize].take().unwrap();\n\n    let mut fake_heap = BinomialHeap {\n        heap_type: heap.heap_type.clone(),\n        compare_func: heap.compare_func.clone(),\n        num_values: 0,\n        roots: least_tree.borrow().subtrees.clone(),\n        roots_length: least_tree.borrow().order,\n    };\n\n    if binomial_heap_merge(heap, &mut fake_heap) != 0 {\n        let result = least_tree.borrow().value.clone();\n        binomial_tree_unref(Some(least_tree));\n\n        heap.num_values -= 1;\n\n        return result;\n    } else {\n        heap.roots[least_index as usize] = Some(least_tree);\n\n        return BINOMIAL_HEAP_NULL;\n    }\n}\n\npub fn binomial_heap_insert(heap: &mut BinomialHeap, value: BinomialHeapValue) -> i32 {\n    let new_tree = Rc::new(RefCell::new(BinomialTree {\n        value: value.clone(),\n        order: 0,\n        refcount: 0,\n        subtrees: Vec::new(),\n    }));\n\n    binomial_tree_ref(&mut Some(new_tree.clone()));\n\n    let mut fake_heap = BinomialHeap {\n        heap_type: heap.heap_type.clone(),\n        compare_func: heap.compare_func.clone(),\n        num_values: 1,\n        roots: vec![Some(new_tree)],\n        roots_length: 1,\n    };\n\n    let result = binomial_heap_merge(heap, &mut fake_heap);\n\n    if result != 0 {\n        heap.num_values += 1;\n    }\n\n    binomial_tree_unref(Some(new_tree));\n\n    result\n}\n\npub const BINOMIAL_HEAP_NULL: BinomialHeapValue = BinomialHeapValue(0);\n\npub static mut test_array: [i32; NUM_TEST_VALUES] = [0; NUM_TEST_VALUES];\n\npub fn int_compare(value1: BinomialHeapValue, value2: BinomialHeapValue) -> i32 {\n    value1.0.cmp(&value2.0) as i32\n}\n\npub fn binomial_tree_ref(tree: &mut Option<Rc<RefCell<BinomialTree>>>) {\n    if let Some(t) = tree {\n        t.borrow_mut().refcount += 1;\n    }\n}\n\npub fn binomial_heap_new(heap_type: BinomialHeapType, compare_func: BinomialHeapCompareFunc) -> Option<BinomialHeap> {\n    let mut new_heap = BinomialHeap {\n        heap_type,\n        compare_func,\n        num_values: 0,\n        roots: Vec::new(),\n        roots_length: 0,\n    };\n\n    Some(new_heap)\n}\n\npub fn binomial_tree_unref(tree: Option<Rc<RefCell<BinomialTree>>>) {\n    if let Some(tree_ref) = tree {\n        let mut tree_borrowed = tree_ref.borrow_mut();\n        tree_borrowed.refcount -= 1;\n\n        if tree_borrowed.refcount == 0 {\n            for subtree in &tree_borrowed.subtrees {\n                binomial_tree_unref(subtree.clone());\n            }\n            tree_borrowed.subtrees.clear();\n        }\n    }\n}\n\nfn main(){}\n //编译报错信息：error[E0599]: the method `clone` exists for struct `Box<dyn Fn(BinomialHeapValue, BinomialHeapValue) -> i32>`, but its trait bounds were not satisfied\n   --> ../tmp/temp.rs:209:41\n    |\n209 |           compare_func: heap.compare_func.clone(),\n    |                                           ^^^^^ method cannot be called due to unsatisfied trait bounds\n    |\n",
        "test_min_heap": "use std::rc::Rc;\nuse std::cell::RefCell;\n\npub struct BinomialHeapType;\n\nimpl PartialEq for BinomialHeapType {\n    fn eq(&self, _other: &Self) -> bool {\n        true\n    }\n}\n\nimpl Eq for BinomialHeapType {}\n\npub struct BinomialHeap {\n    pub heap_type: BinomialHeapType,\n    pub compare_func: BinomialHeapCompareFunc,\n    pub num_values: u32,\n    pub roots: Vec<Option<Rc<RefCell<BinomialTree>>>>,\n    pub roots_length: u32,\n}\n\npub struct BinomialTree {\n    pub value: BinomialHeapValue,\n    pub order: u16,\n    pub refcount: u16,\n    pub subtrees: Vec<Option<Rc<RefCell<BinomialTree>>>>,\n}\n\n#[derive(Clone, PartialEq, Eq, Debug)]\npub struct BinomialHeapValue(i32);\n\npub type BinomialHeapCompareFunc = Box<dyn Fn(BinomialHeapValue, BinomialHeapValue) -> i32>;\n\npub const NUM_TEST_VALUES: usize = 10000;\n\npub const BINOMIAL_HEAP_TYPE_MIN: BinomialHeapType = BinomialHeapType;\n\npub fn binomial_heap_num_entries(heap: &BinomialHeap) -> u32 {\n    heap.num_values\n}\n\npub fn binomial_heap_merge_undo(new_roots: Vec<Option<Rc<RefCell<BinomialTree>>>>, count: usize) {\n    for i in 0..count {\n        binomial_tree_unref(new_roots.get(i).cloned().flatten());\n    }\n}\n\npub fn binomial_tree_merge(heap: &BinomialHeap, tree1: Rc<RefCell<BinomialTree>>, tree2: Rc<RefCell<BinomialTree>>) -> Option<Rc<RefCell<BinomialTree>>> {\n    let mut tree1 = tree1;\n    let mut tree2 = tree2;\n\n    if binomial_heap_cmp(heap, tree1.borrow().value.clone(), tree2.borrow().value.clone()) > 0 {\n        std::mem::swap(&mut tree1, &mut tree2);\n    }\n\n    let mut new_tree = Rc::new(RefCell::new(BinomialTree {\n        value: tree1.borrow().value.clone(),\n        order: tree1.borrow().order + 1,\n        refcount: 0,\n        subtrees: vec![None; tree1.borrow().order as usize + 1],\n    }));\n\n    for i in 0..tree1.borrow().order as usize {\n        new_tree.borrow_mut().subtrees[i] = tree1.borrow().subtrees[i].clone();\n    }\n    new_tree.borrow_mut().subtrees[tree1.borrow().order as usize] = Some(tree2.clone());\n\n    for subtree in new_tree.borrow().subtrees.iter() {\n        if let Some(subtree) = subtree {\n            binomial_tree_ref(&mut Some(subtree.clone()));\n        }\n    }\n\n    Some(new_tree)\n}\n\npub fn binomial_heap_free(heap: BinomialHeap) {\n    let mut heap = heap;\n    for root in heap.roots.drain(..) {\n        binomial_tree_unref(root);\n    }\n}\n\npub fn binomial_heap_merge(heap: &mut BinomialHeap, other: &BinomialHeap) -> i32 {\n    let max = if heap.roots_length > other.roots_length {\n        heap.roots_length + 1\n    } else {\n        other.roots_length + 1\n    };\n\n    let mut new_roots = vec![None; max as usize];\n    let mut new_roots_length = 0;\n    let mut carry: Option<Rc<RefCell<BinomialTree>>> = None;\n    let mut new_carry: Option<Rc<RefCell<BinomialTree>>>;\n\n    for i in 0..max {\n        let mut vals = vec![None; 3];\n        let mut num_vals = 0;\n\n        if i < heap.roots_length && heap.roots[i as usize].is_some() {\n            vals[num_vals] = heap.roots[i as usize].clone();\n            num_vals += 1;\n        }\n\n        if i < other.roots_length && other.roots[i as usize].is_some() {\n            vals[num_vals] = other.roots[i as usize].clone();\n            num_vals += 1;\n        }\n\n        if carry.is_some() {\n            vals[num_vals] = carry.clone();\n            num_vals += 1;\n        }\n\n        if (num_vals & 1) != 0 {\n            new_roots[i as usize] = vals[num_vals - 1].clone();\n            if let Some(ref mut tree) = new_roots[i as usize] {\n                binomial_tree_ref(&mut Some(tree.clone()));\n            }\n            new_roots_length = i + 1;\n        } else {\n            new_roots[i as usize] = None;\n        }\n\n        if (num_vals & 2) != 0 {\n            new_carry = binomial_tree_merge(heap, vals[0].as_ref().unwrap().clone(), vals[1].as_ref().unwrap().clone());\n\n            if new_carry.is_none() {\n                binomial_heap_merge_undo(new_roots.clone(), i as usize);\n                binomial_tree_unref(carry);\n                return 0;\n            }\n        } else {\n            new_carry = None;\n        }\n\n        binomial_tree_unref(carry);\n        carry = new_carry;\n        if let Some(ref mut tree) = carry {\n            binomial_tree_ref(&mut Some(tree.clone()));\n        }\n    }\n\n    for i in 0..heap.roots_length {\n        if let Some(ref tree) = heap.roots[i as usize] {\n            binomial_tree_unref(Some(tree.clone()));\n        }\n    }\n\n    heap.roots = new_roots;\n    heap.roots_length = new_roots_length as u32;\n\n    1\n}\n\npub fn binomial_heap_cmp(heap: &BinomialHeap, data1: BinomialHeapValue, data2: BinomialHeapValue) -> i32 {\n    if heap.heap_type == BinomialHeapType {\n        return (heap.compare_func)(data1.clone(), data2.clone());\n    } else {\n        return -((heap.compare_func)(data1.clone(), data2.clone()));\n    }\n}\n\npub fn test_min_heap() {\n    let mut heap = binomial_heap_new(BINOMIAL_HEAP_TYPE_MIN, Box::new(int_compare)).unwrap();\n    let mut test_array = vec![0; NUM_TEST_VALUES];\n\n    for i in 0..NUM_TEST_VALUES {\n        test_array[i] = i as i32;\n        assert!(binomial_heap_insert(&mut heap, BinomialHeapValue(test_array[i])) != 0);\n    }\n\n    let mut i = -1;\n    while binomial_heap_num_entries(&heap) > 0 {\n        let val = binomial_heap_pop(&mut heap);\n\n        assert_eq!(val, BinomialHeapValue(i + 1));\n        i = val.0;\n    }\n\n    let val = binomial_heap_pop(&mut heap);\n    assert_eq!(val, BinomialHeapValue(0));\n\n    binomial_heap_free(heap);\n}\n\npub fn binomial_heap_pop(heap: &mut BinomialHeap) -> BinomialHeapValue {\n    if heap.num_values == 0 {\n        return BinomialHeapValue(0);\n    }\n\n    let mut least_index = usize::MAX;\n\n    for i in 0..heap.roots_length as usize {\n        if heap.roots[i].is_none() {\n            continue;\n        }\n\n        if least_index == usize::MAX\n            || binomial_heap_cmp(heap, heap.roots[i].as_ref().unwrap().borrow().value.clone(), heap.roots[least_index].as_ref().unwrap().borrow().value.clone()) < 0\n        {\n            least_index = i;\n        }\n    }\n\n    let least_tree = heap.roots[least_index].take().unwrap();\n\n    let mut fake_heap = BinomialHeap {\n        heap_type: heap.heap_type.clone(),\n        compare_func: heap.compare_func.clone(),\n        num_values: 0,\n        roots: least_tree.borrow().subtrees.clone(),\n        roots_length: least_tree.borrow().order,\n    };\n\n    if binomial_heap_merge(heap, &mut fake_heap) != 0 {\n        let result = least_tree.borrow().value.clone();\n        binomial_tree_unref(Some(least_tree));\n        heap.num_values -= 1;\n        result\n    } else {\n        heap.roots[least_index] = Some(least_tree);\n        BinomialHeapValue(0)\n    }\n}\n\npub fn binomial_heap_insert(heap: &mut BinomialHeap, value: BinomialHeapValue) -> i32 {\n    let new_tree = Rc::new(RefCell::new(BinomialTree {\n        value,\n        order: 0,\n        refcount: 0,\n        subtrees: Vec::new(),\n    }));\n\n    binomial_tree_ref(&mut Some(new_tree.clone()));\n\n    let mut fake_heap = BinomialHeap {\n        heap_type: heap.heap_type.clone(),\n        compare_func: heap.compare_func.clone(),\n        num_values: 1,\n        roots: vec![Some(new_tree)],\n        roots_length: 1,\n    };\n\n    let result = binomial_heap_merge(heap, &mut fake_heap);\n\n    if result != 0 {\n        heap.num_values += 1;\n    }\n\n    binomial_tree_unref(Some(new_tree));\n\n    result\n}\n\npub fn binomial_heap_new(heap_type: BinomialHeapType, compare_func: BinomialHeapCompareFunc) -> Option<BinomialHeap> {\n    let mut new_heap = BinomialHeap {\n        heap_type,\n        compare_func,\n        num_values: 0,\n        roots: Vec::new(),\n        roots_length: 0,\n    };\n\n    Some(new_heap)\n}\n\npub fn binomial_tree_unref(tree: Option<Rc<RefCell<BinomialTree>>>) {\n    if let Some(tree_ref) = tree {\n        let mut tree_borrowed = tree_ref.borrow_mut();\n        tree_borrowed.refcount -= 1;\n\n        if tree_borrowed.refcount == 0 {\n            for subtree in &tree_borrowed.subtrees {\n                binomial_tree_unref(subtree.clone());\n            }\n            tree_borrowed.subtrees.clear();\n        }\n    }\n}\n\npub fn binomial_tree_ref(tree: &mut Option<Rc<RefCell<BinomialTree>>>) {\n    if let Some(t) = tree {\n        t.borrow_mut().refcount += 1;\n    }\n}\n\npub fn int_compare(value1: BinomialHeapValue, value2: BinomialHeapValue) -> i32 {\n    value1.0.cmp(&value2.0) as i32\n}\n\nfn main(){}\n //编译报错信息：error[E0599]: no method named `clone` found for struct `BinomialHeapType` in the current scope\n   --> ../tmp/temp.rs:209:35\n    |\n4   | pub struct BinomialHeapType;\n    | --------------------------- method `clone` not found for this struct\n...\n209 |         heap_type: heap.heap_type.clone(),\n    |                                   ^^^^^ method not found in `BinomialHeapType`\n    |\n    = help: items from traits can only be used if the trait is implemented and in scope\n"
    },
    "test-sortedarray": {
        "test_sortedarray_insert": "\nuse std::cmp::Ordering;\n\npub fn sortedarray_get<T>(array: Option<&SortedArray<T>>, i: usize) -> Option<&T> {\n    if let Some(array) = array {\n        if i < array.length {\n            return Some(&array.data[i]);\n        }\n    }\n    None\n}\n\npub struct SortedArray<T> {\n    pub data: Vec<T>,\n    pub length: usize,\n    _alloced: usize,\n    pub equ_func: SortedArrayEqualFunc<T>,\n    pub cmp_func: SortedArrayCompareFunc<T>,\n}\n\npub type SortedArrayCompareFunc<T> = fn(&T, &T) -> i32;\npub type SortedArrayEqualFunc<T> = fn(&T, &T) -> bool;\n\nimpl<T: Clone> SortedArray<T> {\n    pub fn new(length: usize, equ_func: SortedArrayEqualFunc<T>, cmp_func: SortedArrayCompareFunc<T>) -> Option<Box<Self>> {\n        if equ_func as *const () == std::ptr::null() || cmp_func as *const () == std::ptr::null() {\n            return None;\n        }\n\n        let mut len = length;\n        if len == 0 {\n            len = 16;\n        }\n\n        let array = vec![unsafe { std::mem::zeroed() }; len];\n\n        Some(Box::new(Self {\n            data: array,\n            length: 0,\n            _alloced: len,\n            equ_func,\n            cmp_func,\n        }))\n    }\n}\n\nimpl<T> Drop for SortedArray<T> {\n    fn drop(&mut self) {\n        self.data.clear();\n    }\n}\n\npub fn free_sorted_ints(sortedarray: Option<Box<SortedArray<i32>>>) {\n    if let Some(sa) = sortedarray {\n        for i in 0..sortedarray_length(&sa) {\n            if let Some(_value) = sortedarray_get(Some(&sa), i) {\n                // In Rust, we don't need to manually free memory for integers as they are owned and dropped automatically.\n                // However, if the values were boxed or held in smart pointers, we would need to handle them accordingly.\n            }\n        }\n        sortedarray_free(Some(sa));\n    }\n}\n\npub fn generate_sortedarray() -> Option<Box<SortedArray<i32>>> {\n    generate_sortedarray_equ(int_equal)\n}\n\npub fn sortedarray_insert<T: Clone>(sortedarray: &mut SortedArray<T>, data: T) -> i32 {\n    let mut left = 0;\n    let mut right = sortedarray.length;\n    let mut index = 0;\n\n    right = if right > 1 { right } else { 0 };\n\n    while left != right {\n        index = (left + right) / 2;\n\n        let order = (sortedarray.cmp_func)(&data, &sortedarray.data[index]);\n        if order < 0 {\n            right = index;\n        } else if order > 0 {\n            left = index + 1;\n        } else {\n            break;\n        }\n    }\n\n    if sortedarray.length > 0 && (sortedarray.cmp_func)(&data, &sortedarray.data[index]) > 0 {\n        index += 1;\n    }\n\n    if sortedarray.length + 1 > sortedarray._alloced {\n        let newsize = sortedarray._alloced * 2;\n        let mut new_data = vec![unsafe { std::mem::zeroed() }; newsize];\n        new_data[..sortedarray.length].clone_from_slice(&sortedarray.data);\n        sortedarray.data = new_data;\n        sortedarray._alloced = newsize;\n    }\n\n    sortedarray.data.insert(index, data);\n    sortedarray.length += 1;\n\n    1\n}\n\npub fn check_sorted_prop<T>(sortedarray: &SortedArray<T>)\nwhere\n    T: std::cmp::Ord,\n{\n    for i in 1..sortedarray_length(sortedarray) {\n        assert!((sortedarray.cmp_func)(&sortedarray_get(Some(sortedarray), i - 1).unwrap(), &sortedarray_get(Some(sortedarray), i).unwrap()) <= 0);\n    }\n}\n\npub fn sortedarray_length<T>(array: &SortedArray<T>) -> usize {\n    array.length\n}\n\npub fn generate_sortedarray_equ(equ_func: SortedArrayEqualFunc<i32>) -> Option<Box<SortedArray<i32>>> {\n    const TEST_SIZE: usize = 20;\n    let array: [i32; TEST_SIZE] = [10, 12, 12, 1, 2, 3, 6, 7, 2, 23, 13, 23, 23, 34, 31, 9, 0, 0, 0, 0]; // Assuming the rest are zeros or can be ignored\n\n    let mut sortedarray = SortedArray::new(0, equ_func, int_compare)?;\n\n    for &value in &array[..TEST_SIZE] {\n        let data = value; // Directly use the value instead of allocating memory\n        sortedarray_insert(&mut sortedarray, data);\n    }\n\n    Some(sortedarray)\n}\n\npub fn sortedarray_free<T>(sortedarray: Option<Box<SortedArray<T>>>) {\n    if let Some(mut sa) = sortedarray {\n        sa.data.clear();\n    }\n}\n\nfn int_compare(a: &i32, b: &i32) -> i32 {\n    a.cmp(b) as i32\n}\n\nfn int_equal(a: &i32, b: &i32) -> bool {\n    a == b\n}\n\npub fn test_sortedarray_insert() {\n    let mut sortedarray = generate_sortedarray().unwrap();\n    let mut rng = rand::thread_rng();\n\n    for _ in 0..20 {\n        let i = rng.gen_range(0..100);\n        sortedarray_insert(&mut sortedarray, i);\n    }\n\n    check_sorted_prop(&sortedarray);\n    free_sorted_ints(Some(sortedarray));\n}\n\nfn main() {\n    test_sortedarray_insert();\n}\n\n// Removed the unused import and added the missing `rand` crate dependency\nuse rand::Rng; // Added to use `rand::thread_rng()`\n\n //编译报错信息：error[E0432]: unresolved import `rand`\n   --> ../tmp/temp.rs:166:5\n    |\n166 | use rand::Rng; // Added to use `rand::thread_rng()`\n    |     ^^^^ you might be missing crate `rand`\n    |\n"
    },
    "test-hash-table": {
        "test_hash_table_free_functions": "\npub fn new_key<T>(value: T) -> Option<Box<T>> {\n    let result = Box::new(value);\n    ALLOCATED_KEYS.with(|keys| keys.set(keys.get() + 1));\n    Some(result)\n}\n\npub fn hash_table_new(hash_func: HashTableHashFunc, equal_func: HashTableEqualFunc) -> Option<Box<HashTable>> {\n    let mut hash_table = Box::new(HashTable {\n        table: Vec::new(),\n        table_size: 0,\n        hash_func,\n        equal_func,\n        key_free_func: None,\n        value_free_func: None,\n        entries: 0,\n        prime_index: 0,\n    });\n\n    if !hash_table_allocate_table(&mut hash_table) {\n        return None;\n    }\n\n    Some(hash_table)\n}\n\npub fn hash_table_register_free_functions(hash_table: &mut HashTable, key_free_func: Option<HashTableKeyFreeFunc>, value_free_func: Option<HashTableValueFreeFunc>) {\n    hash_table.key_free_func = key_free_func;\n    hash_table.value_free_func = value_free_func;\n}\n\npub fn hash_table_enlarge(hash_table: &mut HashTable) -> bool {\n    let mut old_table = std::mem::replace(&mut hash_table.table, Vec::new());\n    let old_table_size = hash_table.table_size;\n    let old_prime_index = hash_table.prime_index;\n\n    hash_table.prime_index += 1;\n\n    if !hash_table_allocate_table(hash_table) {\n        hash_table.table = old_table;\n        hash_table.table_size = old_table_size;\n        hash_table.prime_index = old_prime_index;\n        return false;\n    }\n\n    for i in 0..old_table_size {\n        let mut rover = old_table[i as usize].take();\n        while let Some(mut entry) = rover {\n            let next = entry.next.take();\n            let pair = entry.pair;\n            let index = (hash_table.hash_func)(pair.0) % hash_table.table_size;\n            entry.next = hash_table.table[index as usize].take();\n            hash_table.table[index as usize] = Some(entry);\n            rover = next;\n        }\n    }\n\n    true\n}\n\npub fn hash_table_remove(hash_table: &mut HashTable, key: HashTableKey) -> i32 {\n    let index = (hash_table.hash_func)(key) % hash_table.table_size;\n\n    let mut rover = &mut hash_table.table[index as usize];\n    let mut result = 0;\n\n    while let Some(entry) = rover.take() {\n        let pair = &entry.pair;\n\n        if (hash_table.equal_func)(key, pair.0) != 0 {\n            hash_table_free_entry(hash_table, entry);\n            hash_table.entries -= 1;\n            result = 1;\n            break;\n        } else {\n            *rover = entry.next;\n            rover = &mut rover.as_mut().unwrap().next;\n        }\n    }\n\n    result\n}\n\npub fn hash_table_allocate_table(hash_table: &mut HashTable) -> bool {\n    let new_table_size: u32;\n\n    if hash_table.prime_index < HASH_TABLE_NUM_PRIMES {\n        new_table_size = HASH_TABLE_PRIMES[hash_table.prime_index as usize];\n    } else {\n        new_table_size = hash_table.entries * 10;\n    }\n\n    hash_table.table_size = new_table_size;\n    hash_table.table = vec![None; new_table_size as usize];\n\n    !hash_table.table.is_empty()\n}\n\nuse std::cell::{Cell, RefCell};\n\nthread_local! {\n    static ALLOCATED_KEYS: Cell<usize> = Cell::new(0);\n}\n\npub struct AllocatedValues {\n    pub count: usize,\n}\n\nimpl Clone for AllocatedValues {\n    fn clone(&self) -> Self {\n        AllocatedValues {\n            count: self.count,\n        }\n    }\n}\n\nthread_local! {\n    static ALLOCATED_VALUES: RefCell<AllocatedValues> = RefCell::new(AllocatedValues { count: 0 });\n}\n\npub struct HashTableEntry {\n    pub pair: HashTablePair,\n    pub next: Option<Box<HashTableEntry>>,\n}\n\nimpl Clone for HashTableEntry {\n    fn clone(&self) -> Self {\n        HashTableEntry {\n            pair: self.pair.clone(),\n            next: self.next.clone(),\n        }\n    }\n}\n\npub struct HashTableIterator {\n    pub hash_table: Option<Box<HashTable>>,\n    pub next_entry: Option<Box<HashTableEntry>>,\n    pub next_chain: u32,\n}\n\nimpl Clone for HashTableIterator {\n    fn clone(&self) -> Self {\n        HashTableIterator {\n            hash_table: self.hash_table.clone(),\n            next_entry: self.next_entry.clone(),\n            next_chain: self.next_chain,\n        }\n    }\n}\n\npub struct HashTable {\n    pub table: Vec<Option<Box<HashTableEntry>>>,\n    pub table_size: u32,\n    pub hash_func: HashTableHashFunc,\n    pub equal_func: HashTableEqualFunc,\n    pub key_free_func: Option<HashTableKeyFreeFunc>,\n    pub value_free_func: Option<HashTableValueFreeFunc>,\n    pub entries: u32,\n    pub prime_index: u32,\n}\n\nimpl Clone for HashTable {\n    fn clone(&self) -> Self {\n        HashTable {\n            table: self.table.iter().cloned().collect(),\n            table_size: self.table_size,\n            hash_func: self.hash_func,\n            equal_func: self.equal_func,\n            key_free_func: self.key_free_func,\n            value_free_func: self.value_free_func,\n            entries: self.entries,\n            prime_index: self.prime_index,\n        }\n    }\n}\n\npub type HashTableHashFunc = fn(value: HashTableKey) -> u32;\npub type HashTableKeyFreeFunc = fn(value: HashTableKey);\npub type HashTableValueFreeFunc = fn(value: HashTableValue);\npub type HashTableKey = *const std::ffi::c_void;\npub type HashTableValue = *const std::ffi::c_void;\npub type HashTableEqualFunc = fn(value1: HashTableKey, value2: HashTableKey) -> i32;\npub type HashTablePair = (HashTableKey, HashTableValue);\n\npub const HASH_TABLE_PRIMES: [u32; 24] = [\n    193, 389, 769, 1543, 3079, 6151, 12289, 24593, 49157, 98317,\n    196613, 393241, 786433, 1572869, 3145739, 6291469,\n    12582917, 25165843, 50331653, 100663319, 201326611,\n    402653189, 805306457, 1610612741,\n];\n\npub const HASH_TABLE_NUM_PRIMES: u32 = HASH_TABLE_PRIMES.len() as u32;\n\npub const NUM_TEST_VALUES: u32 = 10000;\npub fn hash_table_insert(hash_table: &mut HashTable, key: HashTableKey, value: HashTableValue) -> i32 {\n    let mut index = (hash_table.hash_func)(key) % hash_table.table_size;\n    let mut rover = hash_table.table[index as usize].clone();\n\n    if (hash_table.entries * 3) / hash_table.table_size > 0 {\n        if !hash_table_enlarge(hash_table) {\n            return 0;\n        }\n        index = (hash_table.hash_func)(key) % hash_table.table_size;\n        rover = hash_table.table[index as usize].clone();\n    }\n\n    while let Some(mut entry) = rover {\n        let pair = &mut entry.pair;\n\n        if (hash_table.equal_func)(pair.0, key) != 0 {\n            if let Some(value_free_func) = hash_table.value_free_func {\n                value_free_func(pair.1);\n            }\n\n            if let Some(key_free_func) = hash_table.key_free_func {\n                key_free_func(pair.0);\n            }\n\n            pair.0 = key;\n            pair.1 = value;\n\n            return 1;\n        }\n\n        rover = entry.next.clone();\n    }\n\n    let mut newentry = Box::new(HashTableEntry {\n        pair: (key, value),\n        next: None,\n    });\n\n    newentry.next = hash_table.table[index as usize].take();\n    hash_table.table[index as usize] = Some(newentry);\n\n    hash_table.entries += 1;\n\n    1\n}\n\npub fn hash_table_free(mut hash_table: Box<HashTable>) {\n    let mut entries = hash_table.table.drain(..).filter_map(|entry| entry).collect::<Vec<_>>();\n    while let Some(mut current) = entries.pop() {\n        while let Some(next) = current.next.take() {\n            hash_table_free_entry(&mut hash_table, current);\n            current = next;\n        }\n        hash_table_free_entry(&mut hash_table, current);\n    }\n}\n\npub fn hash_table_free_entry(hash_table: &mut HashTable, entry: Box<HashTableEntry>) {\n    let pair = entry.pair;\n\n    if let Some(key_free_func) = hash_table.key_free_func {\n        key_free_func(pair.0);\n    }\n\n    if let Some(value_free_func) = hash_table.value_free_func {\n        value_free_func(pair.1);\n    }\n}\n\npub fn new_value(value: i32) -> i32 {\n    let mut allocated_values = ALLOCATED_VALUES.with(|av| av.borrow().count);\n    allocated_values += 1;\n    ALLOCATED_VALUES.with(|av| av.borrow_mut().count = allocated_values);\n\n    value\n}\n\npub fn test_hash_table_free_functions() {\n    let mut hash_table;\n    let mut key: HashTableKey;\n    let mut value: HashTableValue;\n    let i: i32;\n\n    hash_table = hash_table_new(int_hash, int_equal).expect(\"Failed to create hash table\");\n\n    hash_table_register_free_functions(&mut hash_table, Some(free_key), Some(free_value));\n\n    ALLOCATED_VALUES.with(|av| av.borrow_mut().count = 0);\n    ALLOCATED_KEYS.with(|ak| ak.set(0));\n\n    for i in 0..NUM_TEST_VALUES {\n        key = new_key(i as *const i32) as HashTableKey;\n        value = new_value(99) as HashTableValue;\n\n        hash_table_insert(&mut hash_table, key, value);\n    }\n\n    assert_eq!(ALLOCATED_KEYS.with(|ak| ak.get()), NUM_TEST_VALUES as usize);\n    assert_eq!(ALLOCATED_VALUES.with(|av| av.borrow().count), NUM_TEST_VALUES as usize);\n\n    i = NUM_TEST_VALUES as i32 / 2;\n    hash_table_remove(&mut hash_table, &i as *const i32 as HashTableKey);\n\n    assert_eq!(ALLOCATED_KEYS.with(|ak| ak.get()), (NUM_TEST_VALUES - 1) as usize);\n    assert_eq!(ALLOCATED_VALUES.with(|av| av.borrow().count), (NUM_TEST_VALUES - 1) as usize);\n\n    key = new_key(NUM_TEST_VALUES as i32 / 3) as HashTableKey;\n    value = new_value(999) as HashTableValue;\n\n    assert_eq!(ALLOCATED_KEYS.with(|ak| ak.get()), NUM_TEST_VALUES as usize);\n    assert_eq!(ALLOCATED_VALUES.with(|av| av.borrow().count), NUM_TEST_VALUES as usize);\n\n    hash_table_insert(&mut hash_table, key, value);\n\n    assert_eq!(ALLOCATED_KEYS.with(|ak| ak.get()), (NUM_TEST_VALUES - 1) as usize);\n    assert_eq!(ALLOCATED_VALUES.with(|av| av.borrow().count), (NUM_TEST_VALUES - 1) as usize);\n\n    hash_table_free(hash_table);\n\n    assert_eq!(ALLOCATED_KEYS.with(|ak| ak.get()), 0);\n    assert_eq!(ALLOCATED_VALUES.with(|av| av.borrow().count), 0);\n}\n\npub fn free_key(value: HashTableKey) {\n    unsafe { Box::from_raw(value as *mut i32) };\n}\n\npub fn free_value(value: HashTableValue) {\n    unsafe { Box::from_raw(value as *mut i32) };\n}\n\npub fn int_hash(value: HashTableKey) -> u32 {\n    value as u32\n}\n\npub fn int_equal(value1: HashTableKey, value2: HashTableKey) -> i32 {\n    if value1 == value2 {\n        1\n    } else {\n        0\n    }\n}\n\nfn main() {}\n\n //编译报错信息：error[E0605]: non-primitive cast: `Option<Box<*const i32>>` as `*const c_void`\n   --> ../tmp/temp.rs:286:15\n    |\n286 |         key = new_key(i as *const i32) as HashTableKey;\n    |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n\nerror[E0605]: non-primitive cast: `Option<Box<i32>>` as `*const c_void`\n   --> ../tmp/temp.rs:301:11\n    |\n301 |     key = new_key(NUM_TEST_VALUES as i32 / 3) as HashTableKey;\n    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0605`.\n",
        "free_key": "use std::marker::PhantomData;\n\npub fn free_key<T>(key: T)\nwhere\n    T: Drop,\n{\n    drop(key);\n    unsafe {\n        allocated_keys -= 1;\n    }\n}\n\npub struct HashTableIterator<T, U> {\n    pub hash_table: HashTable<T, U>,\n    pub next_entry: Option<HashTableEntry<T, U>>,\n    pub next_chain: usize,\n    _marker: PhantomData<(T, U)>,\n}\n\npub struct HashTableEntry<T, U> {\n    // Define the fields as needed\n    pub pair: (T, U),\n    pub next: Option<HashTableEntry<T, U>>,\n    _marker: PhantomData<(T, U)>,\n}\n\npub struct HashTable<T, U> {\n    // Define the fields as needed\n    pub table: Vec<Option<HashTableEntry<T, U>>>,\n    pub table_size: usize,\n    _marker: PhantomData<(T, U)>,\n}\n\npub static mut allocated_keys: usize = 0;\n\nfn main() {}\n\npub fn new_key<T>(value: T) -> Option<Box<T>> {\n    let mut result = Box::new(value);\n    unsafe {\n        allocated_keys += 1;\n    }\n    Some(result)\n}\n\npub fn hash_table_iter_next<T, U>(iterator: &mut HashTableIterator<T, U>) -> Option<(T, U)> {\n    let current_entry = iterator.next_entry.take();\n    let mut hash_table = &mut iterator.hash_table;\n    let mut pair = None;\n    let mut chain = iterator.next_chain;\n\n    if let Some(current_entry_unwrapped) = current_entry {\n        pair = Some((current_entry_unwrapped.pair.0, current_entry_unwrapped.pair.1));\n\n        if let Some(next_entry) = current_entry_unwrapped.next {\n            iterator.next_entry = Some(next_entry);\n        } else {\n            chain += 1;\n            iterator.next_entry = None;\n\n            while chain < hash_table.table_size {\n                if let Some(entry) = &hash_table.table[chain] {\n                    iterator.next_entry = Some(entry.clone());\n                    break;\n                }\n                chain += 1;\n            }\n\n            iterator.next_chain = chain;\n        }\n    }\n\n    pair\n}\n\nimpl<T, U> Clone for HashTableEntry<T, U>\nwhere\n    T: Clone,\n    U: Clone,\n{\n    fn clone(&self) -> Self {\n        HashTableEntry {\n            pair: (self.pair.0.clone(), self.pair.1.clone()),\n            next: self.next.clone(),\n            _marker: PhantomData,\n        }\n    }\n}\n\nimpl<T, U> Clone for HashTable<T, U>\nwhere\n    T: Clone,\n    U: Clone,\n{\n    fn clone(&self) -> Self {\n        HashTable {\n            table: self.table.clone(),\n            table_size: self.table_size,\n            _marker: PhantomData,\n        }\n    }\n}\n //编译报错信息：error[E0072]: recursive type `HashTableEntry` has infinite size\n  --> ../tmp/temp.rs:20:1\n   |\n20 | pub struct HashTableEntry<T, U> {\n   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n...\n23 |     pub next: Option<HashTableEntry<T, U>>,\n   |                      -------------------- recursive without indirection\n   |\n"
    },
    "slist": {
        "slist_sort_internal": "pub struct SListEntry<T> {\n    data: T,\n    next: Option<Box<SListEntry<T>>>,\n}\n\nimpl<T> Clone for SListEntry<T>\nwhere\n    T: Clone,\n{\n    fn clone(&self) -> Self {\n        SListEntry {\n            data: self.data.clone(),\n            next: self.next.clone(),\n        }\n    }\n}\n\npub type SListCompareFunc<T> = fn(&T, &T) -> i32;\n\npub fn slist_sort_internal<T>(list: &mut Option<Box<SListEntry<T>>>, compare_func: SListCompareFunc<T>) -> Option<Box<SListEntry<T>>> {\n    if list.is_none() || list.as_ref().unwrap().next.is_none() {\n        return list.take();\n    }\n\n    let mut pivot = list.take().unwrap();\n    let mut less_list: Option<Box<SListEntry<T>>> = None;\n    let mut more_list: Option<Box<SListEntry<T>>> = None;\n    let mut rover = pivot.next.take();\n\n    while let Some(mut rover_node) = rover {\n        rover = rover_node.next.take();\n\n        if compare_func(&rover_node.data, &pivot.data) < 0 {\n            rover_node.next = less_list.take();\n            less_list = Some(rover_node);\n        } else {\n            rover_node.next = more_list.take();\n            more_list = Some(rover_node);\n        }\n    }\n\n    let less_list_end = slist_sort_internal(&mut less_list, compare_func);\n    let more_list_end = slist_sort_internal(&mut more_list, compare_func);\n\n    *list = less_list;\n\n    if list.is_none() {\n        *list = Some(pivot);\n    } else {\n        let mut less_list_end_mut = less_list_end.unwrap();\n        less_list_end_mut.next = Some(pivot);\n    }\n\n    if let Some(ref mut pivot_mut) = list {\n        pivot_mut.next = more_list_end;\n    }\n\n    more_list_end\n}\n\nfn main() {}\n //编译报错信息：error[E0382]: use of moved value: `more_list_end`\n  --> ../tmp/temp.rs:58:5\n   |\n43 |     let more_list_end = slist_sort_internal(&mut more_list, compare_func);\n   |         ------------- move occurs because `more_list_end` has type `Option<Box<SListEntry<T>>>`, which does not implement the `Copy` trait\n...\n55 |         pivot_mut.next = more_list_end;\n   |                          ------------- value moved here\n...\n58 |     more_list_end\n   |     ^^^^^^^^^^^^^ value used here after move\n\nerror: aborting due to 1 previous error\n\nFor more information about this error, try `rustc --explain E0382`.\n",
        "slist_remove_data": "use std::rc::Rc;\nuse std::cell::RefCell;\n\npub static variable1: i32 = 50;\npub static variable2: i32 = 0;\npub static variable3: i32 = 0;\npub static variable4: i32 = 0;\n\npub struct SListEntry<T> {\n    pub data: T,\n    pub next: Option<Rc<RefCell<SListEntry<T>>>>,\n}\n\nimpl<T: Clone + PartialEq> Clone for SListEntry<T> {\n    fn clone(&self) -> Self {\n        SListEntry {\n            data: self.data.clone(),\n            next: self.next.clone(),\n        }\n    }\n}\n\nimpl<T: PartialEq> PartialEq for SListEntry<T> {\n    fn eq(&self, other: &Self) -> bool {\n        self.data == other.data && self.next.is_some() == other.next.is_some()\n    }\n}\n\npub struct SListIterator<T> {\n    pub prev_next: Option<Rc<RefCell<SListEntry<T>>>>,\n    pub current: Option<Rc<RefCell<SListEntry<T>>>>,\n}\n\npub fn slist_remove_data<T: PartialEq>(list: &mut Option<Rc<RefCell<SListEntry<T>>>>, callback: fn(&T, &T) -> bool, data: T) -> usize {\n    let mut entries_removed = 0;\n    let mut rover = list;\n\n    while let Some(entry) = rover.take() {\n        let mut borrowed_entry = entry.borrow_mut();\n\n        if callback(&borrowed_entry.data, &data) {\n            let next = borrowed_entry.next.take();\n            *rover = next;\n            entries_removed += 1;\n        } else {\n            rover = &mut borrowed_entry.next;\n        }\n    }\n\n    entries_removed\n}\n\nfn main(){}\n //编译报错信息：error[E0597]: `entry` does not live long enough\n  --> ../tmp/temp.rs:39:34\n   |\n38 |     while let Some(entry) = rover.take() {\n   |                    -----    ----- borrow later used here\n   |                    |\n   |                    binding `entry` declared here\n39 |         let mut borrowed_entry = entry.borrow_mut();\n   |                                  ^^^^^ borrowed value does not live long enough\n...\n48 |     }\n   |     - `entry` dropped here while still borrowed\n\nerror[E0597]: `borrowed_entry` does not live long enough\n  --> ../tmp/temp.rs:46:26\n   |\n38 |     while let Some(entry) = rover.take() {\n   |                             ----- borrow later used here\n39 |         let mut borrowed_entry = entry.borrow_mut();\n   |             ------------------ binding `borrowed_entry` declared here\n...\n46 |             rover = &mut borrowed_entry.next;\n   |                          ^^^^^^^^^^^^^^ borrowed value does not live long enough\n47 |         }\n48 |     }\n   |     - `borrowed_entry` dropped here while still borrowed\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0597`.\n"
    },
    "test-slist": {
        "test_slist_remove_data": "use std::rc::Rc;\nuse std::cell::RefCell;\n\npub static variable1: i32 = 50;\npub static variable2: i32 = 0;\npub static variable3: i32 = 0;\npub static variable4: i32 = 0;\n\npub struct SListEntry<T> {\n    pub data: T,\n    pub next: Option<Rc<RefCell<SListEntry<T>>>>,\n}\n\nimpl<T: Clone + PartialEq> Clone for SListEntry<T> {\n    fn clone(&self) -> Self {\n        SListEntry {\n            data: self.data.clone(),\n            next: self.next.clone(),\n        }\n    }\n}\n\nimpl<T: PartialEq> PartialEq for SListEntry<T> {\n    fn eq(&self, other: &Self) -> bool {\n        self.data == other.data && self.next.is_some() == other.next.is_some()\n    }\n}\n\npub struct SListIterator<T> {\n    pub prev_next: Option<Rc<RefCell<SListEntry<T>>>>,\n    pub current: Option<Rc<RefCell<SListEntry<T>>>>,\n}\n\npub fn slist_free<T>(list: Option<Rc<RefCell<SListEntry<T>>>>) {\n    let mut current = list;\n\n    while let Some(entry) = current {\n        let next = entry.borrow().next.clone();\n        current = next;\n    }\n}\n\npub fn slist_prepend<T: Clone>(list: &mut Option<Rc<RefCell<SListEntry<T>>>>, data: T) -> Option<Rc<RefCell<SListEntry<T>>>> {\n    let newentry = Rc::new(RefCell::new(SListEntry {\n        data: data,\n        next: list.clone(),\n    }));\n\n    *list = Some(newentry.clone());\n\n    Some(newentry)\n}\n\npub fn slist_length<T>(list: Option<Rc<RefCell<SListEntry<T>>>>) -> u32 {\n    let mut length = 0;\n    let mut current = list;\n\n    while let Some(entry) = current {\n        length += 1;\n        current = entry.borrow().next.clone();\n    }\n\n    length\n}\n\npub fn test_slist_remove_data() {\n    let entries = vec![89, 4, 23, 42, 4, 16, 15, 4, 8, 99, 50, 30, 4];\n    let mut list = None;\n\n    for entry in entries.iter().rev() {\n        slist_prepend(&mut list, *entry);\n    }\n\n    let mut val = 0;\n    assert_eq!(slist_remove_data(&mut list, int_equal, val), 0);\n    val = 56;\n    assert_eq!(slist_remove_data(&mut list, int_equal, val), 0);\n\n    val = 8;\n    assert_eq!(slist_remove_data(&mut list, int_equal, val), 1);\n    assert_eq!(slist_length(list.clone()), (entries.len() - 1) as u32);\n\n    val = 4;\n    assert_eq!(slist_remove_data(&mut list, int_equal, val), 4);\n    assert_eq!(slist_length(list.clone()), (entries.len() - 5) as u32);\n\n    val = 89;\n    assert_eq!(slist_remove_data(&mut list, int_equal, val), 1);\n    assert_eq!(slist_length(list.clone()), (entries.len() - 6) as u32);\n\n    slist_free(list);\n}\n\npub fn slist_remove_data<T: PartialEq>(list: &mut Option<Rc<RefCell<SListEntry<T>>>>, callback: fn(&T, &T) -> bool, data: T) -> u32 {\n    let mut rover = list;\n    let mut entries_removed = 0;\n\n    while let Some(entry) = rover.take() {\n        if callback(&entry.borrow().data, &data) {\n            *rover = entry.borrow().next.clone();\n            entries_removed += 1;\n        } else {\n            *rover = Some(entry);\n            rover = &mut entry.borrow_mut().next;\n        }\n    }\n\n    entries_removed\n}\n\npub fn int_equal(a: &i32, b: &i32) -> bool {\n    *a == *b\n}\n\nfn main(){}\n //编译报错信息：error[E0597]: `entry` does not live long enough\n   --> ../tmp/temp.rs:104:26\n    |\n98  |     while let Some(entry) = rover.take() {\n    |                    -----    ----- borrow later used here\n    |                    |\n    |                    binding `entry` declared here\n...\n104 |             rover = &mut entry.borrow_mut().next;\n    |                          ^^^^^ borrowed value does not live long enough\n105 |         }\n106 |     }\n    |     - `entry` dropped here while still borrowed\n\nerror[E0716]: temporary value dropped while borrowed\n   --> ../tmp/temp.rs:104:26\n    |\n98  |     while let Some(entry) = rover.take() {\n    |                             ----- borrow later used here\n...\n104 |             rover = &mut entry.borrow_mut().next;\n    |                          ^^^^^^^^^^^^^^^^^^     - temporary value is freed at the end of this statement\n    |                          |\n    |                          creates a temporary value which is freed while still in use\n    |\n",
        "test_slist_sort": "\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\npub static variable1: i32 = 50;\npub static variable2: i32 = 0;\npub static variable3: i32 = 0;\npub static variable4: i32 = 0;\n\npub struct SListEntry<T> {\n    pub data: T,\n    pub next: Option<Rc<RefCell<SListEntry<T>>>>,\n}\n\nimpl<T: Clone + PartialEq> Clone for SListEntry<T> {\n    fn clone(&self) -> Self {\n        SListEntry {\n            data: self.data.clone(),\n            next: self.next.clone(),\n        }\n    }\n}\n\nimpl<T: PartialEq> PartialEq for SListEntry<T> {\n    fn eq(&self, other: &Self) -> bool {\n        self.data == other.data && self.next.is_some() == other.next.is_some()\n    }\n}\n\npub struct SListIterator<T> {\n    pub prev_next: Option<Rc<RefCell<SListEntry<T>>>>,\n    pub current: Option<Rc<RefCell<SListEntry<T>>>>,\n}\n\npub fn slist_nth_entry<T>(list: Option<Rc<RefCell<SListEntry<T>>>>, n: usize) -> Option<Rc<RefCell<SListEntry<T>>>> {\n    let mut entry = list;\n    let mut i = 0;\n\n    while i < n {\n        if let Some(current_entry) = entry.take() {\n            entry = current_entry.borrow().next.clone();\n        } else {\n            return None;\n        }\n        i += 1;\n    }\n\n    entry\n}\n\npub fn slist_free<T>(list: Option<Rc<RefCell<SListEntry<T>>>>) {\n    let mut current = list;\n\n    while let Some(entry) = current {\n        let next = entry.borrow().next.clone();\n        current = next;\n    }\n}\n\npub fn slist_prepend<T: Clone>(list: &mut Option<Rc<RefCell<SListEntry<T>>>>, data: T) -> Option<Rc<RefCell<SListEntry<T>>>> {\n    let newentry = Rc::new(RefCell::new(SListEntry {\n        data: data,\n        next: list.clone(),\n    }));\n\n    *list = Some(newentry.clone());\n\n    Some(newentry)\n}\n\npub fn slist_sort<T: Clone + PartialEq>(list: &mut Option<Rc<RefCell<SListEntry<T>>>>, compare_func: impl Fn(&T, &T) -> i32) {\n    *list = slist_sort_internal(list, compare_func);\n}\n\npub fn slist_nth_data<T: Clone>(list: Option<Rc<RefCell<SListEntry<T>>>>, n: usize) -> Option<T> {\n    let entry = slist_nth_entry(list, n);\n\n    match entry {\n        None => None,\n        Some(e) => Some(e.borrow().data.clone()),\n    }\n}\n\npub fn slist_length<T>(list: Option<Rc<RefCell<SListEntry<T>>>>) -> u32 {\n    let mut length = 0;\n    let mut current = list;\n\n    while let Some(entry) = current {\n        length += 1;\n        current = entry.borrow().next.clone();\n    }\n\n    length\n}\n\npub fn slist_sort_internal<T: Clone + PartialEq>(list: &mut Option<Rc<RefCell<SListEntry<T>>>>, compare_func: impl Fn(&T, &T) -> i32) -> Option<Rc<RefCell<SListEntry<T>>>> {\n    let pivot;\n    let mut rover;\n    let mut less_list = None;\n    let mut more_list = None;\n\n    if list.is_none() || list.as_ref().unwrap().borrow().next.is_none() {\n        return list.clone();\n    }\n\n    pivot = list.take().unwrap();\n\n    rover = pivot.borrow_mut().next.take();\n\n    while let Some(node) = rover {\n        let next = node.borrow_mut().next.take();\n\n        if compare_func(&node.borrow().data, &pivot.borrow().data) < 0 {\n            node.borrow_mut().next = less_list.take();\n            less_list = Some(node);\n        } else {\n            node.borrow_mut().next = more_list.take();\n            more_list = Some(node);\n        }\n\n        rover = next;\n    }\n\n    let less_list_end = slist_sort_internal(&mut less_list, &compare_func);\n    let more_list_end = slist_sort_internal(&mut more_list, &compare_func);\n\n    *list = less_list;\n\n    if list.is_none() {\n        *list = Some(pivot.clone());\n    } else {\n        less_list_end.unwrap().borrow_mut().next = Some(pivot.clone());\n    }\n\n    pivot.borrow_mut().next = more_list_end;\n\n    Some(pivot)\n}\n\npub fn test_slist_sort() {\n    let mut list: Option<Rc<RefCell<SListEntry<i32>>>> = None;\n    let entries = vec![89, 4, 23, 42, 4, 16, 15, 4, 8, 99, 50, 30, 4];\n    let sorted = vec![4, 4, 4, 4, 8, 15, 16, 23, 30, 42, 50, 89, 99];\n    let num_entries = entries.len();\n\n    for &entry in &entries {\n        slist_prepend(&mut list, entry);\n    }\n\n    slist_sort(&mut list, |a, b| a.cmp(b) as i32);\n\n    // List length is unchanged\n    assert_eq!(slist_length(list), num_entries as u32);\n\n    // Check the list is sorted\n    for i in 0..num_entries {\n        let value = slist_nth_data(list.clone(), i).unwrap();\n        assert_eq!(value, sorted[i]);\n    }\n\n    slist_free(list);\n\n    // Check sorting an empty list\n    list = None;\n    slist_sort(&mut list, |a, b| a.cmp(b) as i32);\n    assert!(list.is_none());\n}\n\nfn int_compare(a: &i32, b: &i32) -> i32 {\n    a.cmp(b) as i32\n}\n\nfn main() {}\n\n //编译报错信息：error[E0382]: use of moved value: `list`\n   --> ../tmp/temp.rs:161:16\n    |\n141 |     let mut list: Option<Rc<RefCell<SListEntry<i32>>>> = None;\n    |         -------- move occurs because `list` has type `Option<Rc<RefCell<SListEntry<i32>>>>`, which does not implement the `Copy` trait\n...\n153 |     assert_eq!(slist_length(list), num_entries as u32);\n    |                             ---- value moved here\n...\n161 |     slist_free(list);\n    |                ^^^^ value used here after move\n    |\nnote: consider changing this parameter type in function `slist_length` to borrow instead if owning the value isn't necessary\n   --> ../tmp/temp.rs:84:30\n    |\n84  | pub fn slist_length<T>(list: Option<Rc<RefCell<SListEntry<T>>>>) -> u32 {\n    |        ------------          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this parameter takes ownership of the value\n    |        |\n    |        in this function\n"
    },
    "arraylist": {
        "arraylist_remove": "pub fn arraylist_remove_range<T: ArrayListComparable + Clone>(arraylist: &mut ArrayList<T>, index: usize, length: usize) {\n    // Check this is a valid range\n    if index > arraylist.length || index + length > arraylist.length {\n        return;\n    }\n\n    // Move back the entries following the range to be removed\n    let _shift_start = index + length;\n    let shift_end = arraylist.length;\n    for i in index..shift_end - length {\n        arraylist.data[i] = arraylist.data[i + length].clone();\n    }\n\n    // Decrease the counter\n    arraylist.length -= length;\n}\n\n\npub trait ArrayListComparable {\n    fn compare(&self, other: &Self) -> i32;\n}\n\npub struct ArrayList<T: ArrayListComparable + Clone> {\n    pub data: Vec<T>,\n    pub length: usize,\n    _alloced: usize,\n}\n\n\npub fn arraylist_remove<T: ArrayListComparable + Clone>(arraylist: &mut ArrayList<T>, index: usize) {\n    arraylist_remove_range(arraylist, index, 1);\n}\n\n\nfn main(){}\n //编译报错信息：",
        "arraylist_sort": "pub fn arraylist_sort_internal<T: ArrayListComparable + Clone>(list_data: &mut [T], compare_func: fn(&T, &T) -> i32) {\n    if list_data.len() <= 1 {\n        return;\n    }\n\n    let pivot_index = list_data.len() - 1;\n    let pivot = list_data[pivot_index].clone();\n    let mut list1_length = 0;\n\n    for i in 0..pivot_index {\n        if compare_func(&list_data[i], &pivot) < 0 {\n            list_data.swap(i, list1_length);\n            list1_length += 1;\n        }\n    }\n\n    list_data.swap(list1_length, pivot_index);\n\n    arraylist_sort_internal(&mut list_data[0..list1_length], compare_func);\n    arraylist_sort_internal(&mut list_data[list1_length + 1..], compare_func);\n}\n\npub trait ArrayListComparable {\n    fn compare(&self, other: &Self) -> i32;\n}\n\npub struct ArrayList<T: ArrayListComparable + Clone> {\n    pub data: Vec<T>,\n    pub length: usize,\n    _alloced: usize,\n}\n\npub fn arraylist_sort<T: ArrayListComparable + Clone>(arraylist: &mut ArrayList<T>, compare_func: fn(&T, &T) -> i32) {\n    arraylist_sort_internal(&mut arraylist.data, compare_func);\n}\n\nfn main(){}\n //编译报错信息：",
        "arraylist_index_of": "pub trait ArrayListComparable {\n    fn compare(&self, other: &Self) -> i32;\n}\n\npub struct ArrayList<T: ArrayListComparable + Clone> {\n    pub data: Vec<T>,\n    pub length: usize,\n    _alloced: usize,\n}\n\n\npub fn arraylist_index_of<T: ArrayListComparable + Clone>(arraylist: &ArrayList<T>, callback: fn(&T, &T) -> bool, data: &T) -> i32 {\n    for i in 0..arraylist.length {\n        if callback(&arraylist.data[i], data) {\n            return i as i32;\n        }\n    }\n    -1\n}\n\n\nfn main(){}\n //编译报错信息："
    },
    "test-arraylist": {
        "test_arraylist_append": "\npub fn arraylist_new<T: ArrayListComparable + Clone>(length: usize) -> Option<ArrayList<T>> {\n    let mut len = length;\n    if len <= 0 {\n        len = 16;\n    }\n\n    let data: Vec<T> = Vec::with_capacity(len);\n\n    Some(ArrayList {\n        data,\n        length: 0,\n        _alloced: len,\n    })\n}\n\npub fn arraylist_append<T: ArrayListComparable + Clone>(arraylist: &mut ArrayList<T>, data: T) -> i32 {\n    arraylist_insert(arraylist, arraylist.length, data)\n}\n\npub fn arraylist_free<T: ArrayListComparable + Clone>(arraylist: Option<Box<ArrayList<T>>>) {\n    if let Some(mut list) = arraylist {\n        list.data.clear();\n    }\n}\n\npub fn arraylist_enlarge<T: ArrayListComparable + Clone>(arraylist: &mut ArrayList<T>) -> i32 {\n    let newsize = arraylist._alloced * 2;\n    let mut new_data = Vec::with_capacity(newsize);\n\n    if new_data.capacity() < newsize {\n        return 0;\n    }\n\n    new_data.extend_from_slice(&arraylist.data);\n    arraylist.data = new_data;\n    arraylist._alloced = newsize;\n\n    1\n}\n\npub trait ArrayListComparable {\n    fn compare(&self, other: &Self) -> i32;\n}\n\npub struct ArrayList<T: ArrayListComparable + Clone> {\n    pub data: Vec<T>,\n    pub length: usize,\n    _alloced: usize,\n}\n\npub fn arraylist_insert<T: ArrayListComparable + Clone>(arraylist: &mut ArrayList<T>, index: usize, data: T) -> i32 {\n    if index > arraylist.length {\n        return 0;\n    }\n\n    if arraylist.length + 1 > arraylist._alloced {\n        if arraylist_enlarge(arraylist) == 0 {\n            return 0;\n        }\n    }\n\n    arraylist.data.insert(index, data);\n    arraylist.length += 1;\n\n    1\n}\n\npub static mut variable1: i32 = 0;\n\npub fn test_arraylist_append() {\n    let mut arraylist = arraylist_new(0).unwrap();\n    assert_eq!(arraylist.length, 0);\n\n    let var1 = 1;\n    let var2 = 2;\n    let var3 = 3;\n    let var4 = 4;\n\n    // Implement a wrapper type that implements ArrayListComparable for i32\n    struct IntWrapper(i32);\n\n    impl ArrayListComparable for IntWrapper {\n        fn compare(&self, other: &Self) -> i32 {\n            match self.0.cmp(&other.0) {\n                std::cmp::Ordering::Less => -1,\n                std::cmp::Ordering::Equal => 0,\n                std::cmp::Ordering::Greater => 1,\n            }\n        }\n    }\n\n    impl Clone for IntWrapper {\n        fn clone(&self) -> Self {\n            IntWrapper(self.0)\n        }\n    }\n\n    let wrapped_var1 = IntWrapper(var1);\n    let wrapped_var2 = IntWrapper(var2);\n    let wrapped_var3 = IntWrapper(var3);\n    let wrapped_var4 = IntWrapper(var4);\n\n    assert_ne!(arraylist_append(&mut arraylist, wrapped_var1.clone()), 0);\n    assert_eq!(arraylist.length, 1);\n\n    assert_ne!(arraylist_append(&mut arraylist, wrapped_var2.clone()), 0);\n    assert_eq!(arraylist.length, 2);\n\n    assert_ne!(arraylist_append(&mut arraylist, wrapped_var3.clone()), 0);\n    assert_eq!(arraylist.length, 3);\n\n    assert_ne!(arraylist_append(&mut arraylist, wrapped_var4.clone()), 0);\n    assert_eq!(arraylist.length, 4);\n\n    assert_eq!(arraylist.data[0].0, var1);\n    assert_eq!(arraylist.data[1].0, var2);\n    assert_eq!(arraylist.data[2].0, var3);\n    assert_eq!(arraylist.data[3].0, var4);\n\n    for _ in 0..10000 {\n        assert_ne!(arraylist_append(&mut arraylist, wrapped_var1.clone()), 0);\n    }\n\n    arraylist_free(Some(Box::new(arraylist)));\n\n    let mut arraylist = arraylist_new(100).unwrap();\n\n    for _ in 0..100 {\n        assert_ne!(arraylist_append(&mut arraylist, wrapped_var1.clone()), 0);\n    }\n\n    assert_eq!(arraylist.length, 100);\n    assert_eq!(arraylist_append(&mut arraylist, wrapped_var1.clone()), 0);\n    assert_eq!(arraylist.length, 100);\n\n    arraylist_free(Some(Box::new(arraylist)));\n}\n\nfn main() {}\n\n //编译报错信息：",
        "test_arraylist_clear": "\npub fn arraylist_new<T: ArrayListComparable + Clone>(length: usize) -> Option<ArrayList<T>> {\n    let mut len = length;\n    if len <= 0 {\n        len = 16;\n    }\n\n    let data: Vec<T> = Vec::with_capacity(len);\n\n    Some(ArrayList {\n        data,\n        length: 0,\n        _alloced: len,\n    })\n}\n\npub fn arraylist_clear<T: ArrayListComparable + Clone>(arraylist: &mut ArrayList<T>) {\n    arraylist.data.clear();\n    arraylist.length = 0;\n}\n\npub fn arraylist_append<T: ArrayListComparable + Clone>(arraylist: &mut ArrayList<T>, data: T) -> i32 {\n    arraylist_insert(arraylist, arraylist.length, data)\n}\n\npub fn arraylist_free<T: ArrayListComparable + Clone>(arraylist: Option<Box<ArrayList<T>>>) {\n    if let Some(mut list) = arraylist {\n        list.data.clear();\n    }\n}\n\npub fn arraylist_enlarge<T: ArrayListComparable + Clone>(arraylist: &mut ArrayList<T>) -> i32 {\n    let newsize = arraylist._alloced * 2;\n    let mut new_data = Vec::with_capacity(newsize);\n\n    if new_data.capacity() < newsize {\n        return 0;\n    }\n\n    new_data.extend_from_slice(&arraylist.data);\n    arraylist.data = new_data;\n    arraylist._alloced = newsize;\n\n    1\n}\n\npub trait ArrayListComparable {\n    fn compare(&self, other: &Self) -> i32;\n}\n\npub struct ArrayList<T: ArrayListComparable + Clone> {\n    pub data: Vec<T>,\n    pub length: usize,\n    _alloced: usize,\n}\n\npub fn arraylist_insert<T: ArrayListComparable + Clone>(arraylist: &mut ArrayList<T>, index: usize, data: T) -> i32 {\n    if index > arraylist.length {\n        return 0;\n    }\n\n    if arraylist.length + 1 > arraylist._alloced {\n        if arraylist_enlarge(arraylist) == 0 {\n            return 0;\n        }\n    }\n\n    arraylist.data.insert(index, data);\n    arraylist.length += 1;\n\n    1\n}\n\npub static mut variable1: i32 = 0;\n\npub fn test_arraylist_clear() {\n    let mut arraylist = arraylist_new(0).unwrap();\n\n    // Emptying an already-empty arraylist\n    arraylist_clear(&mut arraylist);\n    assert_eq!(arraylist.length, 0);\n\n    // Add some items and then empty it\n    arraylist_append(&mut arraylist, variable1);\n    arraylist_append(&mut arraylist, variable1);\n    arraylist_append(&mut arraylist, variable1);\n    arraylist_append(&mut arraylist, variable1);\n\n    arraylist_clear(&mut arraylist);\n    assert_eq!(arraylist.length, 0);\n\n    arraylist_free(Some(Box::new(arraylist)));\n}\n\nfn main() {}\n\n //编译报错信息：error[E0277]: the trait bound `i32: ArrayListComparable` is not satisfied\n  --> ../tmp/temp.rs:80:21\n   |\n80 |     arraylist_clear(&mut arraylist);\n   |     --------------- ^^^^^^^^^^^^^^ the trait `ArrayListComparable` is not implemented for `i32`\n   |     |\n   |     required by a bound introduced by this call\n   |\n",
        "test_arraylist_new_free": "\npub fn arraylist_free<T: ArrayListComparable + Clone>(arraylist: Option<Box<ArrayList<T>>>) {\n    if let Some(mut list) = arraylist {\n        list.data.clear();\n    }\n}\n\npub fn arraylist_new<T: ArrayListComparable + Clone>(length: usize) -> Option<Box<ArrayList<T>>> {\n    let mut len = length;\n    if len <= 0 {\n        len = 16;\n    }\n\n    let data: Vec<T> = Vec::with_capacity(len);\n\n    Some(Box::new(ArrayList {\n        data,\n        length: 0,\n        _alloced: len,\n    }))\n}\n\npub trait ArrayListComparable: PartialEq + std::fmt::Debug {\n    fn compare(&self, other: &Self) -> i32;\n}\n\n#[derive(Clone, PartialEq, std::fmt::Debug)]\npub struct CustomInt(i32);\n\nimpl ArrayListComparable for CustomInt {\n    fn compare(&self, other: &Self) -> i32 {\n        self.0.cmp(&other.0) as i32\n    }\n}\n\npub struct ArrayList<T: ArrayListComparable + Clone> {\n    pub data: Vec<T>,\n    pub length: usize,\n    _alloced: usize,\n}\n\npub trait ArrayListEqualFunc<T: ArrayListComparable + Clone> {\n    fn equal(&self, value1: &T, value2: &T) -> bool;\n}\n\nimpl<F, T> ArrayListEqualFunc<T> for F where F: Fn(&T, &T) -> bool, T: ArrayListComparable + Clone {\n    fn equal(&self, value1: &T, value2: &T) -> bool {\n        self(value1, value2)\n    }\n}\n\npub fn test_arraylist_new_free() {\n    // Use a default size when given zero\n    let arraylist: Option<Box<ArrayList<CustomInt>>> = arraylist_new(0);\n    assert!(arraylist.is_some());\n    arraylist_free(arraylist);\n\n    // Normal allocated\n    let arraylist: Option<Box<ArrayList<CustomInt>>> = arraylist_new(10);\n    assert!(arraylist.is_some());\n    arraylist_free(arraylist);\n\n    // Freeing a null arraylist works\n    arraylist_free::<CustomInt>(None);\n}\n\nfn main() {}\n\n //编译报错信息："
    },
    "trie": {
        "trie_insert_rollback": "pub struct TrieNode<T> {\n    pub data: Option<T>,\n    pub use_count: u32,\n    pub next: [Option<Box<TrieNode<T>>>; 256],\n}\n\nimpl<T> Clone for TrieNode<T> where T: Clone {\n    fn clone(&self) -> Self {\n        TrieNode {\n            data: self.data.clone(),\n            use_count: self.use_count,\n            next: self.next.clone(),\n        }\n    }\n}\n\npub struct Trie<T> {\n    pub root_node: Option<Box<TrieNode<T>>>,\n}\n\npub fn trie_insert_rollback<T>(trie: &mut Trie<T>, key: &[u8]) {\n    let mut node = trie.root_node.take();\n    let mut prev_ptr = &mut trie.root_node;\n    let mut p = key.iter();\n\n    while let Some(current_node) = node {\n        let next_index = *p.next().unwrap() as usize;\n        let mut current_node = current_node.as_ref().clone();\n        let next_prev_ptr = &mut current_node.next[next_index];\n        let next_node = next_prev_ptr.take();\n\n        current_node.use_count -= 1;\n\n        if current_node.use_count == 0 {\n            *prev_ptr = None;\n            *next_prev_ptr = None;\n        } else {\n            *prev_ptr = Some(Box::new(current_node.clone()));\n            *next_prev_ptr = next_node.clone();\n        }\n\n        node = next_node;\n        prev_ptr = next_prev_ptr;\n    }\n}\n\nfn main(){}\n //编译报错信息：error[E0308]: mismatched types\n   --> ../tmp/temp.rs:38:39\n    |\n38  |             *prev_ptr = Some(Box::new(current_node.clone()));\n    |                              -------- ^^^^^^^^^^^^^^^^^^^^ expected `TrieNode<T>`, found `&TrieNode<T>`\n    |                              |\n    |                              arguments to this function are incorrect\n    |\n",
        "trie_insert": "pub fn trie_find_end<'a, T>(trie: &'a Trie<T>, key: &str) -> Option<&'a Box<TrieNode<T>>> {\n    let mut node = trie.root_node.as_ref();\n\n    for c in key.bytes() {\n        if let Some(n) = node {\n            node = n.next[c as usize].as_ref();\n        } else {\n            return None;\n        }\n    }\n\n    node\n}\n\nuse std::clone::Clone;\n\npub struct TrieNode<T> {\n    pub data: Option<T>,\n    pub use_count: u32,\n    pub next: [Option<Box<TrieNode<T>>>; 256],\n}\n\nimpl<T: Clone> Clone for TrieNode<T> {\n    fn clone(&self) -> Self {\n        TrieNode {\n            data: self.data.clone(),\n            use_count: self.use_count,\n            next: self.next.clone(),\n        }\n    }\n}\n\npub struct Trie<T> {\n    pub root_node: Option<Box<TrieNode<T>>>,\n}\n\npub const bin_key4: [u8; 4] = [ b'z', 0, b'z', b'z' ];\npub const bin_key2: [u8; 8] = [ b'a', b'b', b'c', 0, 1, 2, 0xff, 0 ];\npub const bin_key3: [u8; 3] = [ b'a', b'b', b'c' ];\npub const bin_key: [u8; 7] = [ b'a', b'b', b'c', 0, 1, 2, 0xff ];\n\npub fn trie_insert_rollback<T: Clone>(trie: &mut Trie<T>, key: &[u8]) {\n    let mut node = trie.root_node.take();\n    let mut prev_ptr = &mut trie.root_node;\n    let mut p = key.iter();\n\n    while let Some(mut current_node) = node {\n        let next_index = *p.next().unwrap_or(&0) as usize;\n        let next_node = current_node.next[next_index].take();\n\n        current_node.use_count -= 1;\n\n        if current_node.use_count == 0 {\n            *prev_ptr = None;\n        } else {\n            *prev_ptr = Some(current_node);\n        }\n\n        node = next_node;\n        if let Some(ref mut prev_node) = *prev_ptr {\n            prev_ptr = &mut prev_node.next[next_index];\n        }\n    }\n}\n\npub fn trie_insert<T: Clone>(trie: &mut Trie<T>, key: &str, value: Option<T>) -> bool {\n    if value.is_none() {\n        return false;\n    }\n\n    if let Some(node) = trie_find_end(trie, key) {\n        if node.data.is_some() {\n            node.data = value;\n            return true;\n        }\n    }\n\n    let mut rover = &mut trie.root_node;\n    let mut p = key.bytes();\n\n    loop {\n        let mut node = rover.take();\n\n        if node.is_none() {\n            node = Some(Box::new(TrieNode {\n                data: None,\n                use_count: 0,\n                next: [None; 256],\n            }));\n        }\n\n        if let Some(ref mut node) = node {\n            node.use_count += 1;\n\n            let c = p.next().unwrap_or(0) as usize;\n\n            if c == 0 {\n                node.data = value;\n                *rover = Some(node.clone());\n                break;\n            }\n\n            rover = &mut node.next[c];\n        }\n\n        *rover = node;\n    }\n\n    true\n}\n\nfn main(){}\n //编译报错信息：error[E0277]: the trait bound `Box<TrieNode<T>>: Copy` is not satisfied\n  --> ../tmp/temp.rs:88:24\n   |\n88 |                 next: [None; 256],\n   |                        ^^^^\n   |                        |\n   |                        the trait `Copy` is not implemented for `Box<TrieNode<T>>`\n   |                        help: create an inline `const` block: `const { None }`\n   |\n   = note: required for `Option<Box<TrieNode<T>>>` to implement `Copy`\n   = note: the `Copy` trait is required because this value will be copied for each element of the array\n\nerror: aborting due to 1 previous error\n\nFor more information about this error, try `rustc --explain E0277`.\n",
        "trie_insert_binary": "pub fn trie_find_end_binary<'a, T>(trie: &'a Trie<T>, key: &[u8], key_length: usize) -> Option<&'a TrieNode<T>> {\n    let mut node = trie.root_node.as_ref().map(|n| &**n);\n\n    for j in 0..key_length {\n        if node.is_none() {\n            return None;\n        }\n\n        let c = key[j] as usize;\n\n        node = node.and_then(|n| n.next[c].as_ref().map(|n| &**n));\n    }\n\n    node\n}\n\nuse std::clone::Clone;\n\npub struct TrieNode<T> {\n    pub data: Option<T>,\n    pub use_count: u32,\n    pub next: [Option<Box<TrieNode<T>>>; 256],\n}\n\nimpl<T: Clone> Clone for TrieNode<T> {\n    fn clone(&self) -> Self {\n        TrieNode {\n            data: self.data.clone(),\n            use_count: self.use_count,\n            next: self.next.clone(),\n        }\n    }\n}\n\npub struct Trie<T> {\n    pub root_node: Option<Box<TrieNode<T>>>\n}\n\npub fn trie_insert_binary<T>(trie: &mut Trie<T>, key: &[u8], key_length: usize, value: T) -> i32 {\n    let node = trie_find_end_binary(trie, key, key_length);\n\n    if let Some(node) = node {\n        if node.data.is_some() {\n            let node = unsafe { &mut *(node as *const TrieNode<T> as *mut TrieNode<T>) };\n            node.data = Some(value);\n            return 1;\n        }\n    }\n\n    let mut rover = &mut trie.root_node;\n    let mut p = 0;\n\n    loop {\n        if rover.is_none() {\n            *rover = Some(Box::new(TrieNode {\n                data: None,\n                use_count: 0,\n                next: [(); 256].map(|_| None),\n            }));\n        }\n\n        let node = rover.as_mut().unwrap();\n        node.use_count += 1;\n\n        let c = key[p] as usize;\n\n        if p == key_length {\n            node.data = Some(value);\n            break;\n        }\n\n        rover = &mut node.next[c];\n        p += 1;\n    }\n\n    1\n}\n\npub fn trie_insert_rollback<T>(trie: &mut Trie<T>, key: &[u8]) {\n    let mut node = trie.root_node.take();\n    let mut prev_ptr = &mut trie.root_node;\n    let mut p = 0;\n\n    while let Some(mut current_node) = node {\n        let c = key[p] as usize;\n        let next_node = current_node.next[c].take();\n        p += 1;\n\n        current_node.use_count -= 1;\n\n        if current_node.use_count == 0 {\n            *prev_ptr = None;\n        } else {\n            *prev_ptr = Some(current_node);\n        }\n\n        node = next_node;\n        if let Some(ref mut next_node) = *prev_ptr {\n            prev_ptr = &mut next_node.next[c];\n        }\n    }\n}\n\nfn main(){}\n //编译报错信息：error: casting `&T` to `&mut T` is undefined behavior, even if the reference is unused, consider instead using an `UnsafeCell`\n  --> ../tmp/temp.rs:44:33\n   |\n44 |             let node = unsafe { &mut *(node as *const TrieNode<T> as *mut TrieNode<T>) };\n   |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: for more information, visit <https://doc.rust-lang.org/book/ch15-05-interior-mutability.html>\n   = note: even for types with interior mutability, the only legal way to obtain a mutable pointer from a shared reference is through `UnsafeCell::get`\n   = note: `#[deny(invalid_reference_casting)]` on by default\n\nerror: aborting due to 1 previous error\n\n",
        "trie_remove_binary": "pub fn trie_find_end_binary<'a, T>(trie: &'a Trie<T>, key: &[u8], key_length: usize) -> Option<&'a TrieNode<T>> {\n    let mut node = trie.root_node.as_ref();\n\n    for j in 0..key_length {\n        if node.is_none() {\n            return None;\n        }\n\n        let c = key[j] as usize;\n\n        node = node.and_then(|n| n.next[c].as_ref());\n    }\n\n    node.map(|n| &**n)\n}\n\nuse std::clone::Clone;\n\npub struct TrieNode<T> {\n    pub data: Option<T>,\n    pub use_count: u32,\n    pub next: [Option<Box<TrieNode<T>>>; 256],\n}\n\nimpl<T: Clone> Clone for TrieNode<T> {\n    fn clone(&self) -> Self {\n        TrieNode {\n            data: self.data.clone(),\n            use_count: self.use_count,\n            next: self.next.clone(),\n        }\n    }\n}\n\npub struct Trie<T> {\n    pub root_node: Option<Box<TrieNode<T>>>,\n}\n\npub const bin_key4: [u8; 4] = [ b'z', 0, b'z', b'z' ];\npub const bin_key2: [u8; 8] = [ b'a', b'b', b'c', 0, 1, 2, 0xff, 0 ];\npub const bin_key3: [u8; 3] = [ b'a', b'b', b'c' ];\npub const bin_key: [u8; 7] = [ b'a', b'b', b'c', 0, 1, 2, 0xff ];\n\npub fn trie_remove_binary<T>(trie: &mut Trie<T>, key: &[u8], key_length: usize) -> bool {\n    // Find the end node and remove the value\n    let end_node = trie_find_end_binary(trie, key, key_length);\n\n    if let Some(node) = end_node {\n        if node.data.is_some() {\n            node.data = None;\n        } else {\n            return false;\n        }\n    } else {\n        return false;\n    }\n\n    // Now traverse the tree again as before, decrementing the use count of each node. Free back nodes as necessary.\n    let mut node = trie.root_node.as_mut();\n    let mut last_next_ptr: Option<&mut Option<Box<TrieNode<T>>>> = None;\n    let mut p = 0;\n\n    while let Some(n) = node {\n        // Find the next node\n        let c = key[p] as usize;\n        let next = n.next[c].as_mut();\n\n        // Free this node if necessary\n        n.use_count -= 1;\n\n        if n.use_count <= 0 {\n            if let Some(last) = last_next_ptr {\n                *last = None;\n            }\n            node = None;\n        } else {\n            node = next;\n        }\n\n        // Go to the next character or finish\n        if p == key_length - 1 {\n            break;\n        } else {\n            p += 1;\n        }\n\n        // If necessary, save the location of the \"next\" pointer so that it may be set to NULL on the next iteration if the next node visited is freed.\n        if last_next_ptr.is_none() {\n            last_next_ptr = Some(&mut n.next[c]);\n        }\n    }\n\n    // Removed successfully\n    true\n}\n\nfn main(){}\n //编译报错信息：error[E0594]: cannot assign to `node.data`, which is behind a `&` reference\n  --> ../tmp/temp.rs:50:13\n   |\n48 |     if let Some(node) = end_node {\n   |                 ---- consider changing this binding's type to be: `&mut TrieNode<T>`\n49 |         if node.data.is_some() {\n50 |             node.data = None;\n   |             ^^^^^^^^^ `node` is a `&` reference, so the data it refers to cannot be written\n\nerror[E0382]: use of moved value\n  --> ../tmp/temp.rs:72:25\n   |\n72 |             if let Some(last) = last_next_ptr {\n   |                         ^^^^ value moved here, in previous iteration of loop\n...\n89 |             last_next_ptr = Some(&mut n.next[c]);\n   |             ------------------------------------ this reinitialization might get skipped\n   |\n   = note: move occurs because value has type `&mut Option<Box<TrieNode<T>>>`, which does not implement the `Copy` trait\n"
    },
    "test-trie": {
        "generate_binary_trie": "use std::clone::Clone;\n\npub struct TrieNode<T> {\n    pub data: Option<T>,\n    pub use_count: u32,\n    pub next: [Option<Box<TrieNode<T>>>; 256],\n}\n\nimpl<T: Clone> Clone for TrieNode<T> {\n    fn clone(&self) -> Self {\n        TrieNode {\n            data: self.data.clone(),\n            use_count: self.use_count,\n            next: self.next.clone(),\n        }\n    }\n}\n\npub struct Trie<T> {\n    pub root_node: Option<Box<TrieNode<T>>>,\n}\n\npub fn trie_new<T>() -> Option<Trie<T>> {\n    let mut new_trie = Trie {\n        root_node: None,\n    };\n\n    Some(new_trie)\n}\n\npub fn trie_find_end_binary<'a, T>(trie: &'a Trie<T>, key: &[u8], key_length: usize) -> Option<&'a TrieNode<T>> {\n    let mut node = trie.root_node.as_ref().map(|n| &**n);\n\n    for j in 0..key_length {\n        if node.is_none() {\n            return None;\n        }\n\n        let c = key[j] as usize;\n\n        node = node.and_then(|n| n.next[c].as_ref().map(|n| &**n));\n    }\n\n    node\n}\n\npub fn generate_binary_trie() -> Option<Trie<String>> {\n    let mut trie = trie_new::<String>();\n\n    if let Some(trie_ref) = &mut trie {\n        assert!(trie_insert_binary(trie_ref, b\"abc\\x00\\x01\\x02\\xff\\x00\", 8, \"goodbye world\".to_string()) != 0);\n        assert!(trie_insert_binary(trie_ref, b\"abc\\x00\\x01\\x02\\xff\", 7, \"hello world\".to_string()) != 0);\n    }\n\n    trie\n}\n\npub fn trie_insert_rollback<T>(trie: &mut Trie<T>, key: &[u8]) {\n    let mut node = trie.root_node.as_mut();\n    let mut prev_ptr = &mut trie.root_node;\n    let mut p = 0;\n\n    while let Some(current_node) = node {\n        let c = key[p] as usize;\n        let next_node = current_node.next[c].take();\n        p += 1;\n\n        current_node.use_count -= 1;\n\n        if current_node.use_count == 0 {\n            *prev_ptr = None;\n        }\n\n        node = next_node.as_mut();\n        prev_ptr = &mut current_node.next[c];\n    }\n}\n\npub fn trie_insert_binary<T: Clone>(trie: &mut Trie<T>, key: &[u8], key_length: usize, value: T) -> i32 {\n    if key_length == 0 {\n        return 0;\n    }\n\n    if let Some(node) = trie_find_end_binary(trie, key, key_length) {\n        if node.data.is_some() {\n            node.data = Some(value);\n            return 1;\n        }\n    }\n\n    let mut rover = &mut trie.root_node;\n    let mut p = 0;\n\n    loop {\n        let node = rover;\n\n        if node.is_none() {\n            let new_node = Box::new(TrieNode {\n                data: None,\n                use_count: 0,\n                next: [None; 256],\n            });\n\n            *rover = Some(new_node);\n        }\n\n        let current_node = rover.as_mut().unwrap();\n        current_node.use_count += 1;\n\n        let c = key[p] as usize;\n        p += 1;\n\n        if p == key_length {\n            current_node.data = Some(value);\n            break;\n        }\n\n        rover = &mut current_node.next[c];\n    }\n\n    1\n}\n\nfn main(){}\n //编译报错信息：error[E0277]: the trait bound `Box<TrieNode<_>>: Copy` is not satisfied\n   --> ../tmp/temp.rs:101:24\n    |\n101 |                 next: [None; 256],\n    |                        ^^^^\n    |                        |\n    |                        the trait `Copy` is not implemented for `Box<TrieNode<_>>`\n    |                        help: create an inline `const` block: `const { None }`\n    |\n",
        "generate_trie": "pub fn trie_num_entries<T>(trie: &Trie<T>) -> u32 {\n    if let Some(root_node) = &trie.root_node {\n        root_node.use_count\n    } else {\n        0\n    }\n}\n\npub fn trie_find_end<'a, T>(trie: &'a Trie<T>, key: &str) -> Option<&'a Box<TrieNode<T>>> {\n    let mut node = trie.root_node.as_ref();\n\n    for c in key.bytes() {\n        if let Some(n) = node {\n            node = n.next[c as usize].as_ref();\n        } else {\n            return None;\n        }\n    }\n\n    node\n}\n\nuse std::clone::Clone;\n\npub struct TrieNode<T> {\n    pub data: Option<T>,\n    pub use_count: u32,\n    pub next: [Option<Box<TrieNode<T>>>; 256],\n}\n\nimpl<T: Clone> Clone for TrieNode<T> {\n    fn clone(&self) -> Self {\n        TrieNode {\n            data: self.data.clone(),\n            use_count: self.use_count,\n            next: self.next.clone(),\n        }\n    }\n}\n\npub struct Trie<T> {\n    pub root_node: Option<Box<TrieNode<T>>>,\n}\n\npub const bin_key4: [u8; 4] = [ b'z', 0, b'z', b'z' ];\npub const bin_key2: [u8; 8] = [ b'a', b'b', b'c', 0, 1, 2, 0xff, 0 ];\npub const bin_key3: [u8; 3] = [ b'a', b'b', b'c' ];\npub const bin_key: [u8; 7] = [ b'a', b'b', b'c', 0, 1, 2, 0xff ];\n\npub fn trie_insert_rollback<T: Clone>(trie: &mut Trie<T>, key: &[u8]) {\n    let mut node = trie.root_node.take();\n    let mut prev_ptr = &mut trie.root_node;\n    let mut p = key.iter();\n\n    while let Some(mut current_node) = node {\n        let next_index = *p.next().unwrap_or(&0) as usize;\n        let next_node = current_node.next[next_index].take();\n\n        current_node.use_count -= 1;\n\n        if current_node.use_count == 0 {\n            *prev_ptr = None;\n        } else {\n            *prev_ptr = Some(current_node);\n        }\n\n        node = next_node;\n        if let Some(ref mut prev_node) = *prev_ptr {\n            prev_ptr = &mut prev_node.next[next_index];\n        }\n    }\n}\n\npub fn trie_new<T>() -> Option<Trie<T>> {\n    let mut new_trie = Trie {\n        root_node: None,\n    };\n\n    Some(new_trie)\n}\n\npub fn generate_trie() -> Option<Trie<i32>> {\n    let mut trie = trie_new()?;\n    let mut entries = 0;\n\n    for i in 0..NUM_TEST_VALUES {\n        unsafe {\n            test_array[i] = i as i32;\n            test_strings[i] = test_strings_from_string(format!(\"{}\", i));\n        }\n\n        assert!(trie_insert(&mut trie, &unsafe { std::str::from_utf8_unchecked(&test_strings[i]) }, &unsafe { test_array[i] }).is_ok());\n\n        entries += 1;\n\n        assert_eq!(trie_num_entries(&trie), entries);\n    }\n\n    Some(trie)\n}\n\npub fn trie_insert<T: Clone>(trie: &mut Trie<T>, key: &str, value: &T) -> Result<(), ()> {\n    if value.is_none() {\n        return Err(());\n    }\n\n    if let Some(node) = trie_find_end(trie, key) {\n        if node.data.is_some() {\n            node.data = Some(value.clone());\n            return Ok(());\n        }\n    }\n\n    let mut rover = &mut trie.root_node;\n    let mut p = key.bytes();\n\n    loop {\n        let c = p.next().unwrap_or(0) as usize;\n\n        if rover.is_none() {\n            *rover = Some(Box::new(TrieNode {\n                data: None,\n                use_count: 0,\n                next: [(); 256].map(|_| None),\n            }));\n        }\n\n        let node = rover.as_mut().unwrap();\n\n        node.use_count += 1;\n\n        if c == 0 {\n            node.data = Some(value.clone());\n            break;\n        }\n\n        rover = &mut node.next[c];\n    }\n\n    Ok(())\n}\n\npub const NUM_TEST_VALUES: usize = 10000;\npub const TRIE_NULL: Option<i32> = None;\n\npub fn assert(condition: bool) {\n    if !condition {\n        panic!(\"Assertion failed!\");\n    }\n}\n\npub fn assert_eq<T: std::cmp::PartialEq + std::fmt::Debug>(left: T, right: T) {\n    if left != right {\n        panic!(\"Assertion failed: {:?} != {:?}\", left, right);\n    }\n}\n\npub static mut test_array: [i32; NUM_TEST_VALUES] = [0; NUM_TEST_VALUES];\npub static mut test_strings: [[u8; 10]; NUM_TEST_VALUES] = [[0; 10]; NUM_TEST_VALUES];\n\nfn test_strings_from_string(s: String) -> [u8; 10] {\n    let mut arr = [0; 10];\n    let bytes = s.as_bytes();\n    let len = bytes.len().min(10);\n    arr[..len].copy_from_slice(&bytes[..len]);\n    arr\n}\n\nfn main(){}\n //编译报错信息：error[E0599]: no method named `is_none` found for reference `&T` in the current scope\n   --> ../tmp/temp.rs:103:14\n    |\n103 |     if value.is_none() {\n    |              ^^^^^^^ method not found in `&T`\n\nwarning: variable does not need to be mutable\n  --> ../tmp/temp.rs:75:9\n   |\n75 |     let mut new_trie = Trie {\n   |         ----^^^^^^^^\n   |         |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\nerror: aborting due to 1 previous error; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0599`.\n",
        "test_trie_negative_keys": "pub fn trie_free<T>(trie: Trie<T>) {\n    let mut free_list: Option<Box<TrieNode<T>>> = None;\n\n    if let Some(root_node) = trie.root_node {\n        trie_free_list_push(&mut free_list, root_node);\n    }\n\n    while let Some(mut node) = trie_free_list_pop(&mut free_list) {\n        for i in 0..256 {\n            if let Some(next_node) = node.next[i].take() {\n                trie_free_list_push(&mut free_list, next_node);\n            }\n        }\n    }\n}\n\npub fn trie_find_end<'a, T>(trie: &'a Trie<T>, key: &str) -> Option<&'a Box<TrieNode<T>>> {\n    let mut node = trie.root_node.as_ref();\n\n    for c in key.bytes() {\n        if let Some(n) = node {\n            node = n.next[c as usize].as_ref();\n        } else {\n            return None;\n        }\n    }\n\n    node\n}\n\nuse std::clone::Clone;\n\npub struct TrieNode<T> {\n    pub data: Option<T>,\n    pub use_count: u32,\n    pub next: [Option<Box<TrieNode<T>>>; 256],\n}\n\nimpl<T: Clone> Clone for TrieNode<T> {\n    fn clone(&self) -> Self {\n        TrieNode {\n            data: self.data.clone(),\n            use_count: self.use_count,\n            next: self.next.clone(),\n        }\n    }\n}\n\npub struct Trie<T> {\n    pub root_node: Option<Box<TrieNode<T>>>,\n}\n\npub const bin_key4: [u8; 4] = [ b'z', 0, b'z', b'z' ];\npub const bin_key2: [u8; 8] = [ b'a', b'b', b'c', 0, 1, 2, 0xff, 0 ];\npub const bin_key3: [u8; 3] = [ b'a', b'b', b'c' ];\npub const bin_key: [u8; 7] = [ b'a', b'b', b'c', 0, 1, 2, 0xff ];\npub fn trie_insert_rollback<T: Clone>(trie: &mut Trie<T>, key: &[u8]) {\n    let mut node = trie.root_node.take();\n    let mut prev_ptr = &mut trie.root_node;\n    let mut p = key.iter();\n\n    while let Some(mut current_node) = node {\n        let next_index = *p.next().unwrap_or(&0) as usize;\n        let next_node = current_node.next[next_index].take();\n\n        current_node.use_count -= 1;\n\n        if current_node.use_count == 0 {\n            *prev_ptr = None;\n        } else {\n            *prev_ptr = Some(current_node);\n        }\n\n        node = next_node;\n        if let Some(ref mut prev_node) = *prev_ptr {\n            prev_ptr = &mut prev_node.next[next_index];\n        }\n    }\n}\n\npub fn trie_free_list_pop<T>(list: &mut Option<Box<TrieNode<T>>>) -> Option<Box<TrieNode<T>>> {\n    if let Some(mut result) = list.take() {\n        *list = result.next[0].take();\n        Some(result)\n    } else {\n        None\n    }\n}\n\npub fn trie_remove<T>(trie: &mut Trie<T>, key: &str) -> bool {\n    let node = trie_find_end(trie, key);\n\n    if let Some(node) = node {\n        if node.data.is_some() {\n            if let Some(mut node_mut) = trie.root_node.as_deref_mut() {\n                let mut current = &mut *node_mut;\n                for c in key.bytes() {\n                    current = current.next[c as usize].as_deref_mut().unwrap();\n                }\n                current.data = None;\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    } else {\n        return false;\n    }\n\n    let mut node = &mut trie.root_node;\n    let mut last_next_ptr: *mut Option<Box<TrieNode<T>>> = std::ptr::null_mut();\n    let mut p = key.as_bytes().iter();\n\n    while let Some(&c) = p.next() {\n        if let Some(n) = node.as_deref_mut() {\n            n.use_count -= 1;\n\n            if n.use_count <= 0 {\n                if !last_next_ptr.is_null() {\n                    unsafe {\n                        *last_next_ptr = None;\n                    }\n                }\n                break;\n            }\n\n            last_next_ptr = &mut n.next[c as usize];\n            node = &mut n.next[c as usize];\n        } else {\n            break;\n        }\n    }\n\n    true\n}\n\npub fn trie_new<T>() -> Option<Trie<T>> {\n    let mut new_trie = Trie {\n        root_node: None,\n    };\n\n    Some(new_trie)\n}\n\npub fn trie_free_list_push<T>(list: &mut Option<Box<TrieNode<T>>>, mut node: Box<TrieNode<T>>) {\n    node.data = None;\n    *list = Some(node);\n}\n\npub fn trie_lookup<'a, T>(trie: &'a Trie<T>, key: &str) -> Option<&'a T> {\n    let node = trie_find_end(trie, key);\n\n    if let Some(n) = node {\n        n.data.as_ref()\n    } else {\n        None\n    }\n}\n\npub fn test_trie_negative_keys() {\n    let my_key: [u8; 6] = [b'a', b'b', b'c', 206, 236, 0];\n    let mut trie = trie_new::<&str>().unwrap();\n    let value = \"hello world\";\n\n    assert!(trie_insert(&mut trie, &my_key, value));\n\n    let found_value = trie_lookup(&trie, &String::from_utf8_lossy(&my_key));\n    assert_eq!(found_value, Some(&value));\n\n    assert!(trie_remove(&mut trie, &String::from_utf8_lossy(&my_key)));\n    assert!(!trie_remove(&mut trie, &String::from_utf8_lossy(&my_key)));\n    assert_eq!(trie_lookup(&trie, &String::from_utf8_lossy(&my_key)), None);\n\n    trie_free(trie);\n}\n\npub fn trie_insert<T: Clone + PartialEq + Default>(trie: &mut Trie<T>, key: &[u8], value: T) -> bool {\n    if value == T::default() {\n        return false;\n    }\n\n    if let Some(node) = trie_find_end(trie, &String::from_utf8_lossy(key)) {\n        if node.data.is_some() {\n            node.data = Some(value);\n            return true;\n        }\n    }\n\n    let mut rover = &mut trie.root_node;\n    let mut p = key.iter();\n\n    while let Some(&c) = p.next() {\n        if rover.is_none() {\n            *rover = Some(Box::new(TrieNode {\n                data: None,\n                use_count: 0,\n                next: [None; 256],\n            }));\n        }\n\n        let node = rover.as_mut().unwrap();\n        node.use_count += 1;\n\n        if c == 0 {\n            node.data = Some(value);\n            break;\n        }\n\n        rover = &mut node.next[c as usize];\n    }\n\n    true\n}\n\nfn main(){}\n //编译报错信息：error[E0277]: the trait bound `Box<TrieNode<T>>: Copy` is not satisfied\n   --> ../tmp/temp.rs:198:24\n    |\n198 |                 next: [None; 256],\n    |                        ^^^^\n    |                        |\n    |                        the trait `Copy` is not implemented for `Box<TrieNode<T>>`\n    |                        help: create an inline `const` block: `const { None }`\n    |\n",
        "test_trie_insert_out_of_memory": "pub fn trie_lookup_binary<'a, T>(trie: &'a Trie<T>, key: &[u8], key_length: usize) -> Option<&'a T> {\n    let node = trie_find_end_binary(trie, key, key_length);\n\n    if let Some(n) = node {\n        n.data.as_ref()\n    } else {\n        None\n    }\n}\n\npub fn trie_free<T>(trie: Trie<T>) {\n    let mut free_list: Option<Box<TrieNode<T>>> = None;\n\n    if let Some(root_node) = trie.root_node {\n        trie_free_list_push(&mut free_list, root_node);\n    }\n\n    while let Some(mut node) = trie_free_list_pop(&mut free_list) {\n        for i in 0..256 {\n            if let Some(next_node) = node.next[i].take() {\n                trie_free_list_push(&mut free_list, next_node);\n            }\n        }\n    }\n}\n\npub fn trie_find_end_binary<'a, T>(trie: &'a Trie<T>, key: &[u8], key_length: usize) -> Option<&'a TrieNode<T>> {\n    let mut node = trie.root_node.as_ref().map(|n| &**n);\n\n    for j in 0..key_length {\n        if node.is_none() {\n            return None;\n        }\n\n        let c = key[j] as usize;\n\n        node = node.and_then(|n| n.next[c].as_ref().map(|n| &**n));\n    }\n\n    node\n}\n\npub fn trie_num_entries<T>(trie: &Trie<T>) -> u32 {\n    if let Some(root_node) = &trie.root_node {\n        root_node.use_count\n    } else {\n        0\n    }\n}\n\npub fn trie_free_list_pop<T>(list: &mut Option<Box<TrieNode<T>>>) -> Option<Box<TrieNode<T>>> {\n    if let Some(mut result) = list.take() {\n        *list = result.next[0].take();\n        Some(result)\n    } else {\n        None\n    }\n}\n\npub fn trie_new<T>() -> Option<Trie<T>> {\n    let mut new_trie = Trie {\n        root_node: None,\n    };\n\n    Some(new_trie)\n}\n\nuse std::clone::Clone;\n\npub struct TrieNode<T> {\n    pub data: Option<T>,\n    pub use_count: u32,\n    pub next: [Option<Box<TrieNode<T>>>; 256],\n}\n\nimpl<T: Clone> Clone for TrieNode<T> {\n    fn clone(&self) -> Self {\n        TrieNode {\n            data: self.data.clone(),\n            use_count: self.use_count,\n            next: self.next.clone(),\n        }\n    }\n}\n\npub struct Trie<T> {\n    pub root_node: Option<Box<TrieNode<T>>>,\n}\n\npub fn trie_free_list_push<T>(list: &mut Option<Box<TrieNode<T>>>, mut node: Box<TrieNode<T>>) {\n    node.data = None;\n    *list = Some(node);\n}\n\npub fn test_trie_insert_out_of_memory() {\n    let mut trie = generate_binary_trie();\n\n    assert_eq!(trie_insert_binary(&mut trie, &bin_key4, bin_key4.len(), \"test value\"), 0);\n    assert_eq!(trie_lookup_binary(&trie, &bin_key4, bin_key4.len()), None);\n    assert_eq!(trie_num_entries(&trie), 2);\n\n    trie_free(trie);\n}\n\npub fn trie_insert_rollback<T>(trie: &mut Trie<T>, key: &[u8]) {\n    let mut node = trie.root_node.as_mut();\n    let mut prev_ptr = &mut trie.root_node;\n    let mut p = 0;\n\n    while let Some(current_node) = node {\n        let c = key[p] as usize;\n        let next_node = current_node.next[c].take();\n        p += 1;\n\n        current_node.use_count -= 1;\n\n        if current_node.use_count == 0 {\n            if let Some(prev) = prev_ptr {\n                *prev = None;\n            }\n        } else {\n            *prev_ptr = current_node.next[c].as_mut();\n        }\n\n        node = next_node;\n        prev_ptr = &mut current_node.next[c];\n    }\n}\n\npub fn generate_binary_trie<T>() -> Trie<T> {\n    let mut trie = trie_new().unwrap();\n\n    assert_ne!(trie_insert_binary(&mut trie, &bin_key2, bin_key2.len(), \"goodbye world\".to_string()), 0);\n    assert_ne!(trie_insert_binary(&mut trie, &bin_key, bin_key.len(), \"hello world\".to_string()), 0);\n\n    trie\n}\n\npub fn trie_insert_binary<T>(trie: &mut Trie<T>, key: &[u8], key_length: usize, value: T) -> i32 {\n    if value == TRIE_NULL {\n        return 0;\n    }\n\n    let mut rover = &mut trie.root_node;\n    let mut p = 0;\n\n    while let Some(node) = rover {\n        node.use_count += 1;\n\n        let c = key[p] as usize;\n        rover = &mut node.next[c];\n        p += 1;\n\n        if p == key_length {\n            node.data = Some(value);\n            return 1;\n        }\n    }\n\n    let mut current = rover;\n    while p <= key_length {\n        let new_node = Box::new(TrieNode {\n            data: if p == key_length { Some(value) } else { None },\n            use_count: 1,\n            next: [None; 256],\n        });\n\n        *current = Some(new_node);\n        current = &mut current.as_mut().unwrap().next[key[p] as usize];\n        p += 1;\n    }\n\n    1\n}\n\npub const TRIE_NULL: Option<String> = None;\n\npub const bin_key2: [u8; 8] = [ b'a', b'b', b'c', 0, 1, 2, 0xff, 0 ];\npub const bin_key3: [u8; 3] = [ b'a', b'b', b'c' ];\npub const bin_key4: [u8; 4] = [ b'z', 0, b'z', b'z' ];\npub const bin_key: [u8; 7] = [ b'a', b'b', b'c', 0, 1, 2, 0xff ];\n\nfn main(){}\n //编译报错信息：error[E0308]: mismatched types\n   --> ../tmp/temp.rs:119:25\n    |\n119 |                 *prev = None;\n    |                 -----   ^^^^ expected `Box<TrieNode<T>>`, found `Option<_>`\n    |                 |\n    |                 expected due to the type of this binding\n    |\n",
        "test_trie_insert_empty": "pub fn trie_num_entries<T>(trie: &Trie<T>) -> u32 {\n    if let Some(root_node) = &trie.root_node {\n        root_node.use_count\n    } else {\n        0\n    }\n}\n\npub fn trie_free<T>(trie: Trie<T>) {\n    let mut free_list: Option<Box<TrieNode<T>>> = None;\n\n    if let Some(root_node) = trie.root_node {\n        trie_free_list_push(&mut free_list, root_node);\n    }\n\n    while let Some(mut node) = trie_free_list_pop(&mut free_list) {\n        for i in 0..256 {\n            if let Some(next_node) = node.next[i].take() {\n                trie_free_list_push(&mut free_list, next_node);\n            }\n        }\n    }\n}\n\npub fn trie_find_end<'a, T>(trie: &'a Trie<T>, key: &str) -> Option<&'a Box<TrieNode<T>>> {\n    let mut node = trie.root_node.as_ref();\n\n    for c in key.bytes() {\n        if let Some(n) = node {\n            node = n.next[c as usize].as_ref();\n        } else {\n            return None;\n        }\n    }\n\n    node\n}\n\nuse std::clone::Clone;\n\npub struct TrieNode<T> {\n    pub data: Option<T>,\n    pub use_count: u32,\n    pub next: [Option<Box<TrieNode<T>>>; 256],\n}\n\nimpl<T: Clone> Clone for TrieNode<T> {\n    fn clone(&self) -> Self {\n        TrieNode {\n            data: self.data.clone(),\n            use_count: self.use_count,\n            next: self.next.clone(),\n        }\n    }\n}\n\npub struct Trie<T> {\n    pub root_node: Option<Box<TrieNode<T>>>,\n}\n\npub const bin_key4: [u8; 4] = [ b'z', 0, b'z', b'z' ];\npub const bin_key2: [u8; 8] = [ b'a', b'b', b'c', 0, 1, 2, 0xff, 0 ];\npub const bin_key3: [u8; 3] = [ b'a', b'b', b'c' ];\npub const bin_key: [u8; 7] = [ b'a', b'b', b'c', 0, 1, 2, 0xff ];\npub fn trie_insert_rollback<T: Clone>(trie: &mut Trie<T>, key: &[u8]) {\n    let mut node = trie.root_node.take();\n    let mut prev_ptr = &mut trie.root_node;\n    let mut p = key.iter();\n\n    while let Some(mut current_node) = node {\n        let next_index = *p.next().unwrap_or(&0) as usize;\n        let next_node = current_node.next[next_index].take();\n\n        current_node.use_count -= 1;\n\n        if current_node.use_count == 0 {\n            *prev_ptr = None;\n        } else {\n            *prev_ptr = Some(current_node);\n        }\n\n        node = next_node;\n        if let Some(ref mut prev_node) = *prev_ptr {\n            prev_ptr = &mut prev_node.next[next_index];\n        }\n    }\n}\n\npub fn trie_free_list_pop<T>(list: &mut Option<Box<TrieNode<T>>>) -> Option<Box<TrieNode<T>>> {\n    if let Some(mut result) = list.take() {\n        *list = result.next[0].take();\n        Some(result)\n    } else {\n        None\n    }\n}\n\npub fn trie_remove<T>(trie: &mut Trie<T>, key: &str) -> bool {\n    let node = trie_find_end(trie, key);\n\n    if let Some(node) = node {\n        if node.data.is_some() {\n            if let Some(mut node_mut) = trie.root_node.as_deref_mut() {\n                let mut current = &mut *node_mut;\n                for c in key.bytes() {\n                    current = current.next[c as usize].as_deref_mut().unwrap();\n                }\n                current.data = None;\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    } else {\n        return false;\n    }\n\n    let mut node = &mut trie.root_node;\n    let mut last_next_ptr: *mut Option<Box<TrieNode<T>>> = std::ptr::null_mut();\n    let mut p = key.as_bytes().iter();\n\n    while let Some(&c) = p.next() {\n        if let Some(n) = node.as_deref_mut() {\n            n.use_count -= 1;\n\n            if n.use_count <= 0 {\n                if !last_next_ptr.is_null() {\n                    unsafe {\n                        *last_next_ptr = None;\n                    }\n                }\n                break;\n            }\n\n            last_next_ptr = &mut n.next[c as usize];\n            node = &mut n.next[c as usize];\n        } else {\n            break;\n        }\n    }\n\n    true\n}\n\npub fn trie_new<T>() -> Option<Trie<T>> {\n    let mut new_trie = Trie {\n        root_node: None,\n    };\n\n    Some(new_trie)\n}\n\npub fn trie_free_list_push<T>(list: &mut Option<Box<TrieNode<T>>>, mut node: Box<TrieNode<T>>) {\n    node.data = None;\n    *list = Some(node);\n}\n\npub fn trie_lookup<'a, T>(trie: &'a Trie<T>, key: &str) -> Option<&'a T> {\n    let node = trie_find_end(trie, key);\n\n    if let Some(n) = node {\n        n.data.as_ref()\n    } else {\n        None\n    }\n}\n\npub fn test_trie_insert_empty() {\n    let mut trie = trie_new::<String>().unwrap();\n    let buf = String::from(\"\");\n\n    assert!(trie_insert(&mut trie, \"\", buf.clone()));\n    assert!(trie_num_entries(&trie) != 0);\n    assert_eq!(trie_lookup(&trie, \"\"), Some(&buf));\n    assert!(trie_remove(&mut trie, \"\"));\n\n    assert_eq!(trie_num_entries(&trie), 0);\n\n    trie_free(trie);\n}\n\npub fn trie_insert<T: Clone + Default + PartialEq>(trie: &mut Trie<T>, key: &str, value: T) -> bool {\n    let mut rover = &mut trie.root_node;\n    let mut node: Option<Box<TrieNode<T>>>;\n    let mut p = key.bytes();\n\n    if value == T::default() {\n        return false;\n    }\n\n    if let Some(end_node) = trie_find_end(trie, key) {\n        if end_node.data.is_some() {\n            let mut end_node_mut = end_node.clone();\n            end_node_mut.data = Some(value);\n            return true;\n        }\n    }\n\n    loop {\n        node = rover.take();\n\n        if node.is_none() {\n            node = Some(Box::new(TrieNode {\n                data: None,\n                use_count: 0,\n                next: [None; 256],\n            }));\n            *rover = node.clone();\n        }\n\n        let mut current_node = rover.as_mut().unwrap();\n        current_node.use_count += 1;\n\n        match p.next() {\n            Some(c) => {\n                rover = &mut current_node.next[c as usize];\n            }\n            None => {\n                current_node.data = Some(value);\n                break;\n            }\n        }\n    }\n\n    true\n}\n\nfn main(){}\n //编译报错信息：error[E0277]: the trait bound `Box<TrieNode<T>>: Copy` is not satisfied\n   --> ../tmp/temp.rs:207:24\n    |\n207 |                 next: [None; 256],\n    |                        ^^^^\n    |                        |\n    |                        the trait `Copy` is not implemented for `Box<TrieNode<T>>`\n    |                        help: create an inline `const` block: `const { None }`\n    |\n",
        "test_trie_lookup": "\npub fn trie_num_entries<T>(trie: &Trie<T>) -> u32 {\n    if let Some(root_node) = &trie.root_node {\n        root_node.use_count\n    } else {\n        0\n    }\n}\n\npub fn trie_free<T>(trie: Trie<T>) {\n    let mut free_list: Option<Box<TrieNode<T>>> = None;\n\n    if let Some(root_node) = trie.root_node {\n        trie_free_list_push(&mut free_list, root_node);\n    }\n\n    while let Some(mut node) = trie_free_list_pop(&mut free_list) {\n        for i in 0..256 {\n            if let Some(next_node) = node.next[i].take() {\n                trie_free_list_push(&mut free_list, next_node);\n            }\n        }\n    }\n}\n\npub fn trie_find_end<'a, T>(trie: &'a Trie<T>, key: &str) -> Option<&'a Box<TrieNode<T>>> {\n    let mut node = trie.root_node.as_ref();\n\n    for c in key.bytes() {\n        if let Some(n) = node {\n            node = n.next[c as usize].as_ref();\n        } else {\n            return None;\n        }\n    }\n\n    node\n}\n\nuse std::clone::Clone;\n\npub struct TrieNode<T> {\n    pub data: Option<T>,\n    pub use_count: u32,\n    pub next: [Option<Box<TrieNode<T>>>; 256],\n}\n\nimpl<T: Clone> Clone for TrieNode<T> {\n    fn clone(&self) -> Self {\n        TrieNode {\n            data: self.data.clone(),\n            use_count: self.use_count,\n            next: self.next.clone(),\n        }\n    }\n}\n\npub struct Trie<T> {\n    pub root_node: Option<Box<TrieNode<T>>>,\n}\n\npub const bin_key4: [u8; 4] = [ b'z', 0, b'z', b'z' ];\npub const bin_key2: [u8; 8] = [ b'a', b'b', b'c', 0, 1, 2, 0xff, 0 ];\npub const bin_key3: [u8; 3] = [ b'a', b'b', b'c' ];\npub const bin_key: [u8; 7] = [ b'a', b'b', b'c', 0, 1, 2, 0xff ];\n\npub fn trie_insert_rollback<T: Clone>(trie: &mut Trie<T>, key: &[u8]) {\n    let mut node = trie.root_node.take();\n    let mut prev_ptr = &mut trie.root_node;\n    let mut p = key.iter();\n\n    while let Some(mut current_node) = node {\n        let next_index = *p.next().unwrap_or(&0) as usize;\n        let next_node = current_node.next[next_index].take();\n\n        current_node.use_count -= 1;\n\n        if current_node.use_count == 0 {\n            *prev_ptr = None;\n        } else {\n            *prev_ptr = Some(current_node);\n        }\n\n        node = next_node;\n        if let Some(ref mut prev_node) = *prev_ptr {\n            prev_ptr = &mut prev_node.next[next_index];\n        }\n    }\n}\n\npub fn trie_free_list_pop<T>(list: &mut Option<Box<TrieNode<T>>>) -> Option<Box<TrieNode<T>>> {\n    if let Some(mut result) = list.take() {\n        *list = result.next[0].take();\n        Some(result)\n    } else {\n        None\n    }\n}\n\npub fn trie_new<T>() -> Option<Trie<T>> {\n    let mut new_trie = Trie {\n        root_node: None,\n    };\n\n    Some(new_trie)\n}\n\npub fn trie_free_list_push<T>(list: &mut Option<Box<TrieNode<T>>>, mut node: Box<TrieNode<T>>) {\n    node.data = None;\n    *list = Some(node);\n}\n\npub fn trie_lookup<'a, T>(trie: &'a Trie<T>, key: &str) -> Option<&'a T> {\n    let node = trie_find_end(trie, key);\n\n    if let Some(n) = node {\n        n.data.as_ref()\n    } else {\n        None\n    }\n}\n\npub fn test_trie_lookup() {\n    let mut trie = generate_trie();\n\n    /* Test lookup for non-existent values */\n    assert!(trie_lookup(&trie, \"000000000000000\").is_none());\n    assert!(trie_lookup(&trie, \"\").is_none());\n\n    /* Look up all values */\n    for i in 0..NUM_TEST_VALUES {\n        let mut buf = String::new();\n        write!(&mut buf, \"{}\", i).unwrap();\n\n        let val = trie_lookup(&trie, &buf);\n\n        assert_eq!(val, Some(&test_array[i]));\n    }\n\n    trie_free(trie);\n}\n\npub fn generate_trie() -> Trie<i32> {\n    let mut trie = trie_new().unwrap();\n    let mut entries = 0;\n\n    /* Create a trie and fill it with a large number of values */\n    for i in 0..NUM_TEST_VALUES {\n        /* Create a string containing a text version of i, and use\n         * it as a key for the value */\n\n        test_array[i] = i;\n        unsafe {\n            test_strings[i] = format!(\"{}\", i);\n        }\n\n        assert!(trie_insert(&mut trie, &unsafe { test_strings[i] }, test_array[i]) != 0);\n\n        entries += 1;\n\n        assert_eq!(trie_num_entries(&trie), entries);\n    }\n\n    trie\n}\n\npub fn trie_insert<T: Clone>(trie: &mut Trie<T>, key: &str, value: T) -> i32 {\n    let mut rover = &mut trie.root_node;\n    let mut node: Option<Box<TrieNode<T>>>;\n    let mut p = key.bytes();\n\n    /* Cannot insert NULL values */\n    if value == TRIE_NULL {\n        return 0;\n    }\n\n    /* Search to see if this is already in the tree */\n    node = trie_find_end(trie, key).cloned();\n\n    /* Already in the tree? If so, replace the existing value and\n     * return success. */\n    if let Some(mut n) = node {\n        n.data = Some(value);\n        *rover = Some(n);\n        return 1;\n    }\n\n    /* Search down the trie until we reach the end of string,\n     * creating nodes as necessary */\n    for c in p {\n        node = rover.take();\n\n        if node.is_none() {\n            /* Node does not exist, so create it */\n            let mut new_node = Box::new(TrieNode {\n                data: None,\n                use_count: 0,\n                next: [None; 256],\n            });\n\n            /* Link in to the trie */\n            *rover = Some(new_node);\n            node = rover.take();\n        }\n\n        let mut n = node.unwrap();\n\n        /* Increase the node use count */\n        n.use_count += 1;\n\n        /* Advance to the next node in the chain */\n        rover = &mut n.next[c as usize];\n        *rover = Some(n);\n    }\n\n    /* Set the data at the node we have reached */\n    if let Some(mut n) = rover.take() {\n        n.data = Some(value);\n        *rover = Some(n);\n    }\n\n    1\n}\n\npub const NUM_TEST_VALUES: usize = 10000;\npub const TRIE_NULL: Option<i32> = None;\n\npub static mut test_array: [i32; NUM_TEST_VALUES] = [0; NUM_TEST_VALUES];\npub static mut test_strings: [String; NUM_TEST_VALUES] = [String::new(); NUM_TEST_VALUES];\n\nfn main(){}\n\n //编译报错信息：error[E0277]: the trait bound `String: Copy` is not satisfied\n   --> ../tmp/temp.rs:229:59\n    |\n229 | pub static mut test_strings: [String; NUM_TEST_VALUES] = [String::new(); NUM_TEST_VALUES];\n    |                                                           ^^^^^^^^^^^^^\n    |                                                           |\n    |                                                           the trait `Copy` is not implemented for `String`\n    |                                                           help: create an inline `const` block: `const { String::new() }`\n    |\n",
        "test_trie_insert_binary": "pub fn trie_lookup_binary<'a, T>(trie: &'a Trie<T>, key: &[u8], key_length: usize) -> Option<&'a T> {\n    let node = trie_find_end_binary(trie, key, key_length);\n\n    if let Some(n) = node {\n        n.data.as_ref()\n    } else {\n        None\n    }\n}\n\npub fn trie_free<T>(trie: Trie<T>) {\n    let mut free_list: Option<Box<TrieNode<T>>> = None;\n\n    if let Some(root_node) = trie.root_node {\n        trie_free_list_push(&mut free_list, root_node);\n    }\n\n    while let Some(mut node) = trie_free_list_pop(&mut free_list) {\n        for i in 0..256 {\n            if let Some(next_node) = node.next[i].take() {\n                trie_free_list_push(&mut free_list, next_node);\n            }\n        }\n    }\n}\n\npub fn trie_find_end_binary<'a, T>(trie: &'a Trie<T>, key: &[u8], key_length: usize) -> Option<&'a TrieNode<T>> {\n    let mut node = trie.root_node.as_ref().map(|n| &**n);\n\n    for j in 0..key_length {\n        if node.is_none() {\n            return None;\n        }\n\n        let c = key[j] as usize;\n\n        node = node.and_then(|n| n.next[c].as_ref().map(|n| &**n));\n    }\n\n    node\n}\n\npub fn trie_free_list_pop<T>(list: &mut Option<Box<TrieNode<T>>>) -> Option<Box<TrieNode<T>>> {\n    if let Some(mut result) = list.take() {\n        *list = result.next[0].take();\n        Some(result)\n    } else {\n        None\n    }\n}\n\npub fn trie_new<T>() -> Option<Trie<T>> {\n    let mut new_trie = Trie {\n        root_node: None,\n    };\n\n    Some(new_trie)\n}\n\nuse std::clone::Clone;\n\npub struct TrieNode<T> {\n    pub data: Option<T>,\n    pub use_count: u32,\n    pub next: [Option<Box<TrieNode<T>>>; 256],\n}\n\nimpl<T: Clone> Clone for TrieNode<T> {\n    fn clone(&self) -> Self {\n        TrieNode {\n            data: self.data.clone(),\n            use_count: self.use_count,\n            next: self.next.clone(),\n        }\n    }\n}\n\npub struct Trie<T> {\n    pub root_node: Option<Box<TrieNode<T>>>,\n}\n\npub fn trie_free_list_push<T>(list: &mut Option<Box<TrieNode<T>>>, mut node: Box<TrieNode<T>>) {\n    node.data = None;\n    *list = Some(node);\n}\n\npub fn test_trie_insert_binary() {\n    let mut trie = generate_binary_trie().unwrap();\n\n    // Overwrite a value\n    assert!(trie_insert_binary(&mut trie, &bin_key, bin_key.len(), Some(\"hi world\".to_string())));\n\n    // Insert NULL value doesn't work\n    assert!(!trie_insert_binary(&mut trie, &bin_key3, bin_key3.len(), None));\n\n    // Read them back\n    let value = trie_lookup_binary(&trie, &bin_key, bin_key.len());\n    assert_eq!(value, Some(&\"hi world\".to_string()));\n\n    let value = trie_lookup_binary(&trie, &bin_key2, bin_key2.len());\n    assert_eq!(value, Some(&\"goodbye world\".to_string()));\n\n    trie_free(trie);\n}\n\npub fn trie_insert_rollback<T>(trie: &mut Trie<T>, key: &[u8]) {\n    let mut node = trie.root_node.as_mut();\n    let mut prev_ptr = &mut trie.root_node;\n    let mut p = 0;\n\n    while let Some(n) = node {\n        // Find the next node now. We might free this node.\n        let next_prev_ptr = &mut n.next[key[p] as usize];\n        let next_node = next_prev_ptr.take();\n        p += 1;\n\n        // Decrease the use count and free the node if it reaches zero.\n        n.use_count -= 1;\n\n        if n.use_count == 0 {\n            *prev_ptr = None;\n        } else {\n            *next_prev_ptr = next_node;\n        }\n\n        // Update pointers\n        node = next_node;\n        prev_ptr = next_prev_ptr;\n    }\n}\n\npub fn generate_binary_trie() -> Option<Trie<String>> {\n    let mut trie = trie_new::<String>()?;\n\n    // Insert some values\n    assert!(trie_insert_binary(&mut trie, &bin_key2, bin_key2.len(), Some(\"goodbye world\".to_string())));\n    assert!(trie_insert_binary(&mut trie, &bin_key, bin_key.len(), Some(\"hello world\".to_string())));\n\n    Some(trie)\n}\n\npub fn trie_insert_binary<T>(trie: &mut Trie<T>, key: &[u8], key_length: usize, value: Option<T>) -> bool {\n    // Cannot insert NULL values\n    if value.is_none() {\n        return false;\n    }\n\n    // Search to see if this is already in the tree\n    let node = trie_find_end_binary(trie, key, key_length);\n\n    // Already in the tree? If so, replace the existing value and return success.\n    if let Some(n) = node {\n        if n.data.is_some() {\n            n.data = value;\n            return true;\n        }\n    }\n\n    // Search down the trie until we reach the end of string, creating nodes as necessary\n    let mut rover = &mut trie.root_node;\n    let mut p = 0;\n\n    loop {\n        let node = rover.get_or_insert_with(|| {\n            TrieNode {\n                data: None,\n                use_count: 0,\n                next: [(); 256].map(|_| None),\n            }\n        });\n\n        // Increase the node use count\n        node.use_count += 1;\n\n        // Current character\n        let c = key[p] as usize;\n\n        // Reached the end of string? If so, we're finished.\n        if p == key_length {\n            // Set the data at the node we have reached\n            node.data = value;\n            break;\n        }\n\n        // Advance to the next node in the chain\n        rover = &mut node.next[c];\n        p += 1;\n    }\n\n    true\n}\n\npub const bin_key2: [u8; 8] = [b'a', b'b', b'c', 0, 1, 2, 0xff, 0];\npub const bin_key3: [u8; 3] = [b'a', b'b', b'c'];\npub const bin_key: [u8; 7] = [b'a', b'b', b'c', 0, 1, 2, 0xff];\n\nfn main(){}\n //编译报错信息：error[E0308]: mismatched types\n   --> ../tmp/temp.rs:127:16\n    |\n107 |     let mut node = trie.root_node.as_mut();\n    |                    ----------------------- expected due to this value\n...\n127 |         node = next_node;\n    |                ^^^^^^^^^ expected `Option<&mut ...>`, found `Option<Box<...>>`\n    |\n",
        "test_trie_free_long": "pub fn trie_free<T>(trie: Trie<T>) {\n    let mut free_list: Option<Box<TrieNode<T>>> = None;\n\n    if let Some(root_node) = trie.root_node {\n        trie_free_list_push(&mut free_list, root_node);\n    }\n\n    while let Some(mut node) = trie_free_list_pop(&mut free_list) {\n        for i in 0..256 {\n            if let Some(next_node) = node.next[i].take() {\n                trie_free_list_push(&mut free_list, next_node);\n            }\n        }\n    }\n}\n\npub fn trie_find_end<'a, T>(trie: &'a Trie<T>, key: &str) -> Option<&'a Box<TrieNode<T>>> {\n    let mut node = trie.root_node.as_ref();\n\n    for c in key.bytes() {\n        if let Some(n) = node {\n            node = n.next[c as usize].as_ref();\n        } else {\n            return None;\n        }\n    }\n\n    node\n}\n\nuse std::clone::Clone;\n\npub struct TrieNode<T> {\n    pub data: Option<T>,\n    pub use_count: u32,\n    pub next: [Option<Box<TrieNode<T>>>; 256],\n}\n\nimpl<T: Clone> Clone for TrieNode<T> {\n    fn clone(&self) -> Self {\n        TrieNode {\n            data: self.data.clone(),\n            use_count: self.use_count,\n            next: self.next.clone(),\n        }\n    }\n}\n\npub struct Trie<T> {\n    pub root_node: Option<Box<TrieNode<T>>>,\n}\n\npub const bin_key4: [u8; 4] = [ b'z', 0, b'z', b'z' ];\npub const bin_key2: [u8; 8] = [ b'a', b'b', b'c', 0, 1, 2, 0xff, 0 ];\npub const bin_key3: [u8; 3] = [ b'a', b'b', b'c' ];\npub const bin_key: [u8; 7] = [ b'a', b'b', b'c', 0, 1, 2, 0xff ];\n\npub fn trie_insert_rollback<T: Clone>(trie: &mut Trie<T>, key: &[u8]) {\n    let mut node = trie.root_node.take();\n    let mut prev_ptr = &mut trie.root_node;\n    let mut p = key.iter();\n\n    while let Some(mut current_node) = node {\n        let next_index = *p.next().unwrap_or(&0) as usize;\n        let next_node = current_node.next[next_index].take();\n\n        current_node.use_count -= 1;\n\n        if current_node.use_count == 0 {\n            *prev_ptr = None;\n        } else {\n            *prev_ptr = Some(current_node);\n        }\n\n        node = next_node;\n        if let Some(ref mut prev_node) = *prev_ptr {\n            prev_ptr = &mut prev_node.next[next_index];\n        }\n    }\n}\n\npub fn trie_free_list_pop<T>(list: &mut Option<Box<TrieNode<T>>>) -> Option<Box<TrieNode<T>>> {\n    if let Some(mut result) = list.take() {\n        *list = result.next[0].take();\n        Some(result)\n    } else {\n        None\n    }\n}\n\npub fn trie_new<T>() -> Option<Trie<T>> {\n    let mut new_trie = Trie {\n        root_node: None,\n    };\n\n    Some(new_trie)\n}\n\npub fn trie_free_list_push<T>(list: &mut Option<Box<TrieNode<T>>>, mut node: Box<TrieNode<T>>) {\n    node.data = None;\n    *list = Some(node);\n}\n\npub const LONG_STRING_LEN: usize = 4096;\npub const TRIE_NULL: Option<Box<TrieNode<String>>> = None;\n\npub fn test_trie_free_long() {\n    let mut long_string = vec!['A'; LONG_STRING_LEN - 1];\n    long_string.push('\\0');\n\n    let mut trie = trie_new::<String>().unwrap();\n    trie_insert(&mut trie, &long_string.iter().collect::<String>(), Box::new(long_string.iter().collect::<String>()));\n\n    trie_free(trie);\n}\n\npub fn trie_insert<T: Clone>(trie: &mut Trie<T>, key: &str, value: Box<T>) -> i32 {\n    let mut rover = &mut trie.root_node;\n    let mut node: Option<Box<TrieNode<T>>>;\n    let mut p = key.bytes();\n\n    if value.is_none() {\n        return 0;\n    }\n\n    if let Some(found_node) = trie_find_end(trie, key) {\n        if found_node.data.is_some() {\n            found_node.data = Some(*value);\n            return 1;\n        }\n    }\n\n    loop {\n        node = rover.take();\n\n        if node.is_none() {\n            let new_node = TrieNode {\n                data: None,\n                use_count: 0,\n                next: [None; 256],\n            };\n            node = Some(Box::new(new_node));\n            *rover = node.clone();\n        }\n\n        let mut node_mut = rover.as_mut().unwrap();\n        node_mut.use_count += 1;\n\n        let c = p.next().unwrap_or(0);\n\n        if c == 0 {\n            node_mut.data = Some(*value);\n            break;\n        }\n\n        rover = &mut node_mut.next[c as usize];\n    }\n\n    1\n}\n\nfn main(){}\n //编译报错信息：error[E0599]: no method named `is_none` found for struct `Box<T>` in the current scope\n   --> ../tmp/temp.rs:122:14\n    |\n122 |     if value.is_none() {\n    |              ^^^^^^^ method not found in `Box<T>`\n\nerror[E0277]: the trait bound `Box<TrieNode<_>>: Copy` is not satisfied\n   --> ../tmp/temp.rs:140:24\n    |\n140 |                 next: [None; 256],\n    |                        ^^^^\n    |                        |\n    |                        the trait `Copy` is not implemented for `Box<TrieNode<_>>`\n    |                        help: create an inline `const` block: `const { None }`\n    |\n",
        "test_trie_remove_binary": "\npub fn trie_lookup_binary<'a, T>(trie: &'a Trie<T>, key: &[u8], key_length: usize) -> Option<&'a T> {\n    let node = trie_find_end_binary(trie, key, key_length);\n\n    if let Some(n) = node {\n        n.data.as_ref()\n    } else {\n        None\n    }\n}\n\npub fn trie_free<T>(trie: Trie<T>) {\n    let mut free_list: Option<Box<TrieNode<T>>> = None;\n\n    if let Some(root_node) = trie.root_node {\n        trie_free_list_push(&mut free_list, root_node);\n    }\n\n    while let Some(mut node) = trie_free_list_pop(&mut free_list) {\n        for i in 0..256 {\n            if let Some(next_node) = node.next[i].take() {\n                trie_free_list_push(&mut free_list, next_node);\n            }\n        }\n    }\n}\n\nuse std::clone::Clone;\n\npub struct TrieNode<T> {\n    pub data: Option<T>,\n    pub use_count: u32,\n    pub next: [Option<Box<TrieNode<T>>>; 256],\n}\n\nimpl<T: Clone> Clone for TrieNode<T> {\n    fn clone(&self) -> Self {\n        TrieNode {\n            data: self.data.clone(),\n            use_count: self.use_count,\n            next: self.next.clone(),\n        }\n    }\n}\n\npub struct Trie<T> {\n    pub root_node: Option<Box<TrieNode<T>>>,\n}\n\npub const bin_key4: [u8; 4] = [ b'z', 0, b'z', b'z' ];\npub const bin_key2: [u8; 8] = [ b'a', b'b', b'c', 0, 1, 2, 0xff, 0 ];\npub const bin_key3: [u8; 3] = [ b'a', b'b', b'c' ];\npub const bin_key: [u8; 7] = [ b'a', b'b', b'c', 0, 1, 2, 0xff ];\n\npub fn trie_insert_rollback<T: Clone>(trie: &mut Trie<T>, key: &[u8]) {\n    let mut node = trie.root_node.take();\n    let mut prev_ptr = &mut trie.root_node;\n    let mut p = key.iter();\n\n    while let Some(mut current_node) = node {\n        let next_index = *p.next().unwrap_or(&0) as usize;\n        let next_node = current_node.next[next_index].take();\n\n        current_node.use_count -= 1;\n\n        if current_node.use_count == 0 {\n            *prev_ptr = None;\n        } else {\n            *prev_ptr = Some(current_node);\n        }\n\n        node = next_node;\n        if let Some(ref mut prev_node) = *prev_ptr {\n            prev_ptr = &mut prev_node.next[next_index];\n        }\n    }\n}\n\npub fn trie_free_list_pop<T>(list: &mut Option<Box<TrieNode<T>>>) -> Option<Box<TrieNode<T>>> {\n    if let Some(mut result) = list.take() {\n        *list = result.next[0].take();\n        Some(result)\n    } else {\n        None\n    }\n}\n\npub fn trie_insert_binary<T: Clone>(trie: &mut Trie<T>, key: &[u8], key_length: usize, value: Option<T>) -> i32 {\n    if value.is_none() {\n        return 0;\n    }\n\n    if let Some(node) = trie_find_end_binary(trie, key, key_length) {\n        if node.data.is_some() {\n            let mut node_mut = node.clone();\n            node_mut.data = value;\n            return 1;\n        }\n    }\n\n    let mut rover = &mut trie.root_node;\n    let mut p = 0;\n\n    while p <= key_length {\n        let node = rover.take();\n\n        let mut new_node = match node {\n            Some(n) => n,\n            None => {\n                let new_node = TrieNode {\n                    data: None,\n                    use_count: 0,\n                    next: [(); 256].map(|_| None),\n                };\n                Box::new(new_node)\n            }\n        };\n\n        new_node.use_count += 1;\n\n        if p == key_length {\n            new_node.data = value;\n            *rover = Some(new_node);\n            break;\n        }\n\n        let c = key[p] as usize;\n        let next_node = new_node.next[c].take();\n        *rover = Some(new_node);\n        rover = &mut (*rover).as_mut().unwrap().next[c];\n        *rover = next_node;\n        p += 1;\n    }\n\n    1\n}\n\npub fn generate_binary_trie() -> Option<Trie<String>> {\n    let mut new_trie = trie_new::<String>().unwrap();\n\n    /* Insert some values */\n    assert!(trie_insert_binary(&mut new_trie, &bin_key2, bin_key2.len(), Some(\"goodbye world\".to_string())) != 0);\n    assert!(trie_insert_binary(&mut new_trie, &bin_key, bin_key.len(), Some(\"hello world\".to_string())) != 0);\n\n    Some(new_trie)\n}\n\npub fn trie_find_end_binary<'a, T>(trie: &'a Trie<T>, key: &[u8], key_length: usize) -> Option<&'a TrieNode<T>> {\n    let mut node = trie.root_node.as_ref();\n\n    for j in 0..key_length {\n        if node.is_none() {\n            return None;\n        }\n\n        let c = key[j] as usize;\n\n        node = node.and_then(|n| n.next[c].as_ref());\n    }\n\n    node.map(|n| &**n)\n}\n\npub fn trie_new<T>() -> Option<Trie<T>> {\n    let new_trie = Trie {\n        root_node: None,\n    };\n\n    Some(new_trie)\n}\n\npub fn trie_free_list_push<T>(list: &mut Option<Box<TrieNode<T>>>, mut node: Box<TrieNode<T>>) {\n    node.data = None;\n    *list = Some(node);\n}\n\npub fn test_trie_remove_binary() {\n    let mut trie = generate_binary_trie().unwrap();\n\n    /* Test look up and remove of invalid values */\n\n    let value = trie_lookup_binary(&trie, &bin_key3, bin_key3.len());\n    assert!(value.is_none());\n\n    assert!(trie_remove_binary(&mut trie, &bin_key3, bin_key3.len()) == 0);\n\n    assert!(trie_lookup_binary(&trie, &bin_key4, bin_key4.len()).is_none());\n    assert!(trie_remove_binary(&mut trie, &bin_key4, bin_key4.len()) == 0);\n\n    /* Remove the two values */\n\n    assert!(trie_remove_binary(&mut trie, &bin_key2, bin_key2.len()) != 0);\n    assert!(trie_lookup_binary(&trie, &bin_key2, bin_key2.len()).is_none());\n    assert!(trie_lookup_binary(&trie, &bin_key, bin_key.len()).is_some());\n\n    assert!(trie_remove_binary(&mut trie, &bin_key, bin_key.len()) != 0);\n    assert!(trie_lookup_binary(&trie, &bin_key, bin_key.len()).is_none());\n\n    trie_free(trie);\n}\n\npub fn trie_remove_binary<T: Clone>(trie: &mut Trie<T>, key: &[u8], key_length: usize) -> i32 {\n    let node = trie_find_end_binary(trie, key, key_length);\n\n    if let Some(mut n) = node {\n        n.data = None;\n    } else {\n        return 0;\n    }\n\n    /* Now traverse the tree again as before, decrementing the use\n     * count of each node.  Free back nodes as necessary. */\n\n    let mut node = trie.root_node.take();\n    let mut last_next_ptr = &mut trie.root_node;\n    let mut p = 0;\n\n    while let Some(mut current_node) = node {\n        let c = key[p] as usize;\n        let next = current_node.next[c].take();\n\n        current_node.use_count -= 1;\n\n        if current_node.use_count <= 0 {\n            *last_next_ptr = None;\n            last_next_ptr = &mut *last_next_ptr;\n        } else {\n            *last_next_ptr = Some(current_node);\n        }\n\n        if p == key_length {\n            break;\n        } else {\n            p += 1;\n        }\n\n        if last_next_ptr.is_some() {\n            last_next_ptr = &mut last_next_ptr.as_mut().unwrap().next[c];\n        }\n\n        node = next;\n    }\n\n    1\n}\n\nfn main(){}\n\n //编译报错信息：warning: variable does not need to be mutable\n   --> ../tmp/temp.rs:205:17\n    |\n205 |     if let Some(mut n) = node {\n    |                 ----^\n    |                 |\n    |                 help: remove this `mut`\n    |\n",
        "test_trie_remove": "pub fn trie_num_entries<T>(trie: &Trie<T>) -> u32 {\n    if let Some(root_node) = &trie.root_node {\n        root_node.use_count\n    } else {\n        0\n    }\n}\n\npub fn trie_free<T>(trie: Trie<T>) {\n    let mut free_list: Option<Box<TrieNode<T>>> = None;\n\n    if let Some(root_node) = trie.root_node {\n        trie_free_list_push(&mut free_list, root_node);\n    }\n\n    while let Some(mut node) = trie_free_list_pop(&mut free_list) {\n        for i in 0..256 {\n            if let Some(next_node) = node.next[i].take() {\n                trie_free_list_push(&mut free_list, next_node);\n            }\n        }\n    }\n}\n\npub fn trie_find_end<'a, T>(trie: &'a Trie<T>, key: &str) -> Option<&'a Box<TrieNode<T>>> {\n    let mut node = trie.root_node.as_ref();\n\n    for c in key.bytes() {\n        if let Some(n) = node {\n            node = n.next[c as usize].as_ref();\n        } else {\n            return None;\n        }\n    }\n\n    node\n}\n\nuse std::clone::Clone;\n\npub struct TrieNode<T> {\n    pub data: Option<T>,\n    pub use_count: u32,\n    pub next: [Option<Box<TrieNode<T>>>; 256],\n}\n\nimpl<T: Clone> Clone for TrieNode<T> {\n    fn clone(&self) -> Self {\n        TrieNode {\n            data: self.data.clone(),\n            use_count: self.use_count,\n            next: self.next.clone(),\n        }\n    }\n}\n\npub struct Trie<T> {\n    pub root_node: Option<Box<TrieNode<T>>>,\n}\n\npub const bin_key4: [u8; 4] = [ b'z', 0, b'z', b'z' ];\npub const bin_key2: [u8; 8] = [ b'a', b'b', b'c', 0, 1, 2, 0xff, 0 ];\npub const bin_key3: [u8; 3] = [ b'a', b'b', b'c' ];\npub const bin_key: [u8; 7] = [ b'a', b'b', b'c', 0, 1, 2, 0xff ];\npub fn trie_insert_rollback<T: Clone>(trie: &mut Trie<T>, key: &[u8]) {\n    let mut node = trie.root_node.take();\n    let mut prev_ptr = &mut trie.root_node;\n    let mut p = key.iter();\n\n    while let Some(mut current_node) = node {\n        let next_index = *p.next().unwrap_or(&0) as usize;\n        let next_node = current_node.next[next_index].take();\n\n        current_node.use_count -= 1;\n\n        if current_node.use_count == 0 {\n            *prev_ptr = None;\n        } else {\n            *prev_ptr = Some(current_node);\n        }\n\n        node = next_node;\n        if let Some(ref mut prev_node) = *prev_ptr {\n            prev_ptr = &mut prev_node.next[next_index];\n        }\n    }\n}\n\npub fn trie_free_list_pop<T>(list: &mut Option<Box<TrieNode<T>>>) -> Option<Box<TrieNode<T>>> {\n    if let Some(mut result) = list.take() {\n        *list = result.next[0].take();\n        Some(result)\n    } else {\n        None\n    }\n}\n\npub fn trie_remove<T>(trie: &mut Trie<T>, key: &str) -> bool {\n    let node = trie_find_end(trie, key);\n\n    if let Some(node) = node {\n        if node.data.is_some() {\n            if let Some(mut node_mut) = trie.root_node.as_deref_mut() {\n                let mut current = &mut *node_mut;\n                for c in key.bytes() {\n                    current = current.next[c as usize].as_deref_mut().unwrap();\n                }\n                current.data = None;\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    } else {\n        return false;\n    }\n\n    let mut node = &mut trie.root_node;\n    let mut last_next_ptr: *mut Option<Box<TrieNode<T>>> = std::ptr::null_mut();\n    let mut p = key.as_bytes().iter();\n\n    while let Some(&c) = p.next() {\n        if let Some(n) = node.as_deref_mut() {\n            n.use_count -= 1;\n\n            if n.use_count <= 0 {\n                if !last_next_ptr.is_null() {\n                    unsafe {\n                        *last_next_ptr = None;\n                    }\n                }\n                break;\n            }\n\n            last_next_ptr = &mut n.next[c as usize];\n            node = &mut n.next[c as usize];\n        } else {\n            break;\n        }\n    }\n\n    true\n}\n\npub fn trie_new<T>() -> Option<Trie<T>> {\n    let mut new_trie = Trie {\n        root_node: None,\n    };\n\n    Some(new_trie)\n}\n\npub fn trie_free_list_push<T>(list: &mut Option<Box<TrieNode<T>>>, mut node: Box<TrieNode<T>>) {\n    node.data = None;\n    *list = Some(node);\n}\n\npub fn test_trie_remove() {\n    let mut trie = generate_trie();\n    let mut entries = trie_num_entries(&trie);\n\n    assert_eq!(entries, NUM_TEST_VALUES as u32);\n\n    assert_eq!(trie_remove(&mut trie, \"000000000000000\"), false);\n    assert_eq!(trie_remove(&mut trie, \"\"), false);\n\n    assert_eq!(entries, NUM_TEST_VALUES as u32);\n\n    for i in 0..NUM_TEST_VALUES {\n        let mut buf = String::new();\n        buf.push_str(&i.to_string());\n\n        assert_eq!(trie_remove(&mut trie, &buf), true);\n        entries -= 1;\n        assert_eq!(trie_num_entries(&trie), entries as u32);\n    }\n\n    trie_free(trie);\n}\n\npub fn generate_trie() -> Trie<i32> {\n    let mut trie = trie_new().unwrap();\n    let mut entries = 0;\n\n    for i in 0..NUM_TEST_VALUES {\n        unsafe {\n            test_array[i] = i;\n            test_strings[i] = i.to_string();\n        }\n\n        assert_eq!(trie_insert(&mut trie, &unsafe { test_strings[i] }, unsafe { test_array[i] }), true);\n\n        entries += 1;\n\n        assert_eq!(trie_num_entries(&trie), entries as u32);\n    }\n\n    trie\n}\n\npub fn trie_insert<T: Clone>(trie: &mut Trie<T>, key: &str, value: T) -> bool {\n    let mut rover = &mut trie.root_node;\n    let mut p = key.chars();\n\n    if value == TRIE_NULL {\n        return false;\n    }\n\n    let node = trie_find_end(trie, key);\n\n    if let Some(n) = node {\n        if n.data.is_some() {\n            let mut node_mut = n.as_ref().borrow_mut();\n            node_mut.data = Some(value);\n            return true;\n        }\n    }\n\n    while let Some(c) = p.next() {\n        let index = c as usize;\n\n        if let Some(ref mut node) = rover {\n            node.use_count += 1;\n        } else {\n            let new_node = Box::new(TrieNode {\n                data: None,\n                use_count: 1,\n                next: Default::default(),\n            });\n            *rover = Some(new_node);\n        }\n\n        rover = &mut rover.as_mut().unwrap().next[index];\n    }\n\n    if let Some(ref mut node) = rover {\n        node.data = Some(value);\n    }\n\n    true\n}\n\npub const NUM_TEST_VALUES: usize = 10000;\npub const TRIE_NULL: Option<i32> = None;\n\npub static mut test_array: [i32; NUM_TEST_VALUES] = [0; NUM_TEST_VALUES];\npub static mut test_strings: [String; NUM_TEST_VALUES] = [const { String::new() }; NUM_TEST_VALUES];\n\nfn main(){}\n //编译报错信息：error[E0308]: mismatched types\n   --> ../tmp/temp.rs:188:29\n    |\n188 |             test_array[i] = i;\n    |             -------------   ^ expected `i32`, found `usize`\n    |             |\n    |             expected due to the type of this binding\n\nerror[E0369]: binary operation `==` cannot be applied to type `T`\n   --> ../tmp/temp.rs:206:14\n    |\n206 |     if value == TRIE_NULL {\n    |        ----- ^^ --------- Option<i32>\n    |        |\n    |        T\n    |\n",
        "test_trie_insert": "pub fn trie_num_entries<T>(trie: &Trie<T>) -> u32 {\n    if let Some(root_node) = &trie.root_node {\n        root_node.use_count\n    } else {\n        0\n    }\n}\n\npub fn trie_free<T>(trie: Trie<T>) {\n    let mut free_list: Option<Box<TrieNode<T>>> = None;\n\n    if let Some(root_node) = trie.root_node {\n        trie_free_list_push(&mut free_list, root_node);\n    }\n\n    while let Some(mut node) = trie_free_list_pop(&mut free_list) {\n        for i in 0..256 {\n            if let Some(next_node) = node.next[i].take() {\n                trie_free_list_push(&mut free_list, next_node);\n            }\n        }\n    }\n}\n\npub fn trie_find_end<'a, T>(trie: &'a Trie<T>, key: &str) -> Option<&'a Box<TrieNode<T>>> {\n    let mut node = trie.root_node.as_ref();\n\n    for c in key.bytes() {\n        if let Some(n) = node {\n            node = n.next[c as usize].as_ref();\n        } else {\n            return None;\n        }\n    }\n\n    node\n}\n\nuse std::clone::Clone;\n\npub struct TrieNode<T> {\n    pub data: Option<T>,\n    pub use_count: u32,\n    pub next: [Option<Box<TrieNode<T>>>; 256],\n}\n\nimpl<T: Clone> Clone for TrieNode<T> {\n    fn clone(&self) -> Self {\n        TrieNode {\n            data: self.data.clone(),\n            use_count: self.use_count,\n            next: self.next.clone(),\n        }\n    }\n}\n\npub struct Trie<T> {\n    pub root_node: Option<Box<TrieNode<T>>>,\n}\n\npub const bin_key4: [u8; 4] = [ b'z', 0, b'z', b'z' ];\npub const bin_key2: [u8; 8] = [ b'a', b'b', b'c', 0, 1, 2, 0xff, 0 ];\npub const bin_key3: [u8; 3] = [ b'a', b'b', b'c' ];\npub const bin_key: [u8; 7] = [ b'a', b'b', b'c', 0, 1, 2, 0xff ];\n\npub fn trie_insert_rollback<T: Clone>(trie: &mut Trie<T>, key: &[u8]) {\n    let mut node = trie.root_node.take();\n    let mut prev_ptr = &mut trie.root_node;\n    let mut p = key.iter();\n\n    while let Some(mut current_node) = node {\n        let next_index = *p.next().unwrap_or(&0) as usize;\n        let next_node = current_node.next[next_index].take();\n\n        current_node.use_count -= 1;\n\n        if current_node.use_count == 0 {\n            *prev_ptr = None;\n        } else {\n            *prev_ptr = Some(current_node);\n        }\n\n        node = next_node;\n        if let Some(ref mut prev_node) = *prev_ptr {\n            prev_ptr = &mut prev_node.next[next_index];\n        }\n    }\n}\n\npub fn trie_free_list_pop<T>(list: &mut Option<Box<TrieNode<T>>>) -> Option<Box<TrieNode<T>>> {\n    if let Some(mut result) = list.take() {\n        *list = result.next[0].take();\n        Some(result)\n    } else {\n        None\n    }\n}\n\npub fn trie_new<T>() -> Option<Trie<T>> {\n    let mut new_trie = Trie {\n        root_node: None,\n    };\n\n    Some(new_trie)\n}\n\npub fn trie_free_list_push<T>(list: &mut Option<Box<TrieNode<T>>>, mut node: Box<TrieNode<T>>) {\n    node.data = None;\n    *list = Some(node);\n}\n\npub fn test_trie_insert() {\n    let mut trie = generate_trie();\n    let entries = trie_num_entries(&trie);\n    assert_eq!(trie_insert(&mut trie, \"hello world\", None), 0);\n    assert_eq!(trie_num_entries(&trie), entries);\n\n    let allocated = 0; // Placeholder for allocated memory check\n    assert_eq!(trie_insert(&mut trie, \"hello world\", Some(Box::new(42_i32))), 1);\n    assert_eq!(allocated, 0); // Placeholder for allocated memory check\n    assert_eq!(trie_num_entries(&trie), entries + 1);\n\n    trie_free(trie);\n}\n\npub fn generate_trie() -> Trie<Box<i32>> {\n    let mut trie = trie_new().unwrap();\n    let mut entries = 0;\n\n    for i in 0..NUM_TEST_VALUES {\n        unsafe {\n            test_array[i] = i;\n            test_strings[i] = format!(\"{}\", i);\n        }\n\n        assert_ne!(trie_insert(&mut trie, &unsafe { test_strings[i] }, Some(Box::new(unsafe { test_array[i] }))), 0);\n\n        entries += 1;\n\n        assert_eq!(trie_num_entries(&trie), entries);\n    }\n\n    trie\n}\n\npub fn trie_insert<T: Clone>(trie: &mut Trie<T>, key: &str, value: Option<Box<T>>) -> i32 {\n    if value.is_none() {\n        return 0;\n    }\n\n    let mut rover = &mut trie.root_node;\n    let mut p = key.bytes();\n\n    loop {\n        let node = rover.as_mut();\n\n        if node.is_none() {\n            *rover = Some(Box::new(TrieNode {\n                data: None,\n                use_count: 0,\n                next: [None; 256],\n            }));\n        }\n\n        let node = rover.as_mut().unwrap();\n\n        node.use_count += 1;\n\n        match p.next() {\n            Some(c) => {\n                rover = &mut node.next[c as usize];\n            }\n            None => {\n                node.data = value;\n                break;\n            }\n        }\n    }\n\n    1\n}\n\npub const NUM_TEST_VALUES: usize = 10000;\npub static mut test_array: [i32; NUM_TEST_VALUES] = [0; NUM_TEST_VALUES];\npub static mut test_strings: [String; NUM_TEST_VALUES] = [const { String::new() }; NUM_TEST_VALUES];\n\nfn main(){}\n //编译报错信息：error[E0308]: mismatched types\n   --> ../tmp/temp.rs:119:68\n    |\n119 |     assert_eq!(trie_insert(&mut trie, \"hello world\", Some(Box::new(42_i32))), 1);\n    |                                                           -------- ^^^^^^ expected `Box<i32>`, found `i32`\n    |                                                           |\n    |                                                           arguments to this function are incorrect\n    |\n",
        "test_trie_new_free": "\npub fn trie_free<T>(trie: Trie<T>) {\n    let mut free_list: Option<Box<TrieNode<T>>> = None;\n\n    if let Some(root_node) = trie.root_node {\n        trie_free_list_push(&mut free_list, root_node);\n    }\n\n    while let Some(mut node) = trie_free_list_pop(&mut free_list) {\n        for i in 0..256 {\n            if let Some(next_node) = node.next[i].take() {\n                trie_free_list_push(&mut free_list, next_node);\n            }\n        }\n    }\n}\n\npub fn trie_find_end<'a, T>(trie: &'a Trie<T>, key: &str) -> Option<&'a Box<TrieNode<T>>> {\n    let mut node = trie.root_node.as_ref();\n\n    for c in key.bytes() {\n        if let Some(n) = node {\n            node = n.next[c as usize].as_ref();\n        } else {\n            return None;\n        }\n    }\n\n    node\n}\n\nuse std::clone::Clone;\n\npub struct TrieNode<T> {\n    pub data: Option<T>,\n    pub use_count: u32,\n    pub next: [Option<Box<TrieNode<T>>>; 256],\n}\n\nimpl<T: Clone> Clone for TrieNode<T> {\n    fn clone(&self) -> Self {\n        TrieNode {\n            data: self.data.clone(),\n            use_count: self.use_count,\n            next: self.next.clone(),\n        }\n    }\n}\n\npub struct Trie<T> {\n    pub root_node: Option<Box<TrieNode<T>>>,\n}\n\npub const bin_key4: [u8; 4] = [ b'z', 0, b'z', b'z' ];\npub const bin_key2: [u8; 8] = [ b'a', b'b', b'c', 0, 1, 2, 0xff, 0 ];\npub const bin_key3: [u8; 3] = [ b'a', b'b', b'c' ];\npub const bin_key: [u8; 7] = [ b'a', b'b', b'c', 0, 1, 2, 0xff ];\npub fn trie_insert_rollback<T: Clone>(trie: &mut Trie<T>, key: &[u8]) {\n    let mut node = trie.root_node.take();\n    let mut prev_ptr = &mut trie.root_node;\n    let mut p = key.iter();\n\n    while let Some(mut current_node) = node {\n        let next_index = *p.next().unwrap_or(&0) as usize;\n        let next_node = current_node.next[next_index].take();\n\n        current_node.use_count -= 1;\n\n        if current_node.use_count == 0 {\n            *prev_ptr = None;\n        } else {\n            *prev_ptr = Some(current_node);\n        }\n\n        node = next_node;\n        if let Some(ref mut prev_node) = *prev_ptr {\n            prev_ptr = &mut prev_node.next[next_index];\n        }\n    }\n}\n\npub fn trie_free_list_pop<T>(list: &mut Option<Box<TrieNode<T>>>) -> Option<Box<TrieNode<T>>> {\n    if let Some(mut result) = list.take() {\n        *list = result.next[0].take();\n        Some(result)\n    } else {\n        None\n    }\n}\n\npub fn trie_remove<T>(trie: &mut Trie<T>, key: &str) -> bool {\n    let node = trie_find_end(trie, key);\n\n    if let Some(node) = node {\n        if node.data.is_some() {\n            if let Some(mut node_mut) = trie.root_node.as_deref_mut() {\n                let mut current = &mut *node_mut;\n                for c in key.bytes() {\n                    current = current.next[c as usize].as_deref_mut().unwrap();\n                }\n                current.data = None;\n            } else {\n                return false;\n            }\n        } else {\n            return false;\n        }\n    } else {\n        return false;\n    }\n\n    let mut node = &mut trie.root_node;\n    let mut last_next_ptr: *mut Option<Box<TrieNode<T>>> = std::ptr::null_mut();\n    let mut p = key.as_bytes().iter();\n\n    while let Some(&c) = p.next() {\n        if let Some(n) = node.as_deref_mut() {\n            n.use_count -= 1;\n\n            if n.use_count <= 0 {\n                if !last_next_ptr.is_null() {\n                    unsafe {\n                        *last_next_ptr = None;\n                    }\n                }\n                break;\n            }\n\n            last_next_ptr = &mut n.next[c as usize];\n            node = &mut n.next[c as usize];\n        } else {\n            break;\n        }\n    }\n\n    true\n}\n\npub fn trie_new<T>() -> Option<Trie<T>> {\n    let mut new_trie = Trie {\n        root_node: None,\n    };\n\n    Some(new_trie)\n}\n\npub fn trie_free_list_push<T>(list: &mut Option<Box<TrieNode<T>>>, mut node: Box<TrieNode<T>>) {\n    node.data = None;\n    *list = Some(node);\n}\n\npub fn test_trie_new_free() {\n    let mut trie = trie_new::<String>();\n\n    assert!(trie.is_some());\n\n    trie_free(trie.unwrap());\n\n    let mut trie = trie_new::<String>();\n\n    assert!(trie_insert(&mut trie.as_mut().unwrap(), \"hello\", String::from(\"there\")));\n    assert!(trie_insert(&mut trie.as_mut().unwrap(), \"hell\", String::from(\"testing\")));\n    assert!(trie_insert(&mut trie.as_mut().unwrap(), \"testing\", String::from(\"testing\")));\n    assert!(trie_insert(&mut trie.as_mut().unwrap(), \"\", String::from(\"asfasf\")));\n\n    trie_free(trie.unwrap());\n\n    let mut trie = trie_new::<String>();\n\n    assert!(trie_insert(&mut trie.as_mut().unwrap(), \"hello\", String::from(\"there\")));\n    assert!(trie_remove(&mut trie.as_mut().unwrap(), \"hello\"));\n\n    trie_free(trie.unwrap());\n}\n\npub fn trie_insert<T: Clone + PartialEq>(trie: &mut Trie<T>, key: &str, value: T) -> bool {\n    let mut rover = &mut trie.root_node;\n    let mut node: Option<&mut Box<TrieNode<T>>>;\n    let mut p = key.chars();\n\n    if value == TRIE_NULL {\n        return false;\n    }\n\n    node = trie_find_end(trie, key).map(|n| &mut **n);\n\n    if let Some(mut n) = node {\n        if n.data.is_some() {\n            n.data = Some(value);\n            return true;\n        }\n    }\n\n    for c in p {\n        node = match rover {\n            Some(n) => &mut n.next[c as usize],\n            None => {\n                let new_node = Box::new(TrieNode {\n                    data: None,\n                    use_count: 0,\n                    next: [None; 256],\n                });\n                *rover = Some(new_node);\n                rover\n            }\n        };\n\n        if let Some(n) = node {\n            n.use_count += 1;\n        } else {\n            trie_insert_rollback(trie, key.as_bytes());\n            return false;\n        }\n\n        if c == '\\0' {\n            if let Some(n) = node {\n                n.data = Some(value);\n            }\n            break;\n        }\n\n        rover = &mut node.as_mut().unwrap().next[c as usize];\n    }\n\n    true\n}\n\npub const TRIE_NULL: Option<String> = None;\n\nfn main(){}\n\n //编译报错信息：error[E0308]: mismatched types\n   --> ../tmp/temp.rs:181:17\n    |\n176 | pub fn trie_insert<T: Clone + PartialEq>(trie: &mut Trie<T>, key: &str, value: T) -> bool {\n    |                    - expected this type parameter\n...\n181 |     if value == TRIE_NULL {\n    |        -----    ^^^^^^^^^ expected type parameter `T`, found `Option<String>`\n    |        |\n    |        expected because this is `T`\n    |\n",
        "test_trie_replace": "pub fn trie_num_entries<T>(trie: &Trie<T>) -> u32 {\n    if let Some(root_node) = &trie.root_node {\n        root_node.use_count\n    } else {\n        0\n    }\n}\n\npub fn trie_free<T>(trie: Trie<T>) {\n    let mut free_list: Option<Box<TrieNode<T>>> = None;\n\n    if let Some(root_node) = trie.root_node {\n        trie_free_list_push(&mut free_list, root_node);\n    }\n\n    while let Some(mut node) = trie_free_list_pop(&mut free_list) {\n        for i in 0..256 {\n            if let Some(next_node) = node.next[i].take() {\n                trie_free_list_push(&mut free_list, next_node);\n            }\n        }\n    }\n}\n\npub fn trie_find_end<'a, T>(trie: &'a Trie<T>, key: &str) -> Option<&'a Box<TrieNode<T>>> {\n    let mut node = trie.root_node.as_ref();\n\n    for c in key.bytes() {\n        if let Some(n) = node {\n            node = n.next[c as usize].as_ref();\n        } else {\n            return None;\n        }\n    }\n\n    node\n}\n\nuse std::clone::Clone;\n\npub struct TrieNode<T> {\n    pub data: Option<T>,\n    pub use_count: u32,\n    pub next: [Option<Box<TrieNode<T>>>; 256],\n}\n\nimpl<T: Clone> Clone for TrieNode<T> {\n    fn clone(&self) -> Self {\n        TrieNode {\n            data: self.data.clone(),\n            use_count: self.use_count,\n            next: self.next.clone(),\n        }\n    }\n}\n\npub struct Trie<T> {\n    pub root_node: Option<Box<TrieNode<T>>>,\n}\n\npub const bin_key4: [u8; 4] = [ b'z', 0, b'z', b'z' ];\npub const bin_key2: [u8; 8] = [ b'a', b'b', b'c', 0, 1, 2, 0xff, 0 ];\npub const bin_key3: [u8; 3] = [ b'a', b'b', b'c' ];\npub const bin_key: [u8; 7] = [ b'a', b'b', b'c', 0, 1, 2, 0xff ];\n\npub fn trie_insert_rollback<T: Clone>(trie: &mut Trie<T>, key: &[u8]) {\n    let mut node = trie.root_node.take();\n    let mut prev_ptr = &mut trie.root_node;\n    let mut p = key.iter();\n\n    while let Some(mut current_node) = node {\n        let next_index = *p.next().unwrap_or(&0) as usize;\n        let next_node = current_node.next[next_index].take();\n\n        current_node.use_count -= 1;\n\n        if current_node.use_count == 0 {\n            *prev_ptr = None;\n        } else {\n            *prev_ptr = Some(current_node);\n        }\n\n        node = next_node;\n        if let Some(ref mut prev_node) = *prev_ptr {\n            prev_ptr = &mut prev_node.next[next_index];\n        }\n    }\n}\n\npub fn trie_free_list_pop<T>(list: &mut Option<Box<TrieNode<T>>>) -> Option<Box<TrieNode<T>>> {\n    if let Some(mut result) = list.take() {\n        *list = result.next[0].take();\n        Some(result)\n    } else {\n        None\n    }\n}\n\npub fn trie_new<T>() -> Option<Trie<T>> {\n    let mut new_trie = Trie {\n        root_node: None,\n    };\n\n    Some(new_trie)\n}\n\npub fn trie_free_list_push<T>(list: &mut Option<Box<TrieNode<T>>>, mut node: Box<TrieNode<T>>) {\n    node.data = None;\n    *list = Some(node);\n}\n\npub fn trie_lookup<'a, T>(trie: &'a Trie<T>, key: &str) -> Option<&'a T> {\n    let node = trie_find_end(trie, key);\n\n    if let Some(n) = node {\n        n.data.as_ref()\n    } else {\n        None\n    }\n}\n\npub fn test_trie_replace() {\n    let mut trie = generate_trie();\n\n    // Test replacing values\n    let mut val = Box::new(999);\n    assert!(trie_insert(&mut trie, \"999\", Some(val.as_mut())));\n    assert_eq!(trie_num_entries(&trie), NUM_TEST_VALUES as u32);\n\n    assert_eq!(trie_lookup(&trie, \"999\"), Some(val.as_ref()));\n    drop(val);\n    trie_free(trie);\n}\n\npub fn generate_trie() -> Trie<i32> {\n    let mut trie = trie_new().unwrap();\n    let mut entries = 0;\n\n    for i in 0..NUM_TEST_VALUES {\n        unsafe {\n            test_array[i] = i;\n            test_strings[i] = format!(\"{}\", i);\n        }\n\n        assert!(trie_insert(&mut trie, &unsafe { test_strings[i] }, Some(unsafe { &mut test_array[i] })));\n        entries += 1;\n\n        assert_eq!(trie_num_entries(&trie), entries as u32);\n    }\n\n    trie\n}\n\npub fn trie_insert<T: Clone>(trie: &mut Trie<T>, key: &str, value: Option<&mut T>) -> bool {\n    if value.is_none() {\n        return false;\n    }\n\n    let mut rover = &mut trie.root_node;\n    let mut p = key.bytes();\n\n    while let Some(c) = p.next() {\n        let node = rover.get_or_insert_with(|| Box::new(TrieNode {\n            data: None,\n            use_count: 0,\n            next: [None; 256],\n        }));\n\n        node.use_count += 1;\n\n        if c == 0 {\n            node.data = value.cloned();\n            break;\n        }\n\n        rover = &mut node.next[c as usize];\n    }\n\n    true\n}\n\npub const NUM_TEST_VALUES: usize = 10000;\npub static mut test_array: [i32; NUM_TEST_VALUES] = [0; NUM_TEST_VALUES];\npub static mut test_strings: [String; NUM_TEST_VALUES] = [const { String::new() }; NUM_TEST_VALUES];\n\nfn main(){}\n //编译报错信息：error[E0308]: mismatched types\n   --> ../tmp/temp.rs:141:29\n    |\n141 |             test_array[i] = i;\n    |             -------------   ^ expected `i32`, found `usize`\n    |             |\n    |             expected due to the type of this binding\n\nerror[E0277]: the trait bound `Box<TrieNode<T>>: Copy` is not satisfied\n   --> ../tmp/temp.rs:166:20\n    |\n166 |             next: [None; 256],\n    |                    ^^^^\n    |                    |\n    |                    the trait `Copy` is not implemented for `Box<TrieNode<T>>`\n    |                    help: create an inline `const` block: `const { None }`\n    |\n"
    },
    "set": {
        "set_remove": "pub fn set_free_entry<T: Clone>(set: &mut Set<T>, entry: Box<SetEntry<T>>) {\n    if let Some(free_func) = set.free_func {\n        free_func(entry.data.clone());\n    }\n}\n\nuse std::vec::Vec;\n\n#[derive(Clone)]\npub struct SetEntry<T: Clone> {\n    pub data: T,\n    pub next: Option<Box<SetEntry<T>>>,\n}\n\n#[derive(Clone)]\npub struct Set<T: Clone> {\n    pub prime_index: usize,\n    pub table_size: usize,\n    pub entries: usize,\n    pub table: Vec<Option<Box<SetEntry<T>>>>,\n    pub hash_func: fn(&T) -> usize,\n    pub equal_func: fn(&T, &T) -> bool,\n    pub free_func: Option<fn(T)>,\n}\n\n#[derive(Clone)]\npub struct SetIterator<T: Clone> {\n    pub set: Option<Set<T>>,\n    pub next_entry: Option<Box<SetEntry<T>>>,\n    pub next_chain: usize,\n}\n\nconst SET_NUM_PRIMES: usize = 24;\nconst SET_PRIMES: [usize; SET_NUM_PRIMES] = [\n    193, 389, 769, 1543, 3079, 6151, 12289, 24593, 49157, 98317, 196613, 393241, 786433, 1572869,\n    3145739, 6291469, 12582917, 25165843, 50331653, 100663319, 201326611, 402653189, 805306457,\n    1610612741,\n];\n\npub fn set_remove<T: Clone>(set: &mut Set<T>, data: T) -> bool {\n    let index = (set.hash_func)(&data) % set.table_size;\n    let mut rover = &mut set.table[index];\n\n    while let Some(mut entry) = rover.take() {\n        if (set.equal_func)(&data, &entry.data) {\n            let next = entry.next.take();\n            set_free_entry(set, entry);\n            *rover = next;\n            set.entries -= 1;\n            return true;\n        } else {\n            *rover = Some(entry);\n            rover = &mut rover.as_mut().unwrap().next;\n        }\n    }\n\n    false\n}\n\nfn main(){}\n //编译报错信息：error[E0499]: cannot borrow `*set` as mutable more than once at a time\n  --> ../tmp/temp.rs:47:28\n   |\n42 |     let mut rover = &mut set.table[index];\n   |                          --------- first mutable borrow occurs here\n...\n47 |             set_free_entry(set, entry);\n   |                            ^^^ second mutable borrow occurs here\n48 |             *rover = next;\n   |             ------ first borrow later used here\n\nerror: aborting due to 1 previous error\n\nFor more information about this error, try `rustc --explain E0499`.\n"
    },
    "test-set": {
        "test_set_new_free": "\npub fn set_allocate_table<T: Clone>(set: &mut Set<T>) -> bool {\n    if set.prime_index < SET_NUM_PRIMES {\n        set.table_size = SET_PRIMES[set.prime_index];\n    } else {\n        set.table_size = set.entries * 10;\n    }\n\n    set.table = vec![None; set.table_size];\n\n    true\n}\n\nuse std::vec::Vec;\nuse std::hash::Hash;\n\n#[derive(Clone)]\npub struct SetEntry<T: Clone + Hash> {\n    pub data: T,\n    pub next: Option<Box<SetEntry<T>>>,\n}\n\n#[derive(Clone)]\npub struct Set<T: Clone + Hash> {\n    pub prime_index: usize,\n    pub table_size: usize,\n    pub entries: usize,\n    pub table: Vec<Option<Box<SetEntry<T>>>>,\n    pub hash_func: fn(&T) -> usize,\n    pub equal_func: fn(&T, &T) -> bool,\n    pub free_func: Option<fn(T)>,\n}\n\n#[derive(Clone)]\npub struct SetIterator<T: Clone + Hash> {\n    pub set: Option<Set<T>>,\n    pub next_entry: Option<Box<SetEntry<T>>>,\n    pub next_chain: usize,\n}\n\nconst SET_NUM_PRIMES: usize = 24;\nconst SET_PRIMES: [usize; SET_NUM_PRIMES] = [\n    193, 389, 769, 1543, 3079, 6151, 12289, 24593, 49157, 98317, 196613, 393241, 786433, 1572869,\n    3145739, 6291469, 12582917, 25165843, 50331653, 100663319, 201326611, 402653189, 805306457,\n    1610612741,\n];\n\nstatic mut ALLOCATED_VALUES: usize = 0;\npub fn set_free<T: Clone + Hash>(set: &mut Set<T>) {\n    let mut rover;\n    let mut next;\n\n    for i in 0..set.table_size {\n        rover = set.table[i].take();\n\n        while let Some(mut entry) = rover {\n            next = entry.next.take();\n            set_free_entry(set, entry);\n            rover = next;\n        }\n    }\n}\n\npub fn set_insert<T: Clone + Hash + Eq>(set: &mut Set<T>, data: T) -> bool {\n    let mut newentry = Box::new(SetEntry {\n        data: data.clone(),\n        next: None,\n    });\n\n    if (set.entries * 3) / set.table_size > 0 {\n        if !set_enlarge(set) {\n            return false;\n        }\n    }\n\n    let index = (set.hash_func)(&data) % set.table_size;\n\n    let mut rover = set.table[index].take();\n\n    while let Some(entry) = rover {\n        if (set.equal_func)(&data, &entry.data) {\n            set.table[index] = Some(entry);\n            return false;\n        }\n        newentry.next = Some(entry);\n        rover = newentry.next.as_ref().unwrap().next.clone();\n    }\n\n    set.table[index] = Some(newentry);\n    set.entries += 1;\n\n    true\n}\n\npub fn set_enlarge<T: Clone + Hash>(set: &mut Set<T>) -> bool {\n    let mut old_table = Vec::new();\n    std::mem::swap(&mut old_table, &mut set.table);\n    let old_table_size = set.table_size;\n    let old_prime_index = set.prime_index;\n\n    set.prime_index += 1;\n\n    if !set_allocate_table(set) {\n        set.table = old_table;\n        set.table_size = old_table_size;\n        set.prime_index = old_prime_index;\n        return false;\n    }\n\n    for i in 0..old_table_size {\n        let mut rover = old_table[i].take();\n        while let Some(mut entry) = rover {\n            let next = entry.next.take();\n            let index = (set.hash_func)(&entry.data) % set.table_size;\n            entry.next = set.table[index].take();\n            set.table[index] = Some(entry);\n            rover = next;\n        }\n    }\n\n    true\n}\n\npub fn set_free_entry<T: Clone + Hash>(set: &mut Set<T>, entry: Box<SetEntry<T>>) {\n    if let Some(free_func) = set.free_func {\n        free_func(entry.data);\n    }\n}\n\npub fn set_register_free_function<T: Clone + Hash>(set: &mut Set<T>, free_func: Option<fn(T)>) {\n    set.free_func = free_func;\n}\n\npub fn set_new<T: Clone + Hash>(hash_func: fn(&T) -> usize, equal_func: fn(&T, &T) -> bool) -> Option<Set<T>> {\n    let mut new_set = Set {\n        prime_index: 0,\n        table_size: 0,\n        entries: 0,\n        table: Vec::new(),\n        hash_func,\n        equal_func,\n        free_func: None,\n    };\n\n    if !set_allocate_table(&mut new_set) {\n        return None;\n    }\n\n    Some(new_set)\n}\n\npub fn test_set_new_free() {\n    let mut set = set_new(int_hash, int_equal);\n    if let Some(ref mut set) = set {\n        set_register_free_function(set, Some(free));\n    }\n\n    assert!(set.is_some());\n\n    for i in 0..10000 {\n        let value = i;\n        set_insert(set.as_mut().unwrap(), value);\n    }\n\n    if let Some(ref mut set) = set {\n        set_free(set);\n    }\n}\n\nfn int_hash(value: &i32) -> usize {\n    value.to_string().hash()\n}\n\nfn int_equal(value1: &i32, value2: &i32) -> bool {\n    value1 == value2\n}\n\nfn free<T>(_value: T) {\n    // Free function implementation\n}\n\nfn main() {}\n\n //编译报错信息：error[E0277]: the trait bound `T: Hash` is not satisfied\n  --> ../tmp/temp.rs:2:47\n   |\n2  | pub fn set_allocate_table<T: Clone>(set: &mut Set<T>) -> bool {\n   |                                               ^^^^^^ the trait `Hash` is not implemented for `T`\n   |\nnote: required by a bound in `Set`\n  --> ../tmp/temp.rs:24:27\n   |\n24 | pub struct Set<T: Clone + Hash> {\n   |                           ^^^^ required by this bound in `Set`\n",
        "test_set_remove": "\npub fn set_allocate_table<T: Clone>(set: &mut Set<T>) -> bool {\n    if set.prime_index < SET_NUM_PRIMES {\n        set.table_size = SET_PRIMES[set.prime_index];\n    } else {\n        set.table_size = set.entries * 10;\n    }\n\n    set.table = vec![None; set.table_size];\n\n    true\n}\n\nuse std::vec::Vec;\n\n#[derive(Clone)]\npub struct SetEntry<T: Clone> {\n    pub data: T,\n    pub next: Option<Box<SetEntry<T>>>,\n}\n\n#[derive(Clone)]\npub struct Set<T: Clone> {\n    pub prime_index: usize,\n    pub table_size: usize,\n    pub entries: usize,\n    pub table: Vec<Option<Box<SetEntry<T>>>>,\n    pub hash_func: fn(&T) -> usize,\n    pub equal_func: fn(&T, &T) -> bool,\n    pub free_func: Option<fn(T)>,\n}\n\n#[derive(Clone)]\npub struct SetIterator<T: Clone> {\n    pub set: Option<Set<T>>,\n    pub next_entry: Option<Box<SetEntry<T>>>,\n    pub next_chain: usize,\n}\n\nconst SET_NUM_PRIMES: usize = 24;\nconst SET_PRIMES: [usize; SET_NUM_PRIMES] = [\n    193, 389, 769, 1543, 3079, 6151, 12289, 24593, 49157, 98317, 196613, 393241, 786433, 1572869,\n    3145739, 6291469, 12582917, 25165843, 50331653, 100663319, 201326611, 402653189, 805306457,\n    1610612741,\n];\n\nstatic mut ALLOCATED_VALUES: usize = 0;\npub fn set_free<T: Clone>(set: &mut Set<T>) {\n    let mut rover;\n    let mut next;\n\n    /* Free all entries in all chains */\n\n    for i in 0..set.table_size {\n        rover = set.table[i].take();\n\n        while let Some(mut entry) = rover {\n            next = entry.next.take();\n\n            /* Free this entry */\n\n            set_free_entry(set, entry);\n\n            /* Advance to the next entry in the chain */\n\n            rover = next;\n        }\n    }\n\n    /* Free the set structure */\n}\n\npub fn set_query<T: Clone>(set: &Set<T>, data: T) -> i32 {\n    let index = (set.hash_func)(&data) % set.table_size;\n    let mut rover = set.table[index].as_ref();\n\n    while let Some(entry) = rover {\n        if (set.equal_func)(&data, &entry.data) {\n            return 1;\n        }\n        rover = entry.next.as_ref();\n    }\n\n    0\n}\n\npub fn set_insert<T: Clone + Eq>(set: &mut Set<T>, data: T) -> bool {\n    let mut newentry = Box::new(SetEntry {\n        data: data.clone(),\n        next: None,\n    });\n\n    if (set.entries * 3) / set.table_size > 0 {\n        if !set_enlarge(set) {\n            return false;\n        }\n    }\n\n    let index = (set.hash_func)(&data) % set.table_size;\n\n    let mut rover = set.table[index].take();\n\n    while let Some(entry) = rover {\n        if (set.equal_func)(&data, &entry.data) {\n            set.table[index] = Some(entry);\n            return false;\n        }\n        newentry.next = Some(entry);\n        rover = newentry.next.as_ref().unwrap().next.clone();\n    }\n\n    set.table[index] = Some(newentry);\n    set.entries += 1;\n\n    true\n}\n\npub fn set_enlarge<T: Clone>(set: &mut Set<T>) -> bool {\n    let mut old_table = Vec::new();\n    std::mem::swap(&mut old_table, &mut set.table);\n    let old_table_size = set.table_size;\n    let old_prime_index = set.prime_index;\n\n    set.prime_index += 1;\n\n    if !set_allocate_table(set) {\n        set.table = old_table;\n        set.table_size = old_table_size;\n        set.prime_index = old_prime_index;\n\n        return false;\n    }\n\n    for i in 0..old_table_size {\n        let mut rover = old_table[i].take();\n        while let Some(mut entry) = rover {\n            let next = entry.next.take();\n            let index = (set.hash_func)(&entry.data) % set.table_size;\n            entry.next = set.table[index].take();\n            set.table[index] = Some(entry);\n            rover = next;\n        }\n    }\n\n    true\n}\n\npub fn set_num_entries<T: Clone>(set: &Set<T>) -> usize {\n    set.entries\n}\n\npub fn set_free_entry<T: Clone>(set: &mut Set<T>, entry: Box<SetEntry<T>>) {\n    if let Some(free_func) = set.free_func {\n        free_func(entry.data);\n    }\n}\n\nfn string_hash(data: &String) -> usize {\n    use std::collections::hash_map::DefaultHasher;\n    use std::hash::{Hash, Hasher};\n\n    let mut hasher = DefaultHasher::new();\n    data.hash(&mut hasher);\n    hasher.finish() as usize\n}\n\nfn string_equal(a: &String, b: &String) -> bool {\n    a == b\n}\n\nfn free(_data: String) {}\n\npub fn generate_set() -> Option<Set<String>> {\n    let mut set = match set_new(string_hash, string_equal) {\n        Some(s) => s,\n        None => return None,\n    };\n\n    let mut buf = String::with_capacity(10);\n    let mut value: String;\n\n    for i in 0..10000 {\n        buf.clear();\n        buf.push_str(&i.to_string());\n        value = buf.clone();\n\n        set_insert(&mut set, value);\n\n        assert_eq!(set_num_entries(&set), i + 1);\n    }\n\n    set_register_free_function(&mut set, Some(free));\n\n    Some(set)\n}\n\npub fn set_register_free_function<T: Clone>(set: &mut Set<T>, free_func: Option<fn(T)>) {\n    set.free_func = free_func;\n}\n\npub fn set_new<T: Clone>(hash_func: fn(&T) -> usize, equal_func: fn(&T, &T) -> bool) -> Option<Set<T>> {\n    let mut new_set = Set {\n        prime_index: 0,\n        table_size: 0,\n        entries: 0,\n        table: Vec::new(),\n        hash_func,\n        equal_func,\n        free_func: None,\n    };\n\n    if !set_allocate_table(&mut new_set) {\n        return None;\n    }\n\n    Some(new_set)\n}\n\npub fn test_set_remove() {\n    let mut set = match generate_set() {\n        Some(s) => s,\n        None => return,\n    };\n\n    let mut num_entries = set_num_entries(&set);\n    assert_eq!(num_entries, 10000);\n\n    /* Remove some entries */\n    for i in 4000..6000 {\n        let mut buf = String::with_capacity(10);\n        buf.push_str(&i.to_string());\n\n        /* Check this is in the set */\n        assert_ne!(set_query(&set, buf.clone()), 0);\n\n        /* Remove it */\n        assert_ne!(set_remove(&mut set, buf.clone()), 0);\n\n        /* Check the number of entries decreases */\n        assert_eq!(set_num_entries(&set), num_entries - 1);\n\n        /* Check it is no longer in the set */\n        assert_eq!(set_query(&set, buf), 0);\n\n        num_entries -= 1;\n    }\n\n    /* Try to remove some invalid entries */\n    for i in -1000..-500 {\n        let mut buf = String::with_capacity(10);\n        buf.push_str(&i.to_string());\n\n        assert_eq!(set_remove(&mut set, buf), 0);\n        assert_eq!(set_num_entries(&set), num_entries);\n    }\n\n    for i in 50000..51000 {\n        let mut buf = String::with_capacity(10);\n        buf.push_str(&i.to_string());\n\n        assert_eq!(set_remove(&mut set, buf), 0);\n        assert_eq!(set_num_entries(&set), num_entries);\n    }\n\n    set_free(&mut set);\n}\n\npub fn set_remove<T: Clone + Eq>(set: &mut Set<T>, data: T) -> i32 {\n    let index = (set.hash_func)(&data) % set.table_size;\n\n    let mut rover = &mut set.table[index];\n\n    while let Some(entry) = rover {\n        if (set.equal_func)(&data, &entry.data) {\n            let next = entry.next.clone();\n            set_free_entry(set, entry.take().unwrap());\n            *rover = next;\n\n            set.entries -= 1;\n\n            return 1;\n        }\n\n        rover = &mut entry.next;\n    }\n\n    0\n}\n\nfn main(){}\n\n //编译报错信息：error[E0599]: `&mut Box<SetEntry<T>>` is not an iterator\n   --> ../tmp/temp.rs:276:39\n    |\n17  |   pub struct SetEntry<T: Clone> {\n    |   ----------------------------- doesn't satisfy `SetEntry<T>: Iterator`\n...\n276 |               set_free_entry(set, entry.take().unwrap());\n    |                                         ^^^^ `&mut Box<SetEntry<T>>` is not an iterator\n    |\n",
        "test_set_free_function": "pub fn set_allocate_table<T: Clone>(set: &mut Set<T>) -> bool {\n    if set.prime_index < SET_NUM_PRIMES {\n        set.table_size = SET_PRIMES[set.prime_index];\n    } else {\n        set.table_size = set.entries * 10;\n    }\n\n    set.table = vec![None; set.table_size];\n\n    true\n}\n\npub fn set_free<T: Clone>(set: &mut Set<T>) {\n    let mut rover;\n    let mut next;\n\n    /* Free all entries in all chains */\n\n    for i in 0..set.table_size {\n        rover = set.table[i].take();\n\n        while let Some(mut entry) = rover {\n            next = entry.next.take();\n\n            /* Free this entry */\n\n            set_free_entry(set, entry);\n\n            /* Advance to the next entry in the chain */\n\n            rover = next;\n        }\n    }\n\n    /* Free the set structure */\n}\n\npub fn new_value<T>(value: T) -> Box<T>\nwhere\n    T: Clone,\n{\n    let result = Box::new(value);\n    unsafe {\n        ALLOCATED_VALUES += 1;\n    }\n    result\n}\n\nuse std::vec::Vec;\n\n#[derive(Clone)]\npub struct SetEntry<T: Clone> {\n    pub data: T,\n    pub next: Option<Box<SetEntry<T>>>,\n}\n\n#[derive(Clone)]\npub struct Set<T: Clone> {\n    pub prime_index: usize,\n    pub table_size: usize,\n    pub entries: usize,\n    pub table: Vec<Option<Box<SetEntry<T>>>>,\n    pub hash_func: fn(&T) -> usize,\n    pub equal_func: fn(&T, &T) -> bool,\n    pub free_func: Option<fn(T)>,\n}\n\n#[derive(Clone)]\npub struct SetIterator<T: Clone> {\n    pub set: Option<Set<T>>,\n    pub next_entry: Option<Box<SetEntry<T>>>,\n    pub next_chain: usize,\n}\n\nconst SET_NUM_PRIMES: usize = 24;\nconst SET_PRIMES: [usize; SET_NUM_PRIMES] = [\n    193, 389, 769, 1543, 3079, 6151, 12289, 24593, 49157, 98317, 196613, 393241, 786433, 1572869,\n    3145739, 6291469, 12582917, 25165843, 50331653, 100663319, 201326611, 402653189, 805306457,\n    1610612741,\n];\n\nstatic mut ALLOCATED_VALUES: usize = 0;\npub fn set_enlarge<T: Clone>(set: &mut Set<T>) -> bool {\n    let mut old_table = Vec::new();\n    std::mem::swap(&mut old_table, &mut set.table);\n    let old_table_size = set.table_size;\n    let old_prime_index = set.prime_index;\n\n    set.prime_index += 1;\n\n    if !set_allocate_table(set) {\n        set.table = old_table;\n        set.table_size = old_table_size;\n        set.prime_index = old_prime_index;\n\n        return false;\n    }\n\n    for i in 0..old_table_size {\n        let mut rover = old_table[i].take();\n        while let Some(mut entry) = rover {\n            let next = entry.next.take();\n            let index = (set.hash_func)(&entry.data) % set.table_size;\n            entry.next = set.table[index].take();\n            set.table[index] = Some(entry);\n            rover = next;\n        }\n    }\n\n    true\n}\n\npub fn set_insert<T: Clone + Eq>(set: &mut Set<T>, data: T) -> bool {\n    let newentry = Box::new(SetEntry {\n        data: data.clone(),\n        next: None,\n    });\n\n    if (set.entries * 3) / set.table_size > 0 {\n        if !set_enlarge(set) {\n            return false;\n        }\n    }\n\n    let index = (set.hash_func)(&data) % set.table_size;\n\n    let mut rover = &mut set.table[index];\n\n    while let Some(ref mut entry) = *rover {\n        if (set.equal_func)(&data, &entry.data) {\n            return false;\n        }\n        rover = &mut entry.next;\n    }\n\n    *rover = Some(newentry);\n    set.entries += 1;\n\n    true\n}\n\npub fn set_free_entry<T: Clone>(set: &mut Set<T>, entry: Box<SetEntry<T>>) {\n    if let Some(free_func) = set.free_func {\n        free_func(entry.data);\n    }\n}\n\npub fn set_register_free_function<T: Clone>(set: &mut Set<T>, free_func: Option<fn(T)>) {\n    set.free_func = free_func;\n}\n\npub fn set_new<T: Clone>(hash_func: fn(&T) -> usize, equal_func: fn(&T, &T) -> bool) -> Option<Set<T>> {\n    let mut new_set = Set {\n        prime_index: 0,\n        table_size: 0,\n        entries: 0,\n        table: Vec::new(),\n        hash_func,\n        equal_func,\n        free_func: None,\n    };\n\n    if !set_allocate_table(&mut new_set) {\n        return None;\n    }\n\n    Some(new_set)\n}\n\npub fn test_set_free_function() {\n    let mut set = set_new(int_hash, int_equal).expect(\"Failed to create set\");\n    set_register_free_function(&mut set, Some(free_value));\n\n    unsafe { ALLOCATED_VALUES = 0; }\n\n    for i in 0..1000 {\n        let value = new_value(i);\n        set_insert(&mut set, *value);\n    }\n\n    assert_eq!(unsafe { ALLOCATED_VALUES }, 1000);\n\n    let i = 500;\n    set_remove(&mut set, &i);\n\n    assert_eq!(unsafe { ALLOCATED_VALUES }, 999);\n\n    set_free(&mut set);\n\n    assert_eq!(unsafe { ALLOCATED_VALUES }, 0);\n}\n\npub fn set_remove<T: Clone + Eq>(set: &mut Set<T>, data: &T) -> bool {\n    let index = (set.hash_func)(data) % set.table_size;\n\n    let mut rover = &mut set.table[index];\n\n    while let Some(ref mut entry) = *rover {\n        if (set.equal_func)(data, &entry.data) {\n            let entry = rover.take().unwrap();\n            *rover = entry.next;\n            set.entries -= 1;\n            set_free_entry(set, entry);\n            return true;\n        }\n        rover = &mut entry.next;\n    }\n\n    false\n}\n\nfn int_hash(data: &i32) -> usize {\n    *data as usize\n}\n\nfn int_equal(a: &i32, b: &i32) -> bool {\n    a == b\n}\n\nfn free_value(value: i32) {\n    unsafe {\n        ALLOCATED_VALUES -= 1;\n    }\n}\n\nfn main(){}\n //编译报错信息：error[E0499]: cannot borrow `*rover` as mutable more than once at a time\n   --> ../tmp/temp.rs:200:25\n    |\n198 |     while let Some(ref mut entry) = *rover {\n    |                    ------------- first mutable borrow occurs here\n199 |         if (set.equal_func)(data, &entry.data) {\n200 |             let entry = rover.take().unwrap();\n    |                         ^^^^^\n    |                         |\n    |                         second mutable borrow occurs here\n    |                         first borrow later used here\n\nerror[E0506]: cannot assign to `*rover` because it is borrowed\n   --> ../tmp/temp.rs:201:13\n    |\n198 |     while let Some(ref mut entry) = *rover {\n    |                    ------------- `*rover` is borrowed here\n...\n201 |             *rover = entry.next;\n    |             ^^^^^^\n    |             |\n    |             `*rover` is assigned to here but it was already borrowed\n    |             borrow later used here\n\nerror[E0382]: use of partially moved value: `entry`\n   --> ../tmp/temp.rs:203:33\n    |\n201 |             *rover = entry.next;\n    |                      ---------- value partially moved here\n202 |             set.entries -= 1;\n203 |             set_free_entry(set, entry);\n    |                                 ^^^^^ value used here after partial move\n    |\n",
        "test_set_iterating_remove": "pub fn set_allocate_table<T: Clone>(set: &mut Set<T>) -> bool {\n    if set.prime_index < SET_NUM_PRIMES {\n        set.table_size = SET_PRIMES[set.prime_index];\n    } else {\n        set.table_size = set.entries * 10;\n    }\n\n    set.table = vec![None; set.table_size];\n\n    true\n}\n\nuse std::vec::Vec;\n\n#[derive(Clone)]\npub struct SetEntry<T: Clone> {\n    pub data: T,\n    pub next: Option<Box<SetEntry<T>>>,\n}\n\n#[derive(Clone)]\npub struct Set<T: Clone> {\n    pub prime_index: usize,\n    pub table_size: usize,\n    pub entries: usize,\n    pub table: Vec<Option<Box<SetEntry<T>>>>,\n    pub hash_func: fn(&T) -> usize,\n    pub equal_func: fn(&T, &T) -> bool,\n    pub free_func: Option<fn(T)>,\n}\n\n#[derive(Clone)]\npub struct SetIterator<T: Clone> {\n    pub set: Option<Set<T>>,\n    pub next_entry: Option<Box<SetEntry<T>>>,\n    pub next_chain: usize,\n}\n\nconst SET_NUM_PRIMES: usize = 24;\nconst SET_PRIMES: [usize; SET_NUM_PRIMES] = [\n    193, 389, 769, 1543, 3079, 6151, 12289, 24593, 49157, 98317, 196613, 393241, 786433, 1572869,\n    3145739, 6291469, 12582917, 25165843, 50331653, 100663319, 201326611, 402653189, 805306457,\n    1610612741,\n];\n\nstatic mut ALLOCATED_VALUES: usize = 0;\npub fn set_enlarge<T: Clone>(set: &mut Set<T>) -> bool {\n    let mut old_table = Vec::new();\n    std::mem::swap(&mut old_table, &mut set.table);\n    let old_table_size = set.table_size;\n    let old_prime_index = set.prime_index;\n\n    set.prime_index += 1;\n\n    if !set_allocate_table(set) {\n        set.table = old_table;\n        set.table_size = old_table_size;\n        set.prime_index = old_prime_index;\n\n        return false;\n    }\n\n    for i in 0..old_table_size {\n        let mut rover = old_table[i].take();\n        while let Some(mut entry) = rover {\n            let next = entry.next.take();\n            let index = (set.hash_func)(&entry.data) % set.table_size;\n            entry.next = set.table[index].take();\n            set.table[index] = Some(entry);\n            rover = next;\n        }\n    }\n\n    true\n}\n\npub fn set_insert<T: Clone + Eq>(set: &mut Set<T>, data: T) -> bool {\n    let newentry = Box::new(SetEntry {\n        data: data.clone(),\n        next: None,\n    });\n\n    if (set.entries * 3) / set.table_size > 0 {\n        if !set_enlarge(set) {\n            return false;\n        }\n    }\n\n    let index = (set.hash_func)(&data) % set.table_size;\n\n    let mut rover = &mut set.table[index];\n\n    while let Some(entry) = rover {\n        if (set.equal_func)(&data, &entry.data) {\n            return false;\n        }\n        rover = &mut entry.next;\n    }\n\n    *rover = Some(newentry);\n    set.entries += 1;\n\n    true\n}\n\npub fn set_iterate<T: Clone>(set: &Set<T>, iter: &mut SetIterator<T>) {\n    let mut chain = 0;\n\n    iter.set = Some(set.clone());\n    iter.next_entry = None;\n\n    /* Find the first entry */\n    while chain < set.table_size {\n        /* There is a value at the start of this chain */\n        if let Some(entry) = &set.table[chain] {\n            iter.next_entry = Some(entry.clone());\n            break;\n        }\n        chain += 1;\n    }\n\n    iter.next_chain = chain;\n}\n\npub fn set_free<T: Clone>(set: &mut Set<T>) {\n    let mut rover;\n    let mut next;\n\n    for i in 0..set.table_size {\n        rover = set.table[i].take();\n\n        while let Some(mut entry) = rover {\n            next = entry.next.take();\n\n            set_free_entry(set, entry);\n\n            rover = next;\n        }\n    }\n}\n\npub fn set_iter_has_more<T: Clone>(iterator: &SetIterator<T>) -> bool {\n    iterator.next_entry.is_some()\n}\n\npub fn set_num_entries<T: Clone>(set: &Set<T>) -> usize {\n    set.entries\n}\n\npub fn set_free_entry<T: Clone>(set: &mut Set<T>, entry: Box<SetEntry<T>>) {\n    if let Some(free_func) = set.free_func {\n        free_func(entry.data);\n    }\n}\n\npub fn generate_set() -> Option<Set<String>> {\n    let mut set = match set_new(string_hash, string_equal) {\n        Some(s) => s,\n        None => return None,\n    };\n\n    let mut buf = String::with_capacity(10);\n    let mut value: String;\n\n    for i in 0..10000 {\n        buf.clear();\n        buf.push_str(&i.to_string());\n        value = buf.clone();\n\n        set_insert(&mut set, value);\n\n        assert_eq!(set_num_entries(&set), i + 1);\n    }\n\n    set_register_free_function(&mut set, Some(free));\n\n    Some(set)\n}\n\npub fn set_register_free_function<T: Clone>(set: &mut Set<T>, free_func: Option<fn(T)>) {\n    set.free_func = free_func;\n}\n\npub fn set_iter_next<T: Clone>(iterator: &mut SetIterator<T>) -> Option<T> {\n    let set = iterator.set.as_ref()?;\n    let current_entry = iterator.next_entry.take()?;\n\n    let result = Some(current_entry.data.clone());\n\n    if let Some(next_entry) = current_entry.next {\n        iterator.next_entry = Some(next_entry);\n    } else {\n        let mut chain = iterator.next_chain + 1;\n\n        while chain < set.table_size {\n            if let Some(entry) = &set.table[chain] {\n                iterator.next_entry = Some(entry.clone());\n                break;\n            }\n            chain += 1;\n        }\n\n        iterator.next_chain = chain;\n    }\n\n    result\n}\n\npub fn set_new<T: Clone>(hash_func: fn(&T) -> usize, equal_func: fn(&T, &T) -> bool) -> Option<Set<T>> {\n    let mut new_set = Set {\n        prime_index: 0,\n        table_size: 0,\n        entries: 0,\n        table: Vec::new(),\n        hash_func,\n        equal_func,\n        free_func: None,\n    };\n\n    if !set_allocate_table(&mut new_set) {\n        return None;\n    }\n\n    Some(new_set)\n}\n\nfn string_hash(s: &String) -> usize {\n    use std::collections::hash_map::DefaultHasher;\n    use std::hash::{Hash, Hasher};\n\n    let mut hasher = DefaultHasher::new();\n    s.hash(&mut hasher);\n    hasher.finish() as usize\n}\n\nfn string_equal(a: &String, b: &String) -> bool {\n    a == b\n}\n\nfn free(_s: String) {}\n\npub fn test_set_iterating_remove() {\n    let mut set = generate_set().unwrap();\n    let mut iterator = SetIterator { set: None, next_entry: None, next_chain: 0 };\n    let mut count = 0;\n    let mut removed = 0;\n\n    set_iterate(&set, &mut iterator);\n\n    while set_iter_has_more(&iterator) {\n        if let Some(value) = set_iter_next(&mut iterator) {\n            if value.parse::<i32>().unwrap() % 100 == 0 {\n                set_remove(&mut set, value);\n                removed += 1;\n            }\n            count += 1;\n        }\n    }\n\n    assert_eq!(count, 10000);\n    assert_eq!(removed, 100);\n    assert_eq!(set_num_entries(&set), 10000 - removed);\n\n    set_free(&mut set);\n}\n\npub fn set_remove<T: Clone + Eq>(set: &mut Set<T>, data: T) -> bool {\n    let index = (set.hash_func)(&data) % set.table_size;\n\n    let mut rover = &mut set.table[index];\n\n    while let Some(entry) = rover {\n        if (set.equal_func)(&data, &entry.data) {\n            let next = entry.next.take();\n            *rover = next;\n            set.entries -= 1;\n            set_free_entry(set, entry);\n            return true;\n        }\n        rover = &mut entry.next;\n    }\n\n    false\n}\n\nfn main(){}\n //编译报错信息：error[E0308]: mismatched types\n   --> ../tmp/temp.rs:277:33\n    |\n277 |             set_free_entry(set, entry);\n    |             --------------      ^^^^^ expected `Box<SetEntry<T>>`, found `&mut Box<SetEntry<T>>`\n    |             |\n    |             arguments to this function are incorrect\n    |\n"
    },
    "list": {
        "list_sort_internal": "pub type ListValue = *mut ();\npub type ListCompareFunc = fn(ListValue, ListValue) -> i32;\n\n#[derive(Clone)]\npub struct ListEntry {\n    pub data: ListValue,\n    pub prev: Option<Box<ListEntry>>,\n    pub next: Option<Box<ListEntry>>,\n}\n\npub fn list_sort_internal(list: &mut Option<Box<ListEntry>>, compare_func: ListCompareFunc) -> Option<Box<ListEntry>> {\n    if list.is_none() {\n        return None;\n    }\n\n    let list = list.as_mut().unwrap();\n\n    if list.next.is_none() {\n        return Some(list.clone());\n    }\n\n    let pivot = list.clone();\n    let mut less_list: Option<Box<ListEntry>> = None;\n    let mut more_list: Option<Box<ListEntry>> = None;\n    let mut rover = list.next.take();\n\n    while let Some(mut rover_node) = rover {\n        rover = rover_node.next.take();\n\n        if compare_func(rover_node.data, pivot.data) < 0 {\n            rover_node.prev = None;\n            rover_node.next = less_list.take();\n            if let Some(less) = &mut rover_node.next {\n                less.prev = Some(rover_node.clone());\n            }\n            less_list = Some(rover_node);\n        } else {\n            rover_node.prev = None;\n            rover_node.next = more_list.take();\n            if let Some(more) = &mut rover_node.next {\n                more.prev = Some(rover_node.clone());\n            }\n            more_list = Some(rover_node);\n        }\n    }\n\n    let less_list_end = list_sort_internal(&mut less_list, compare_func);\n    let more_list_end = list_sort_internal(&mut more_list, compare_func);\n\n    if let Some(less_list_node) = less_list.take() {\n        *list = less_list_node;\n    }\n\n    let mut pivot = pivot;\n    pivot.prev = None;\n    *list = pivot.clone();\n\n    if let Some(mut less_list_end) = less_list_end {\n        pivot.prev = Some(less_list_end.clone());\n        less_list_end.next = Some(pivot.clone());\n    }\n\n    let mut more_list_clone = more_list.clone();\n    pivot.next = more_list_clone.take();\n    if let Some(more) = &mut more_list_clone {\n        more.prev = Some(pivot.clone());\n    }\n\n    if more_list.is_none() {\n        Some(pivot)\n    } else {\n        more_list_end\n    }\n}\n\nfn main(){}\n //编译报错信息：error[E0502]: cannot borrow `rover_node` as immutable because it is also borrowed as mutable\n  --> ../tmp/temp.rs:34:34\n   |\n33 |             if let Some(less) = &mut rover_node.next {\n   |                                 -------------------- mutable borrow occurs here\n34 |                 less.prev = Some(rover_node.clone());\n   |                 ---------        ^^^^^^^^^^ immutable borrow occurs here\n   |                 |\n   |                 mutable borrow later used here\n\nerror[E0502]: cannot borrow `rover_node` as immutable because it is also borrowed as mutable\n  --> ../tmp/temp.rs:41:34\n   |\n40 |             if let Some(more) = &mut rover_node.next {\n   |                                 -------------------- mutable borrow occurs here\n41 |                 more.prev = Some(rover_node.clone());\n   |                 ---------        ^^^^^^^^^^ immutable borrow occurs here\n   |                 |\n   |                 mutable borrow later used here\n\nerror: aborting due to 2 previous errors\n\nFor more information about this error, try `rustc --explain E0502`.\n",
        "list_remove_data": "use std::cell::RefCell;\nuse std::rc::Rc;\nuse std::any::Any;\n\npub type ListValue = Rc<dyn Any>;\npub type ListEqualFunc = fn(Rc<dyn Any>, Rc<dyn Any>) -> bool;\n\n#[derive(Clone)]\npub struct ListEntry {\n    pub data: ListValue,\n    pub prev: Option<Rc<RefCell<ListEntry>>>,\n    pub next: Option<Rc<RefCell<ListEntry>>>,\n}\n\npub fn list_remove_data(list: &mut Option<Rc<RefCell<ListEntry>>>, callback: ListEqualFunc, data: ListValue) -> usize {\n    let mut entries_removed = 0;\n    let mut rover = list.clone();\n\n    while let Some(entry) = rover {\n        let mut entry_borrow = entry.borrow_mut();\n        let next = entry_borrow.next.clone();\n\n        if callback(entry_borrow.data.clone(), data.clone()) {\n            if let Some(prev) = &entry_borrow.prev {\n                prev.borrow_mut().next = entry_borrow.next.clone();\n            } else {\n                *list = entry_borrow.next.clone();\n            }\n\n            if let Some(next) = &entry_borrow.next {\n                next.borrow_mut().prev = entry_borrow.prev.clone();\n            }\n\n            entries_removed += 1;\n        }\n\n        rover = next;\n    }\n\n    entries_removed\n}\n\nfn main(){}\n //编译报错信息：",
        "list_iterate": "use std::cell::RefCell;\nuse std::rc::Rc;\nuse std::any::Any;\n\npub type ListValue<T> = Rc<RefCell<T>>;\npub type ListEqualFunc<T> = fn(ListValue<T>, ListValue<T>) -> bool;\npub type ListCompareFunc<T> = fn(ListValue<T>, ListValue<T>) -> i32;\n\npub struct ListEntry<T> {\n    pub data: ListValue<T>,\n    pub prev: Option<Rc<RefCell<ListEntry<T>>>>,\n    pub next: Option<Rc<RefCell<ListEntry<T>>>>,\n}\n\npub struct ListIterator<T> {\n    pub prev_next: Option<Rc<RefCell<ListEntry<T>>>>,\n    pub current: Option<Rc<RefCell<ListEntry<T>>>>,\n}\n\npub fn list_iterate<T>(list: &mut Option<Rc<RefCell<ListEntry<T>>>>, iter: &mut ListIterator<T>) {\n    iter.prev_next = list.clone();\n    iter.current = None;\n}\n\nfn main(){}\n //编译报错信息：",
        "list_iter_has_more": "use std::cell::RefCell;\nuse std::rc::Rc;\n\npub type ListValue<T> = Rc<RefCell<T>>;\npub type ListEqualFunc<T> = fn(ListValue<T>, ListValue<T>) -> bool;\npub type ListCompareFunc<T> = fn(ListValue<T>, ListValue<T>) -> i32;\n\n#[derive(PartialEq)]\npub struct ListEntry<T> {\n    pub data: ListValue<T>,\n    pub prev: Option<Rc<RefCell<ListEntry<T>>>>,\n    pub next: Option<Rc<RefCell<ListEntry<T>>>>,\n}\n\npub struct ListIterator<T> {\n    pub prev_next: Option<Rc<RefCell<ListEntry<T>>>>,\n    pub current: Option<Rc<RefCell<ListEntry<T>>>>,\n}\n\npub fn list_iter_has_more<T>(iter: &ListIterator<T>) -> bool {\n    if iter.current.is_none() || iter.current.as_ref().unwrap().borrow().next.as_ref() != iter.prev_next.as_ref() {\n        return iter.prev_next.is_some();\n    } else {\n        return iter.current.as_ref().unwrap().borrow().next.is_some();\n    }\n}\n\nfn main(){}\n //编译报错信息：error[E0369]: binary operation `!=` cannot be applied to type `Option<&Rc<RefCell<ListEntry<T>>>>`\n  --> ../tmp/temp.rs:21:88\n   |\n21 |     if iter.current.is_none() || iter.current.as_ref().unwrap().borrow().next.as_ref() != iter.prev_next.as_ref() {\n   |                                  ----------------------------------------------------- ^^ ----------------------- Option<&Rc<RefCell<ListEntry<T>>>>\n   |                                  |\n   |                                  Option<&Rc<RefCell<ListEntry<T>>>>\n   |\n",
        "list_iter_next": "use std::cell::RefCell;\nuse std::rc::Rc;\n\npub type ListValue<T> = Rc<RefCell<T>>;\n\n#[derive(PartialEq)]\npub struct ListEntry<T> {\n    pub data: ListValue<T>,\n    pub prev: Option<Rc<RefCell<ListEntry<T>>>>,\n    pub next: Option<Rc<RefCell<ListEntry<T>>>>,\n}\n\npub struct ListIterator<T> {\n    pub prev_next: Option<Rc<RefCell<ListEntry<T>>>>,\n    pub current: Option<Rc<RefCell<ListEntry<T>>>>,\n}\n\npub fn list_iter_next<T: Clone>(iter: &mut ListIterator<T>) -> Option<ListValue<T>> {\n    if iter.current.is_none() || iter.current.as_ref().map(|x| x.as_ptr()) != iter.prev_next.as_ref().map(|x| x.as_ptr()) {\n        iter.current = iter.prev_next.take();\n    } else {\n        let next = iter.current.as_ref()?.borrow().next.clone();\n        iter.prev_next = next.clone();\n        iter.current = next;\n    }\n\n    if iter.current.is_none() {\n        None\n    } else {\n        Some(iter.current.as_ref()?.borrow().data.clone())\n    }\n}\n\nfn main(){}\n //编译报错信息：",
        "list_iter_remove": "use std::cell::RefCell;\nuse std::rc::Rc;\n\npub type ListValue<T> = Rc<RefCell<T>>;\n\npub struct ListEntry<T> {\n    pub data: ListValue<T>,\n    pub prev: Option<Rc<RefCell<ListEntry<T>>>>,\n    pub next: Option<Rc<RefCell<ListEntry<T>>>>,\n}\n\nimpl<T> Clone for ListEntry<T> {\n    fn clone(&self) -> Self {\n        ListEntry {\n            data: self.data.clone(),\n            prev: self.prev.clone(),\n            next: self.next.clone(),\n        }\n    }\n}\n\npub struct ListIterator<T> {\n    pub prev_next: Option<Rc<RefCell<ListEntry<T>>>>,\n    pub current: Option<Rc<RefCell<ListEntry<T>>>>,\n}\n\npub fn list_iter_remove<T>(iter: &mut ListIterator<T>) {\n    if let Some(current) = iter.current.as_ref() {\n        if let Some(prev_next) = iter.prev_next.as_ref() {\n            if Rc::ptr_eq(current, &prev_next) {\n                let next = current.borrow().next.clone();\n                if let Some(next_entry) = next.as_ref() {\n                    next_entry.borrow_mut().prev = current.borrow().prev.clone();\n                }\n                if let Some(prev_next_entry) = iter.prev_next.as_ref() {\n                    prev_next_entry.borrow_mut().next = next.clone();\n                }\n                iter.current = None;\n            }\n        }\n    }\n}\n\nfn main(){}\npub fn list_nth_entry<T>(list: Option<Rc<RefCell<ListEntry<T>>>>, n: usize) -> Option<Rc<RefCell<ListEntry<T>>>> {\n    let entry = list;\n    let mut i = 0;\n\n    let mut current_entry = entry;\n    while i < n {\n        if let Some(e) = current_entry {\n            current_entry = e.borrow().next.clone();\n        } else {\n            return None;\n        }\n        i += 1;\n    }\n\n    current_entry\n}\n\npub fn list_remove_entry<T>(list: &mut Option<Rc<RefCell<ListEntry<T>>>>, entry: &Rc<RefCell<ListEntry<T>>>) -> i32 {\n    if list.is_none() || entry.borrow().prev.is_none() && list.as_ref().unwrap().as_ptr() != entry.as_ptr() {\n        return 0;\n    }\n\n    if entry.borrow().prev.is_none() {\n        *list = entry.borrow().next.clone();\n\n        if let Some(next_entry) = entry.borrow().next.as_ref() {\n            next_entry.borrow_mut().prev = None;\n        }\n    } else {\n        if let Some(prev_entry) = entry.borrow().prev.as_ref() {\n            prev_entry.borrow_mut().next = entry.borrow().next.clone();\n        }\n\n        if let Some(next_entry) = entry.borrow().next.as_ref() {\n            next_entry.borrow_mut().prev = entry.borrow().prev.clone();\n        }\n    }\n\n    1\n}\n\npub fn list_free<T>(list: Option<Rc<RefCell<ListEntry<T>>>>) {\n    let mut entry = list;\n\n    while let Some(current_entry) = entry {\n        let next = current_entry.borrow().next.clone();\n        drop(current_entry);\n        entry = next;\n    }\n}\n\npub fn check_list_integrity<T: PartialEq + std::fmt::Debug>(list: Option<Rc<RefCell<ListEntry<T>>>>) {\n    let mut prev: Option<Rc<RefCell<ListEntry<T>>>> = None;\n    let mut rover = list;\n\n    while let Some(current) = rover {\n        assert_eq!(list_prev(&Some(current.clone())), prev);\n        prev = Some(current.clone());\n        rover = list_next(Some(current));\n    }\n}\n\npub fn list_next<T>(listentry: Option<Rc<RefCell<ListEntry<T>>>>) -> Option<Rc<RefCell<ListEntry<T>>>> {\n    if let Some(entry) = listentry {\n        entry.borrow().next.clone()\n    } else {\n        None\n    }\n}\n\npub fn list_prev<T>(listentry: &Option<Rc<RefCell<ListEntry<T>>>>) -> Option<Rc<RefCell<ListEntry<T>>>> {\n    if let Some(entry) = listentry {\n        entry.borrow().prev.clone()\n    } else {\n        None\n    }\n}\n\npub fn list_length<T>(list: Option<Rc<RefCell<ListEntry<T>>>>) -> usize {\n    let mut length = 0;\n    let mut entry = list;\n\n    while let Some(current_entry) = entry.take() {\n        length += 1;\n        entry = current_entry.borrow().next.clone();\n    }\n\n    length\n}\n //编译报错信息：error[E0369]: binary operation `==` cannot be applied to type `Option<Rc<RefCell<ListEntry<T>>>>`\n   --> ../tmp/temp.rs:101:9\n    |\n101 |         assert_eq!(list_prev(&Some(current.clone())), prev);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |         |\n    |         Option<Rc<RefCell<ListEntry<T>>>>\n    |         Option<Rc<RefCell<ListEntry<T>>>>\n    |\nnote: an implementation of `PartialEq` might be missing for `ListEntry<T>`\n   --> ../tmp/temp.rs:6:1\n    |\n6   | pub struct ListEntry<T> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n",
        "list_nth_data": "\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nstruct ListEntry<T> {\n    data: Rc<RefCell<T>>,\n    next: Option<Rc<RefCell<ListEntry<T>>>>,\n}\n\nimpl<T> Clone for ListEntry<T> {\n    fn clone(&self) -> Self {\n        ListEntry {\n            data: self.data.clone(),\n            next: self.next.clone(),\n        }\n    }\n}\n\npub fn list_nth_entry<T>(list: Option<Rc<RefCell<ListEntry<T>>>>, n: usize) -> Option<Rc<RefCell<ListEntry<T>>>> {\n    let mut current_entry = list;\n    let mut i = 0;\n\n    while i < n {\n        if let Some(e) = current_entry {\n            current_entry = e.borrow().next.clone();\n        } else {\n            return None;\n        }\n        i += 1;\n    }\n\n    current_entry\n}\n\npub fn list_nth_data<T>(list: Option<Rc<RefCell<ListEntry<T>>>>, n: usize) -> Option<Rc<RefCell<T>>> {\n    let entry = list_nth_entry(list, n);\n\n    match entry {\n        Some(e) => Some(e.borrow().data.clone()),\n        None => None,\n    }\n}\n\nfn main(){}\n\npub fn list_append<T>(list: &mut Option<Rc<RefCell<ListEntry<T>>>>, data: Rc<RefCell<T>>) -> Option<Rc<RefCell<ListEntry<T>>>> {\n    if list.is_none() {\n        return None;\n    }\n\n    let newentry = Rc::new(RefCell::new(ListEntry {\n        data,\n        next: None,\n    }));\n\n    if list.as_ref().unwrap().borrow().next.is_none() {\n        list.as_mut().unwrap().borrow_mut().next = Some(Rc::clone(&newentry));\n    } else {\n        let mut rover = list.as_ref().unwrap().clone();\n        while rover.borrow().next.is_some() {\n            let next_rover = rover.borrow().next.as_ref().unwrap().clone();\n            rover = next_rover;\n        }\n        rover.borrow_mut().next = Some(Rc::clone(&newentry));\n    }\n\n    Some(newentry)\n}\n\npub fn list_remove_entry<T>(list: &mut Option<Rc<RefCell<ListEntry<T>>>>, entry: &Rc<RefCell<ListEntry<T>>>) -> i32 {\n    if list.is_none() {\n        return 0;\n    }\n\n    if list.as_ref().unwrap().as_ptr() == entry.as_ptr() {\n        *list = entry.borrow().next.clone();\n    } else {\n        let mut rover = list.as_ref().unwrap().clone();\n        while rover.borrow().next.is_some() {\n            let next_rover = rover.borrow().next.as_ref().unwrap().clone();\n            if next_rover.as_ptr() == entry.as_ptr() {\n                rover.borrow_mut().next = entry.borrow().next.clone();\n                break;\n            }\n            rover = next_rover;\n        }\n    }\n\n    1\n}\n\npub fn list_prev<T>(listentry: &Option<Rc<RefCell<ListEntry<T>>>>) -> Option<Rc<RefCell<ListEntry<T>>>> {\n    None\n}\n\npub fn list_data<T: Clone>(listentry: Option<Rc<RefCell<ListEntry<T>>>>) -> Option<T> {\n    if let Some(entry) = listentry {\n        Some(entry.borrow().data.borrow().clone())\n    } else {\n        None\n    }\n}\n\npub fn list_prepend<T>(list: &mut Option<Rc<RefCell<ListEntry<T>>>>, data: Rc<RefCell<T>>) -> Option<Rc<RefCell<ListEntry<T>>>> {\n    let new_entry = Rc::new(RefCell::new(ListEntry {\n        data,\n        next: list.clone(),\n    }));\n\n    if let Some(old_head) = list.as_ref() {\n        old_head.borrow_mut().next = Some(new_entry.clone());\n    }\n\n    *list = Some(new_entry.clone());\n\n    Some(new_entry)\n}\n\npub fn generate_list() -> Option<Rc<RefCell<ListEntry<&'static i32>>>> {\n    let mut list: Option<Rc<RefCell<ListEntry<&'static i32>>>> = None;\n\n    assert!(list_append(&mut list, &variable1).is_some());\n    assert!(list_append(&mut list, &variable2).is_some());\n    assert!(list_append(&mut list, &variable3).is_some());\n    assert!(list_append(&mut list, &variable4).is_some());\n\n    list\n}\n\n\n //编译报错信息：error[E0425]: cannot find value `variable1` in this scope\n   --> ../tmp/temp.rs:122:37\n    |\n122 |     assert!(list_append(&mut list, &variable1).is_some());\n    |                                     ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `variable2` in this scope\n   --> ../tmp/temp.rs:123:37\n    |\n123 |     assert!(list_append(&mut list, &variable2).is_some());\n    |                                     ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `variable3` in this scope\n   --> ../tmp/temp.rs:124:37\n    |\n124 |     assert!(list_append(&mut list, &variable3).is_some());\n    |                                     ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `variable4` in this scope\n   --> ../tmp/temp.rs:125:37\n    |\n125 |     assert!(list_append(&mut list, &variable4).is_some());\n    |                                     ^^^^^^^^^ not found in this scope\n\nwarning: unused variable: `listentry`\n  --> ../tmp/temp.rs:92:21\n   |\n92 | pub fn list_prev<T>(listentry: &Option<Rc<RefCell<ListEntry<T>>>>) -> Option<Rc<RefCell<ListEntry<T>>>> {\n   |                     ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_listentry`\n   |\n   = note: `#[warn(unused_variables)]` on by default\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\nFor more information about this error, try `rustc --explain E0425`.\n",
        "list_sort": "use std::cell::RefCell;\nuse std::rc::Rc;\n\npub type ListValue = Rc<RefCell<dyn std::any::Any>>;\npub type ListCompareFunc = fn(&ListValue, &ListValue) -> i32;\n\n#[derive(Debug, Clone)]\npub struct ListEntry {\n    pub data: ListValue,\n    pub prev: Option<Rc<RefCell<ListEntry>>>,\n    pub next: Option<Rc<RefCell<ListEntry>>>,\n}\n\npub struct ListIterator {\n    pub prev_next: Option<Rc<RefCell<ListEntry>>>,\n    pub current: Option<Rc<RefCell<ListEntry>>>,\n}\n\npub fn list_sort(list: &mut Option<Rc<RefCell<ListEntry>>>, compare_func: ListCompareFunc) {\n    *list = list_sort_internal(list, compare_func);\n}\n\nfn list_sort_internal(list: &mut Option<Rc<RefCell<ListEntry>>>, compare_func: ListCompareFunc) -> Option<Rc<RefCell<ListEntry>>> {\n    if list.is_none() {\n        return None;\n    }\n\n    if list.as_ref().unwrap().borrow().next.is_none() {\n        return list.clone();\n    }\n\n    let pivot = list.take().unwrap();\n    let mut less_list = None;\n    let mut more_list = None;\n    let mut rover = pivot.borrow().next.clone();\n\n    while let Some(current) = rover.take() {\n        let next = current.borrow().next.clone();\n        if compare_func(&current.borrow().data, &pivot.borrow().data) < 0 {\n            current.borrow_mut().prev = None;\n            current.borrow_mut().next = less_list.clone();\n            if let Some(ref mut less) = less_list {\n                less.borrow_mut().prev = Some(current.clone());\n            }\n            less_list = Some(current);\n        } else {\n            current.borrow_mut().prev = None;\n            current.borrow_mut().next = more_list.clone();\n            if let Some(ref mut more) = more_list {\n                more.borrow_mut().prev = Some(current.clone());\n            }\n            more_list = Some(current);\n        }\n        rover = next;\n    }\n\n    let less_list_end = list_sort_internal(&mut less_list, compare_func);\n    let more_list_end = list_sort_internal(&mut more_list, compare_func);\n\n    *list = less_list.clone();\n\n    if let Some(ref less_end) = less_list_end {\n        less_end.borrow_mut().next = Some(pivot.clone());\n        pivot.borrow_mut().prev = Some(less_end.clone());\n    } else {\n        pivot.borrow_mut().prev = None;\n        *list = Some(pivot.clone());\n    }\n\n    pivot.borrow_mut().next = more_list.clone();\n    if let Some(ref mut more) = more_list {\n        more.borrow_mut().prev = Some(pivot.clone());\n    }\n\n    if more_list_end.is_some() {\n        more_list_end\n    } else {\n        Some(pivot)\n    }\n}\n\nfn main(){}\n //编译报错信息：",
        "list_find_data": "use std::cell::RefCell;\nuse std::rc::Rc;\nuse std::fmt::Debug;\n\npub type ListValue<T> = Rc<T>;\npub type ListEqualFunc<T> = Rc<dyn Fn(ListValue<T>, ListValue<T>) -> bool>;\n\npub struct ListEntry<T: Clone + Debug> {\n    pub data: ListValue<T>,\n    pub prev: Option<Rc<RefCell<ListEntry<T>>>>,\n    pub next: Option<Rc<RefCell<ListEntry<T>>>>,\n}\n\nimpl<T: Clone + Debug> Clone for ListEntry<T> {\n    fn clone(&self) -> Self {\n        ListEntry {\n            data: self.data.clone(),\n            prev: self.prev.clone(),\n            next: self.next.clone(),\n        }\n    }\n}\n\npub fn list_find_data<T: Clone + Debug>(list: Option<Rc<RefCell<ListEntry<T>>>>, callback: ListEqualFunc<T>, data: ListValue<T>) -> Option<Rc<RefCell<ListEntry<T>>>> {\n    let mut rover = list.clone();\n\n    while let Some(entry) = rover {\n        let entry_borrow = entry.borrow();\n        if callback(entry_borrow.data.clone(), data.clone()) {\n            return Some(entry.clone());\n        }\n        rover = entry_borrow.next.clone();\n    }\n\n    None\n}\n\nfn main(){}\npub fn list_append<T: Clone + Debug>(list: &mut Option<Rc<RefCell<ListEntry<T>>>>, data: ListValue<T>) -> Option<Rc<RefCell<ListEntry<T>>>> {\n    if list.is_none() {\n        return None;\n    }\n\n    let newentry = Rc::new(RefCell::new(ListEntry {\n        data,\n        prev: None,\n        next: None,\n    }));\n\n    if list.as_ref().unwrap().borrow().next.is_none() {\n        list.as_mut().unwrap().borrow_mut().next = Some(Rc::clone(&newentry));\n        newentry.borrow_mut().prev = list.clone();\n    } else {\n        let mut rover = list.as_ref().unwrap().clone();\n        while rover.borrow().next.is_some() {\n            let next_rover = rover.borrow().next.as_ref().unwrap().clone();\n            rover = next_rover;\n        }\n        rover.borrow_mut().next = Some(Rc::clone(&newentry));\n        newentry.borrow_mut().prev = Some(rover);\n    }\n\n    Some(newentry)\n}\n\npub fn list_nth_entry<T: Clone + Debug>(list: Option<Rc<RefCell<ListEntry<T>>>>, n: usize) -> Option<Rc<RefCell<ListEntry<T>>>> {\n    let entry = list;\n    let mut i = 0;\n\n    let mut current_entry = entry;\n    while i < n {\n        if let Some(e) = current_entry {\n            current_entry = e.borrow().next.clone();\n        } else {\n            return None;\n        }\n        i += 1;\n    }\n\n    current_entry\n}\n\npub fn list_remove_entry<T: Clone + Debug>(list: &mut Option<Rc<RefCell<ListEntry<T>>>>, entry: &Rc<RefCell<ListEntry<T>>>) -> i32 {\n    if list.is_none() || entry.borrow().prev.is_none() && list.as_ref().unwrap().as_ptr() != entry.as_ptr() {\n        return 0;\n    }\n\n    if entry.borrow().prev.is_none() {\n        *list = entry.borrow().next.clone();\n\n        if let Some(next_entry) = entry.borrow().next.as_ref() {\n            next_entry.borrow_mut().prev = None;\n        }\n    } else {\n        if let Some(prev_entry) = entry.borrow().prev.as_ref() {\n            prev_entry.borrow_mut().next = entry.borrow().next.clone();\n        }\n\n        if let Some(next_entry) = entry.borrow().next.as_ref() {\n            next_entry.borrow_mut().prev = entry.borrow().prev.clone();\n        }\n    }\n\n    1\n}\n\npub fn list_free<T: Clone + Debug>(list: Option<Rc<RefCell<ListEntry<T>>>>) {\n    let mut entry = list;\n\n    while let Some(current_entry) = entry {\n        let next = current_entry.borrow().next.clone();\n        drop(current_entry);\n        entry = next;\n    }\n}\n\npub fn check_list_integrity<T: Clone + Debug>(list: Option<Rc<RefCell<ListEntry<T>>>>) {\n    let mut prev: Option<Rc<RefCell<ListEntry<T>>>> = None;\n    let mut rover = list;\n\n    while let Some(current) = rover {\n        assert_eq!(list_prev(&Some(current.clone())), prev);\n        prev = Some(current.clone());\n        rover = list_next(Some(current));\n    }\n}\n\npub fn list_next<T: Clone + Debug>(listentry: Option<Rc<RefCell<ListEntry<T>>>>) -> Option<Rc<RefCell<ListEntry<T>>>> {\n    if let Some(entry) = listentry {\n        entry.borrow().next.clone()\n    } else {\n        None\n    }\n}\n\npub fn list_prev<T: Clone + Debug>(listentry: &Option<Rc<RefCell<ListEntry<T>>>>) -> Option<Rc<RefCell<ListEntry<T>>>> {\n    if let Some(entry) = listentry {\n        entry.borrow().prev.clone()\n    } else {\n        None\n    }\n}\n\npub fn list_length<T: Clone + Debug>(list: Option<Rc<RefCell<ListEntry<T>>>>) -> usize {\n    let mut length = 0;\n    let mut entry = list;\n\n    while let Some(current_entry) = entry.take() {\n        length += 1;\n        entry = current_entry.borrow().next.clone();\n    }\n\n    length\n}\n\npub fn generate_list() -> Option<Rc<RefCell<ListEntry<i32>>>> {\n    let mut list: Option<Rc<RefCell<ListEntry<i32>>>> = None;\n\n    let variable1 = Rc::new(1);\n    let variable2 = Rc::new(2);\n    let variable3 = Rc::new(3);\n    let variable4 = Rc::new(4);\n\n    assert!(list_append(&mut list, variable1).is_some());\n    assert!(list_append(&mut list, variable2).is_some());\n    assert!(list_append(&mut list, variable3).is_some());\n    assert!(list_append(&mut list, variable4).is_some());\n\n    list\n}\n\npub fn list_data<T: Clone + Debug>(listentry: Option<Rc<RefCell<ListEntry<T>>>>) -> Option<ListValue<T>> {\n    if let Some(entry) = listentry {\n        Some(entry.borrow().data.clone())\n    } else {\n        None\n    }\n}\n\npub fn list_prepend<T: Clone + Debug>(list: &mut Option<Rc<RefCell<ListEntry<T>>>>, data: ListValue<T>) -> Option<Rc<RefCell<ListEntry<T>>>> {\n    let new_entry = Rc::new(RefCell::new(ListEntry {\n        data,\n        prev: None,\n        next: list.clone(),\n    }));\n\n    if let Some(old_head) = list.as_ref() {\n        old_head.borrow_mut().prev = Some(new_entry.clone());\n    }\n\n    *list = Some(new_entry.clone());\n\n    Some(new_entry)\n}\n //编译报错信息：error[E0369]: binary operation `==` cannot be applied to type `Option<Rc<RefCell<ListEntry<T>>>>`\n   --> ../tmp/temp.rs:122:9\n    |\n122 |         assert_eq!(list_prev(&Some(current.clone())), prev);\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |         |\n    |         Option<Rc<RefCell<ListEntry<T>>>>\n    |         Option<Rc<RefCell<ListEntry<T>>>>\n    |\nnote: an implementation of `PartialEq` might be missing for `ListEntry<T>`\n   --> ../tmp/temp.rs:8:1\n    |\n8   | pub struct ListEntry<T: Clone + Debug> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`\n",
        "list_to_array": "pub fn list_length<T>(list: Option<Rc<RefCell<ListEntry<T>>>>) -> usize {\n    let mut length = 0;\n    let mut entry = list;\n\n    while let Some(current_entry) = entry.take() {\n        length += 1;\n        entry = current_entry.borrow().next.clone();\n    }\n\n    length\n}\n\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nstruct ListEntry<T> {\n    data: T,\n    next: Option<Rc<RefCell<ListEntry<T>>>>,\n}\n\nimpl<T: Clone> Clone for ListEntry<T> {\n    fn clone(&self) -> Self {\n        ListEntry {\n            data: self.data.clone(),\n            next: self.next.clone(),\n        }\n    }\n}\n\npub fn list_to_array<T: Clone>(list: Option<Rc<RefCell<ListEntry<T>>>>) -> Option<Vec<T>> {\n    let length = list_length(list.clone());\n    let mut array = Vec::with_capacity(length);\n    let mut rover = list;\n\n    for _ in 0..length {\n        if let Some(current_entry) = rover.take() {\n            array.push(current_entry.borrow().data.clone());\n            rover = current_entry.borrow().next.clone();\n        } else {\n            return None;\n        }\n    }\n\n    Some(array)\n}\n\nfn main(){}\npub fn list_append<T>(list: &mut Option<Rc<RefCell<ListEntry<T>>>>, data: T) -> Option<Rc<RefCell<ListEntry<T>>>> {\n    if list.is_none() {\n        return None;\n    }\n\n    let newentry = Rc::new(RefCell::new(ListEntry {\n        data,\n        next: None,\n    }));\n\n    if list.as_ref().unwrap().borrow().next.is_none() {\n        list.as_mut().unwrap().borrow_mut().next = Some(Rc::clone(&newentry));\n    } else {\n        let mut rover = list.as_ref().unwrap().clone();\n        while rover.borrow().next.is_some() {\n            let next_rover = rover.borrow().next.as_ref().unwrap().clone();\n            rover = next_rover;\n        }\n        rover.borrow_mut().next = Some(Rc::clone(&newentry));\n    }\n\n    Some(newentry)\n}\n\npub fn list_remove_entry<T>(list: &mut Option<Rc<RefCell<ListEntry<T>>>>, entry: &Rc<RefCell<ListEntry<T>>>) -> i32 {\n    if list.is_none() {\n        return 0;\n    }\n\n    if list.as_ref().unwrap().as_ptr() == entry.as_ptr() {\n        *list = entry.borrow().next.clone();\n    } else {\n        let mut rover = list.as_ref().unwrap().clone();\n        while rover.borrow().next.is_some() {\n            let next_rover = rover.borrow().next.as_ref().unwrap().clone();\n            if next_rover.as_ptr() == entry.as_ptr() {\n                rover.borrow_mut().next = entry.borrow().next.clone();\n                break;\n            }\n            rover = next_rover;\n        }\n    }\n\n    1\n}\n\npub fn list_prepend<T>(list: &mut Option<Rc<RefCell<ListEntry<T>>>>, data: T) -> Option<Rc<RefCell<ListEntry<T>>>> {\n    let new_entry = Rc::new(RefCell::new(ListEntry {\n        data,\n        next: list.clone(),\n    }));\n\n    *list = Some(new_entry.clone());\n\n    Some(new_entry)\n}\n\npub fn list_prev<T>(listentry: &Option<Rc<RefCell<ListEntry<T>>>>) -> Option<Rc<RefCell<ListEntry<T>>>> {\n    None\n}\n //编译报错信息："
    },
    "test-list": {
        "test_list_iterate_bad_remove": "\npub fn list_iter_next<T: Clone>(iter: &mut ListIterator<T>) -> Option<T> {\n    if iter.current.is_none() || iter.current.as_ref().map(|c| c.as_ptr()) != iter.prev_next.as_ref().map(|p| p.as_ptr()) {\n        iter.current = iter.prev_next.clone();\n    } else {\n        if let Some(current) = iter.current.take() {\n            *iter.prev_next = current.borrow().next.clone();\n            iter.current = current.borrow().next.clone();\n        }\n    }\n\n    iter.current.as_ref().map(|entry| entry.borrow().data.clone())\n}\n\npub fn list_free<T: Clone>(list: Option<Rc<RefCell<ListEntry<T>>>>) {\n    let mut entry = list;\n\n    while let Some(current_entry) = entry {\n        let next = current_entry.borrow().next.clone();\n        drop(current_entry);\n        entry = next;\n    }\n}\n\npub fn list_iterate<'a, T: Clone>(list: &'a mut Option<Rc<RefCell<ListEntry<T>>>>, iter: &mut ListIterator<'a, T>) {\n    iter.prev_next = list;\n    iter.current = None;\n}\n\npub fn list_prepend<T: Clone>(list: &mut Option<Rc<RefCell<ListEntry<T>>>>, data: T) -> Option<Rc<RefCell<ListEntry<T>>>> {\n    let new_entry = Rc::new(RefCell::new(ListEntry {\n        data,\n        prev: None,\n        next: list.clone(),\n    }));\n\n    if let Some(old_head) = list.as_ref() {\n        old_head.borrow_mut().prev = Some(new_entry.clone());\n    }\n\n    *list = Some(new_entry.clone());\n\n    Some(new_entry)\n}\n\npub fn list_remove_data<T: PartialEq + Clone>(list: &mut Option<Rc<RefCell<ListEntry<T>>>>, callback: ListEqualFunc<T>, data: &T) -> usize {\n    let mut entries_removed = 0;\n    let mut rover = list.clone();\n\n    while let Some(current) = rover {\n        let next = current.borrow().next.clone();\n\n        if callback(&current.borrow().data, data) {\n            if let Some(prev) = current.borrow().prev.clone() {\n                prev.borrow_mut().next = current.borrow().next.clone();\n            } else {\n                *list = current.borrow().next.clone();\n            }\n\n            if let Some(next) = current.borrow().next.clone() {\n                next.borrow_mut().prev = current.borrow().prev.clone();\n            }\n\n            entries_removed += 1;\n        }\n\n        rover = next;\n    }\n\n    entries_removed\n}\n\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug, PartialEq, Clone)]\npub struct ListEntry<T: Clone> {\n    pub data: T,\n    pub prev: Option<Rc<RefCell<ListEntry<T>>>>,\n    pub next: Option<Rc<RefCell<ListEntry<T>>>>,\n}\n\npub type ListEqualFunc<T> = fn(&T, &T) -> bool;\n\npub type ListCompareFunc<T> = Option<fn(&T, &T) -> i32>;\n\npub struct ListIterator<'a, T: Clone> {\n    pub prev_next: &'a mut Option<Rc<RefCell<ListEntry<T>>>>,\n    pub current: Option<Rc<RefCell<ListEntry<T>>>>,\n}\n\npub fn list_iter_has_more<T: Clone>(iter: &mut ListIterator<T>) -> bool {\n    if iter.current.is_none() || iter.current.as_ref().unwrap().as_ptr() != iter.prev_next.as_ref().unwrap().as_ptr() {\n        iter.prev_next.is_some()\n    } else {\n        iter.current.as_ref().unwrap().borrow().next.is_some()\n    }\n}\n\npub fn list_iter_remove<T: Clone>(iter: &mut ListIterator<T>) {\n    if iter.current.is_none() || iter.current.as_ref().map(|c| Rc::ptr_eq(c, iter.prev_next.as_ref().unwrap())) == Some(false) {\n        // Do nothing\n    } else {\n        let current = iter.current.take().unwrap();\n        *iter.prev_next = current.borrow().next.clone();\n\n        if let Some(next) = current.borrow().next.as_ref() {\n            next.borrow_mut().prev = current.borrow().prev.clone();\n        }\n\n        iter.current = None;\n    }\n}\n\npub fn test_list_iterate_bad_remove() {\n    let mut list: Option<Rc<RefCell<ListEntry<i32>>>> = None;\n    let mut values = [0; 49];\n    let mut iter = ListIterator {\n        prev_next: &mut list,\n        current: None,\n    };\n\n    for i in 0..49 {\n        values[i] = i as i32;\n        list_prepend(&mut list, values[i]);\n    }\n\n    list_iterate(&mut list, &mut iter);\n\n    while list_iter_has_more(&mut iter) {\n        let val = list_iter_next(&mut iter);\n\n        if val.unwrap() % 2 == 0 {\n            let mut local_list = list.clone();\n            assert!(list_remove_data(&mut local_list, int_equal, &val.unwrap()) != 0);\n            list = local_list;\n            list_iter_remove(&mut iter);\n        }\n    }\n\n    list_free(list);\n}\n\npub fn int_equal(a: &i32, b: &i32) -> bool {\n    a == b\n}\n\nfn main() {}\n\n //编译报错信息：error[E0499]: cannot borrow `list` as mutable more than once at a time\n   --> ../tmp/temp.rs:125:22\n    |\n119 |         prev_next: &mut list,\n    |                    --------- first mutable borrow occurs here\n...\n125 |         list_prepend(&mut list, values[i]);\n    |                      ^^^^^^^^^ second mutable borrow occurs here\n...\n128 |     list_iterate(&mut list, &mut iter);\n    |                             --------- first borrow later used here\n\nerror[E0499]: cannot borrow `list` as mutable more than once at a time\n   --> ../tmp/temp.rs:128:18\n    |\n119 |         prev_next: &mut list,\n    |                    --------- first mutable borrow occurs here\n...\n128 |     list_iterate(&mut list, &mut iter);\n    |                  ^^^^^^^^^  --------- first borrow later used here\n    |                  |\n    |                  second mutable borrow occurs here\n\nerror[E0502]: cannot borrow `list` as immutable because it is also borrowed as mutable\n   --> ../tmp/temp.rs:134:34\n    |\n119 |         prev_next: &mut list,\n    |                    --------- mutable borrow occurs here\n...\n134 |             let mut local_list = list.clone();\n    |                                  ^^^^ immutable borrow occurs here\n...\n137 |             list_iter_remove(&mut iter);\n    |                              --------- mutable borrow later used here\n\nerror[E0506]: cannot assign to `list` because it is borrowed\n   --> ../tmp/temp.rs:136:13\n    |\n119 |         prev_next: &mut list,\n    |                    --------- `list` is borrowed here\n...\n136 |             list = local_list;\n    |             ^^^^ `list` is assigned to here but it was already borrowed\n137 |             list_iter_remove(&mut iter);\n    |                              --------- borrow later used here\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations: E0499, E0502, E0506.\nFor more information about an error, try `rustc --explain E0499`.\n",
        "test_list_iterate": "use std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug, PartialEq, Clone)]\npub struct ListEntry<T: Clone> {\n    pub data: T,\n    pub prev: Option<Rc<RefCell<ListEntry<T>>>>,\n    pub next: Option<Rc<RefCell<ListEntry<T>>>>,\n}\n\npub type ListEqualFunc<T> = fn(&T, &T) -> bool;\npub type ListCompareFunc<T> = Option<fn(&T, &T) -> i32>;\n\npub struct ListIterator<'a, T: Clone> {\n    pub prev_next: &'a mut Option<Rc<RefCell<ListEntry<T>>>>,\n    pub current: Option<Rc<RefCell<ListEntry<T>>>>,\n}\n\npub fn list_iter_next<T: Clone>(iter: &mut ListIterator<T>) -> Option<T> {\n    if iter.current.is_none() || iter.current.as_ref().map(|c| c.as_ptr()) != iter.prev_next.as_ref().map(|p| p.as_ptr()) {\n        iter.current = iter.prev_next.clone();\n    } else {\n        if let Some(current) = iter.current.take() {\n            *iter.prev_next = current.borrow().next.clone();\n            iter.current = current.borrow().next.clone();\n        }\n    }\n\n    iter.current.as_ref().map(|entry| entry.borrow().data.clone())\n}\n\npub fn list_free<T: Clone>(list: Option<Rc<RefCell<ListEntry<T>>>>) {\n    let mut entry = list;\n\n    while let Some(current_entry) = entry {\n        let next = current_entry.borrow().next.clone();\n        drop(current_entry);\n        entry = next;\n    }\n}\n\npub fn list_iterate<'a, T: Clone>(list: &'a mut Option<Rc<RefCell<ListEntry<T>>>>, iter: &mut ListIterator<'a, T>) {\n    iter.prev_next = list;\n    iter.current = None;\n}\n\npub fn list_length<T: Clone>(list: Option<Rc<RefCell<ListEntry<T>>>>) -> usize {\n    let mut length = 0;\n    let mut entry = list;\n\n    while let Some(current_entry) = entry.take() {\n        length += 1;\n        entry = current_entry.borrow().next.clone();\n    }\n\n    length\n}\n\npub fn list_prepend<T: Clone>(list: &mut Option<Rc<RefCell<ListEntry<T>>>>, data: T) -> Option<Rc<RefCell<ListEntry<T>>>> {\n    let new_entry = Rc::new(RefCell::new(ListEntry {\n        data,\n        prev: None,\n        next: list.clone(),\n    }));\n\n    if let Some(old_head) = list.as_ref() {\n        old_head.borrow_mut().prev = Some(new_entry.clone());\n    }\n\n    *list = Some(new_entry.clone());\n\n    Some(new_entry)\n}\n\npub fn list_iter_has_more<T: Clone>(iter: &mut ListIterator<T>) -> bool {\n    if iter.current.is_none() || iter.current.as_ref().unwrap().as_ptr() != iter.prev_next.as_ref().unwrap().as_ptr() {\n        iter.prev_next.is_some()\n    } else {\n        iter.current.as_ref().unwrap().borrow().next.is_some()\n    }\n}\n\npub fn list_iter_remove<T: Clone>(iter: &mut ListIterator<T>) {\n    if iter.current.is_none() || iter.current.as_ref().map(|c| Rc::ptr_eq(c, iter.prev_next.as_ref().unwrap())) == Some(false) {\n        // Do nothing\n    } else {\n        let current = iter.current.take().unwrap();\n        *iter.prev_next = current.borrow().next.clone();\n\n        if let Some(next) = current.borrow().next.as_ref() {\n            next.borrow_mut().prev = current.borrow().prev.clone();\n        }\n\n        iter.current = None;\n    }\n}\n\npub fn test_list_iterate() {\n    let mut list: Option<Rc<RefCell<ListEntry<i32>>>> = None;\n    let mut iter = ListIterator {\n        prev_next: &mut list,\n        current: None,\n    };\n    let mut counter = 0;\n\n    for _ in 0..50 {\n        list_prepend(&mut list, 0);\n    }\n\n    list_iterate(&mut list, &mut iter);\n    list_iter_remove(&mut iter);\n\n    while list_iter_has_more(&mut iter) {\n        if let Some(_data) = list_iter_next(&mut iter) {\n            counter += 1;\n\n            if counter % 2 == 0 {\n                list_iter_remove(&mut iter);\n                list_iter_remove(&mut iter);\n            }\n        }\n    }\n\n    assert!(list_iter_next(&mut iter).is_none());\n    list_iter_remove(&mut iter);\n\n    assert_eq!(counter, 50);\n    assert_eq!(list_length(list.clone()), 25);\n\n    list_free(list.take());\n\n    list = None;\n    counter = 0;\n    list_iterate(&mut list, &mut iter);\n\n    while list_iter_has_more(&mut iter) {\n        if let Some(_data) = list_iter_next(&mut iter) {\n            counter += 1;\n        }\n    }\n\n    assert_eq!(counter, 0);\n}\n\nfn main() {}\n //编译报错信息：error[E0499]: cannot borrow `list` as mutable more than once at a time\n   --> ../tmp/temp.rs:107:22\n    |\n101 |         prev_next: &mut list,\n    |                    --------- first mutable borrow occurs here\n...\n107 |         list_prepend(&mut list, 0);\n    |                      ^^^^^^^^^ second mutable borrow occurs here\n...\n110 |     list_iterate(&mut list, &mut iter);\n    |                             --------- first borrow later used here\n\nerror[E0499]: cannot borrow `list` as mutable more than once at a time\n   --> ../tmp/temp.rs:110:18\n    |\n101 |         prev_next: &mut list,\n    |                    --------- first mutable borrow occurs here\n...\n110 |     list_iterate(&mut list, &mut iter);\n    |                  ^^^^^^^^^  --------- first borrow later used here\n    |                  |\n    |                  second mutable borrow occurs here\n\nerror[E0502]: cannot borrow `list` as immutable because it is also borrowed as mutable\n   --> ../tmp/temp.rs:128:28\n    |\n101 |         prev_next: &mut list,\n    |                    --------- mutable borrow occurs here\n...\n128 |     assert_eq!(list_length(list.clone()), 25);\n    |                            ^^^^ immutable borrow occurs here\n...\n134 |     list_iterate(&mut list, &mut iter);\n    |                             --------- mutable borrow later used here\n\nerror[E0499]: cannot borrow `list` as mutable more than once at a time\n   --> ../tmp/temp.rs:130:15\n    |\n101 |         prev_next: &mut list,\n    |                    --------- first mutable borrow occurs here\n...\n130 |     list_free(list.take());\n    |               ^^^^ second mutable borrow occurs here\n...\n134 |     list_iterate(&mut list, &mut iter);\n    |                             --------- first borrow later used here\n\nerror[E0506]: cannot assign to `list` because it is borrowed\n   --> ../tmp/temp.rs:132:5\n    |\n101 |         prev_next: &mut list,\n    |                    --------- `list` is borrowed here\n...\n132 |     list = None;\n    |     ^^^^ `list` is assigned to here but it was already borrowed\n133 |     counter = 0;\n134 |     list_iterate(&mut list, &mut iter);\n    |                             --------- borrow later used here\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations: E0499, E0502, E0506.\nFor more information about an error, try `rustc --explain E0499`.\n",
        "test_list_to_array": "use std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug, PartialEq, Clone)]\npub struct ListEntry<T> {\n    pub data: T,\n    pub prev: Option<Rc<RefCell<ListEntry<T>>>>,\n    pub next: Option<Rc<RefCell<ListEntry<T>>>>,\n}\n\npub type ListEqualFunc<T> = fn(&T, &T) -> bool;\n\npub type ListCompareFunc<T> = Option<fn(&T, &T) -> i32>;\n\npub fn list_length<T>(list: Option<Rc<RefCell<ListEntry<T>>>>) -> usize {\n    let mut length = 0;\n    let mut entry = list;\n\n    while let Some(current_entry) = entry.take() {\n        length += 1;\n        entry = current_entry.borrow().next.clone();\n    }\n\n    length\n}\n\npub fn list_append<T: Clone>(list: &mut Option<Rc<RefCell<ListEntry<T>>>>, data: T) -> Option<Rc<RefCell<ListEntry<T>>>> {\n    if list.is_none() {\n        return None;\n    }\n\n    let newentry = Rc::new(RefCell::new(ListEntry {\n        data,\n        prev: None,\n        next: None,\n    }));\n\n    if list.as_ref().unwrap().borrow().next.is_none() {\n        list.as_mut().unwrap().borrow_mut().next = Some(Rc::clone(&newentry));\n        newentry.borrow_mut().prev = list.clone();\n    } else {\n        let mut rover = list.as_ref().unwrap().clone();\n        while rover.borrow().next.is_some() {\n            let next_rover = rover.borrow().next.as_ref().unwrap().clone();\n            rover = next_rover;\n        }\n        rover.borrow_mut().next = Some(Rc::clone(&newentry));\n        newentry.borrow_mut().prev = Some(rover);\n    }\n\n    Some(newentry)\n}\n\npub fn generate_list() -> Option<Rc<RefCell<ListEntry<&'static i32>>>> {\n    let mut list: Option<Rc<RefCell<ListEntry<&'static i32>>>> = None;\n\n    assert!(list_append(&mut list, &variable1).is_some());\n    assert!(list_append(&mut list, &variable2).is_some());\n    assert!(list_append(&mut list, &variable3).is_some());\n    assert!(list_append(&mut list, &variable4).is_some());\n\n    list\n}\n\npub static variable1: i32 = 50;\npub static variable2: i32 = 0;\npub static variable3: i32 = 0;\npub static variable4: i32 = 0;\n\npub fn list_free<T>(list: Option<Rc<RefCell<ListEntry<T>>>>) {\n    let mut entry = list;\n\n    while let Some(current_entry) = entry {\n        let next = current_entry.borrow().next.clone();\n        drop(current_entry);\n        entry = next;\n    }\n}\n\npub fn test_list_to_array() {\n    let list = generate_list();\n    let array = list_to_array(list.clone());\n\n    assert_eq!(array[0], &variable1 as *const i32);\n    assert_eq!(array[1], &variable2 as *const i32);\n    assert_eq!(array[2], &variable3 as *const i32);\n    assert_eq!(array[3], &variable4 as *const i32);\n\n    list_free(list);\n}\n\npub fn list_to_array<T: Clone>(list: Option<Rc<RefCell<ListEntry<T>>>>) -> Vec<*const T> {\n    let mut rover = list.clone();\n    let length = list_length(list);\n    let mut array = Vec::with_capacity(length);\n\n    for _ in 0..length {\n        if let Some(current_entry) = rover {\n            array.push(&current_entry.borrow().data as *const T);\n            rover = current_entry.borrow().next.clone();\n        }\n    }\n\n    array\n}\n\nfn main(){}\n //编译报错信息：error[E0308]: mismatched types\n  --> ../tmp/temp.rs:84:26\n   |\n84 |     assert_eq!(array[0], &variable1 as *const i32);\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^ expected `*const &i32`, found `*const i32`\n   |\n   = note: expected raw pointer `*const &i32`\n              found raw pointer `*const i32`\n\nerror[E0308]: mismatched types\n  --> ../tmp/temp.rs:85:26\n   |\n85 |     assert_eq!(array[1], &variable2 as *const i32);\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^ expected `*const &i32`, found `*const i32`\n   |\n   = note: expected raw pointer `*const &i32`\n              found raw pointer `*const i32`\n\nerror[E0308]: mismatched types\n  --> ../tmp/temp.rs:86:26\n   |\n86 |     assert_eq!(array[2], &variable3 as *const i32);\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^ expected `*const &i32`, found `*const i32`\n   |\n   = note: expected raw pointer `*const &i32`\n              found raw pointer `*const i32`\n\nerror[E0308]: mismatched types\n  --> ../tmp/temp.rs:87:26\n   |\n87 |     assert_eq!(array[3], &variable4 as *const i32);\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^ expected `*const &i32`, found `*const i32`\n   |\n   = note: expected raw pointer `*const &i32`\n              found raw pointer `*const i32`\n\nerror: aborting due to 4 previous errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
    },
    "rb-tree": {
        "rb_tree_insert_case1": "use std::rc::Rc;\nuse std::cell::RefCell;\n\npub enum RBTreeNodeColor {\n    RbTreeNodeRed,\n    RbTreeNodeBlack,\n}\n\nimpl Clone for RBTreeNodeColor {\n    fn clone(&self) -> Self {\n        match self {\n            RBTreeNodeColor::RbTreeNodeRed => RBTreeNodeColor::RbTreeNodeRed,\n            RBTreeNodeColor::RbTreeNodeBlack => RBTreeNodeColor::RbTreeNodeBlack,\n        }\n    }\n}\n\npub enum RBTreeNodeSide {\n    RbTreeNodeLeft,\n    RbTreeNodeRight,\n}\n\nimpl PartialEq for RBTreeNodeSide {\n    fn eq(&self, other: &Self) -> bool {\n        match (self, other) {\n            (RBTreeNodeSide::RbTreeNodeLeft, RBTreeNodeSide::RbTreeNodeLeft) => true,\n            (RBTreeNodeSide::RbTreeNodeRight, RBTreeNodeSide::RbTreeNodeRight) => true,\n            _ => false,\n        }\n    }\n}\n\npub struct RBTreeNode<T> {\n    pub color: RBTreeNodeColor,\n    pub key: T,\n    pub value: T,\n    pub parent: Option<Rc<RefCell<RBTreeNode<T>>>>,\n    pub children: [Option<Rc<RefCell<RBTreeNode<T>>>>; 2],\n}\n\nimpl<T: Clone + PartialEq> Clone for RBTreeNode<T> {\n    fn clone(&self) -> Self {\n        RBTreeNode {\n            color: self.color.clone(),\n            key: self.key.clone(),\n            value: self.value.clone(),\n            parent: self.parent.clone(),\n            children: self.children.clone(),\n        }\n    }\n}\n\nimpl PartialEq for RBTreeNodeColor {\n    fn eq(&self, other: &Self) -> bool {\n        match (self, other) {\n            (RBTreeNodeColor::RbTreeNodeRed, RBTreeNodeColor::RbTreeNodeRed) => true,\n            (RBTreeNodeColor::RbTreeNodeBlack, RBTreeNodeColor::RbTreeNodeBlack) => true,\n            _ => false,\n        }\n    }\n}\n\nimpl<T: PartialEq> PartialEq for RBTreeNode<T> {\n    fn eq(&self, other: &Self) -> bool {\n        self.key == other.key && self.value == other.value && self.color == other.color\n    }\n}\n\npub struct RBTree<T> {\n    pub root_node: Option<Rc<RefCell<RBTreeNode<T>>>>,\n    pub compare_func: fn(&T, &T) -> i32,\n    pub num_nodes: i32,\n}\n\npub fn rb_tree_insert_case1<T>(tree: &mut RBTree<T>, node: Rc<RefCell<RBTreeNode<T>>>) {\n    let node_borrow = node.borrow();\n    if node_borrow.parent.is_none() {\n        node.borrow_mut().color = RBTreeNodeColor::RbTreeNodeBlack;\n    } else {\n        rb_tree_insert_case2(tree, node.clone());\n    }\n}\n\npub fn rb_tree_insert_case3<T>(tree: &mut RBTree<T>, node: Rc<RefCell<RBTreeNode<T>>>) {\n    let grandparent = node.borrow().parent.as_ref().unwrap().borrow().parent.clone().unwrap();\n    let uncle = rb_tree_node_uncle(node.clone());\n\n    if let Some(uncle_node) = uncle {\n        let mut uncle_borrow = uncle_node.borrow_mut();\n        let mut node_borrow = node.borrow_mut();\n        let mut grandparent_borrow = grandparent.borrow_mut();\n\n        if uncle_borrow.color == RBTreeNodeColor::RbTreeNodeRed {\n            node_borrow.parent.as_ref().unwrap().borrow_mut().color = RBTreeNodeColor::RbTreeNodeBlack;\n            uncle_borrow.color = RBTreeNodeColor::RbTreeNodeBlack;\n            grandparent_borrow.color = RBTreeNodeColor::RbTreeNodeRed;\n\n            rb_tree_insert_case1(tree, grandparent);\n        } else {\n            rb_tree_insert_case4(tree, node);\n        }\n    } else {\n        rb_tree_insert_case4(tree, node);\n    }\n}\n\npub fn rb_tree_rotate<T>(tree: &mut RBTree<T>, node: Rc<RefCell<RBTreeNode<T>>>, direction: RBTreeNodeSide) -> Rc<RefCell<RBTreeNode<T>>> {\n    let direction_index = match direction {\n        RBTreeNodeSide::RbTreeNodeLeft => 1,\n        RBTreeNodeSide::RbTreeNodeRight => 0,\n    };\n    let new_root = node.borrow().children[direction_index].clone().unwrap();\n    let mut new_root_borrow = new_root.borrow_mut();\n    let mut node_borrow = node.borrow_mut();\n\n    rb_tree_node_replace(tree, node.clone(), Some(new_root.clone()));\n\n    node_borrow.children[direction_index] = new_root_borrow.children[1 - direction_index].clone();\n    new_root_borrow.children[1 - direction_index] = Some(node.clone());\n\n    node_borrow.parent = Some(new_root.clone());\n\n    if let Some(ref mut child) = node_borrow.children[direction_index] {\n        child.borrow_mut().parent = Some(node.clone());\n    }\n\n    new_root\n}\n\npub fn rb_tree_node_replace<T>(tree: &mut RBTree<T>, node1: Rc<RefCell<RBTreeNode<T>>>, node2: Option<Rc<RefCell<RBTreeNode<T>>>>) {\n    let side = rb_tree_node_side(node1.clone());\n\n    if let Some(ref node2_inner) = node2 {\n        node2_inner.borrow_mut().parent = node1.borrow().parent.clone();\n    }\n\n    if node1.borrow().parent.is_none() {\n        tree.root_node = node2;\n    } else {\n        let parent = node1.borrow().parent.as_ref().unwrap();\n        let mut parent_borrow_mut = parent.borrow_mut();\n        parent_borrow_mut.children[side as usize] = node2;\n    }\n}\n\npub fn rb_tree_node_sibling<T>(node: Rc<RefCell<RBTreeNode<T>>>) -> Option<Rc<RefCell<RBTreeNode<T>>>> {\n    let side = rb_tree_node_side(node.clone());\n    node.borrow().parent.as_ref().unwrap().borrow().children[1 - side as usize].clone()\n}\n\npub fn rb_tree_insert_case2<T>(tree: &mut RBTree<T>, node: Rc<RefCell<RBTreeNode<T>>>) {\n    let parent_color = node.borrow().parent.as_ref().unwrap().borrow().color.clone();\n\n    if parent_color != RBTreeNodeColor::RbTreeNodeBlack {\n        rb_tree_insert_case3(tree, node);\n    }\n}\n\npub fn rb_tree_node_uncle<T>(node: Rc<RefCell<RBTreeNode<T>>>) -> Option<Rc<RefCell<RBTreeNode<T>>>> {\n    rb_tree_node_sibling(node.borrow().parent.clone().unwrap())\n}\n\npub fn rb_tree_insert_case4<T>(tree: &mut RBTree<T>, node: Rc<RefCell<RBTreeNode<T>>>) {\n    let side = rb_tree_node_side(node.clone());\n    let parent = node.borrow().parent.clone().unwrap();\n    let mut next_node = node.clone();\n\n    if side != rb_tree_node_side(parent.clone()) {\n        next_node = parent.clone();\n        rb_tree_rotate(tree, parent, match side {\n            RBTreeNodeSide::RbTreeNodeLeft => RBTreeNodeSide::RbTreeNodeRight,\n            RBTreeNodeSide::RbTreeNodeRight => RBTreeNodeSide::RbTreeNodeLeft,\n        });\n    }\n\n    rb_tree_insert_case5(tree, next_node);\n}\n\npub fn rb_tree_node_side<T>(node: Rc<RefCell<RBTreeNode<T>>>) -> RBTreeNodeSide {\n    let parent = node.borrow().parent.as_ref().unwrap();\n    if parent.borrow().children[0].as_ref().map_or(false, |child| Rc::ptr_eq(child, &node)) {\n        RBTreeNodeSide::RbTreeNodeLeft\n    } else {\n        RBTreeNodeSide::RbTreeNodeRight\n    }\n}\n\npub fn rb_tree_insert_case5<T>(tree: &mut RBTree<T>, node: Rc<RefCell<RBTreeNode<T>>>) {\n    let parent = node.borrow().parent.clone().unwrap();\n    let grandparent = parent.borrow().parent.clone().unwrap();\n    let side = rb_tree_node_side(node.clone());\n\n    let mut parent_borrow = parent.borrow_mut();\n    let mut grandparent_borrow = grandparent.borrow_mut();\n\n    rb_tree_rotate(tree, grandparent, match side {\n        RBTreeNodeSide::RbTreeNodeLeft => RBTreeNodeSide::RbTreeNodeRight,\n        RBTreeNodeSide::RbTreeNodeRight => RBTreeNodeSide::RbTreeNodeLeft,\n    });\n\n    parent_borrow.color = RBTreeNodeColor::RbTreeNodeBlack;\n    grandparent_borrow.color = RBTreeNodeColor::RbTreeNodeRed;\n}\n\nfn main(){}\n //编译报错信息：warning: variable does not need to be mutable\n  --> ../tmp/temp.rs:90:13\n   |\n90 |         let mut node_borrow = node.borrow_mut();\n   |             ----^^^^^^^^^^^\n   |             |\n   |             help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0505]: cannot move out of `grandparent` because it is borrowed\n   --> ../tmp/temp.rs:98:40\n    |\n85  |     let grandparent = node.borrow().parent.as_ref().unwrap().borrow().parent.clone().unwrap();\n    |         ----------- binding `grandparent` declared here\n...\n91  |         let mut grandparent_borrow = grandparent.borrow_mut();\n    |                                      ----------- borrow of `grandparent` occurs here\n...\n98  |             rb_tree_insert_case1(tree, grandparent);\n    |                                        ^^^^^^^^^^^ move out of `grandparent` occurs here\n...\n102 |     } else {\n    |     - borrow might be used here, when `grandparent_borrow` is dropped and runs the destructor for type `RefMut<'_, RBTreeNode<T>>`\n\nerror[E0505]: cannot move out of `node` because it is borrowed\n   --> ../tmp/temp.rs:100:40\n    |\n84  | pub fn rb_tree_insert_case3<T>(tree: &mut RBTree<T>, node: Rc<RefCell<RBTreeNode<T>>>) {\n    |                                                      ---- binding `node` declared here\n...\n90  |         let mut node_borrow = node.borrow_mut();\n    |                               ---- borrow of `node` occurs here\n...\n100 |             rb_tree_insert_case4(tree, node);\n    |                                        ^^^^ move out of `node` occurs here\n101 |         }\n102 |     } else {\n    |     - borrow might be used here, when `node_borrow` is dropped and runs the destructor for type `RefMut<'_, RBTreeNode<T>>`\n\nerror[E0505]: cannot move out of `new_root` because it is borrowed\n   --> ../tmp/temp.rs:127:5\n    |\n112 |     let new_root = node.borrow().children[direction_index].clone().unwrap();\n    |         -------- binding `new_root` declared here\n113 |     let mut new_root_borrow = new_root.borrow_mut();\n    |                               -------- borrow of `new_root` occurs here\n...\n127 |     new_root\n    |     ^^^^^^^^ move out of `new_root` occurs here\n128 | }\n    | - borrow might be used here, when `new_root_borrow` is dropped and runs the destructor for type `RefMut<'_, RBTreeNode<T>>`\n\nerror[E0716]: temporary value dropped while borrowed\n   --> ../tmp/temp.rs:140:22\n    |\n140 |         let parent = node1.borrow().parent.as_ref().unwrap();\n    |                      ^^^^^^^^^^^^^^                         - temporary value is freed at the end of this statement\n    |                      |\n    |                      creates a temporary value which is freed while still in use\n141 |         let mut parent_borrow_mut = parent.borrow_mut();\n    |                                     ------ borrow later used here\n    |\n",
        "rb_tree_insert_case2": "use std::cell::RefCell;\nuse std::rc::Rc;\n\npub enum RBTreeNodeColor {\n    RbTreeNodeRed,\n    RbTreeNodeBlack,\n}\n\nimpl Clone for RBTreeNodeColor {\n    fn clone(&self) -> Self {\n        match self {\n            RBTreeNodeColor::RbTreeNodeRed => RBTreeNodeColor::RbTreeNodeRed,\n            RBTreeNodeColor::RbTreeNodeBlack => RBTreeNodeColor::RbTreeNodeBlack,\n        }\n    }\n}\n\nimpl PartialEq for RBTreeNodeColor {\n    fn eq(&self, other: &Self) -> bool {\n        self == other\n    }\n}\n\npub enum RBTreeNodeSide {\n    RbTreeNodeLeft,\n    RbTreeNodeRight,\n}\n\nimpl PartialEq for RBTreeNodeSide {\n    fn eq(&self, other: &Self) -> bool {\n        self == other\n    }\n}\n\npub struct RBTreeNode<T> {\n    pub color: RBTreeNodeColor,\n    pub key: T,\n    pub value: T,\n    pub parent: Option<Rc<RefCell<RBTreeNode<T>>>>,\n    pub children: [Option<Rc<RefCell<RBTreeNode<T>>>>; 2],\n}\n\nimpl<T: Clone + PartialEq> Clone for RBTreeNode<T> {\n    fn clone(&self) -> Self {\n        RBTreeNode {\n            color: self.color.clone(),\n            key: self.key.clone(),\n            value: self.value.clone(),\n            parent: self.parent.clone(),\n            children: self.children.clone(),\n        }\n    }\n}\n\nimpl<T: PartialEq> PartialEq for RBTreeNode<T> {\n    fn eq(&self, other: &Self) -> bool {\n        self.key == other.key && self.value == other.value\n    }\n}\n\npub struct RBTree<T> {\n    pub root_node: Option<Rc<RefCell<RBTreeNode<T>>>>,\n    pub compare_func: fn(&T, &T) -> i32,\n    pub num_nodes: i32,\n}\n\npub fn rb_tree_insert_case2<T: Clone + PartialEq>(tree: &mut RBTree<T>, node: Rc<RefCell<RBTreeNode<T>>>) {\n    let parent = node.borrow().parent.as_ref().unwrap().clone();\n    if parent.borrow().color != RBTreeNodeColor::RbTreeNodeBlack {\n        rb_tree_insert_case3(tree, node);\n    }\n}\n\npub fn rb_tree_rotate<T: Clone + PartialEq>(tree: &mut RBTree<T>, node: Rc<RefCell<RBTreeNode<T>>>, direction: RBTreeNodeSide) -> Rc<RefCell<RBTreeNode<T>>> {\n    let mut node_borrow = node.borrow_mut();\n    let new_root_index = match direction {\n        RBTreeNodeSide::RbTreeNodeLeft => 1,\n        RBTreeNodeSide::RbTreeNodeRight => 0,\n    };\n    let new_root = node_borrow.children[new_root_index].as_ref().unwrap().clone();\n\n    rb_tree_node_replace(tree, node.clone(), Some(new_root.clone()));\n\n    node_borrow.children[new_root_index] = new_root.borrow().children[1 - new_root_index].clone();\n    new_root.borrow_mut().children[1 - new_root_index] = Some(node.clone());\n\n    node_borrow.parent = Some(new_root.clone());\n    if let Some(ref mut child) = node_borrow.children[new_root_index] {\n        child.borrow_mut().parent = Some(node.clone());\n    }\n\n    new_root\n}\n\npub fn rb_tree_insert_case3<T: Clone + PartialEq>(tree: &mut RBTree<T>, node: Rc<RefCell<RBTreeNode<T>>>) {\n    let parent = node.borrow().parent.as_ref().unwrap().clone();\n    let grandparent = parent.borrow().parent.as_ref().unwrap().clone();\n    let uncle = rb_tree_node_uncle(node.clone());\n\n    if let Some(ref uncle) = uncle {\n        if uncle.borrow().color == RBTreeNodeColor::RbTreeNodeRed {\n            parent.borrow_mut().color = RBTreeNodeColor::RbTreeNodeBlack;\n            uncle.borrow_mut().color = RBTreeNodeColor::RbTreeNodeBlack;\n            grandparent.borrow_mut().color = RBTreeNodeColor::RbTreeNodeRed;\n            rb_tree_insert_case1(tree, grandparent);\n        } else {\n            rb_tree_insert_case4(tree, node);\n        }\n    } else {\n        rb_tree_insert_case4(tree, node);\n    }\n}\n\npub fn rb_tree_node_replace<T: Clone + PartialEq>(tree: &mut RBTree<T>, node1: Rc<RefCell<RBTreeNode<T>>>, node2: Option<Rc<RefCell<RBTreeNode<T>>>>) {\n    if let Some(ref node2) = node2 {\n        node2.borrow_mut().parent = node1.borrow().parent.clone();\n    }\n\n    if let Some(ref parent) = node1.borrow().parent {\n        let side = rb_tree_node_side(node1.clone());\n        parent.borrow_mut().children[side as usize] = node2;\n    } else {\n        tree.root_node = node2;\n    }\n}\n\npub fn rb_tree_node_sibling<T: Clone + PartialEq>(node: Rc<RefCell<RBTreeNode<T>>>) -> Option<Rc<RefCell<RBTreeNode<T>>>> {\n    let side = rb_tree_node_side(node.clone());\n    node.borrow().parent.as_ref().and_then(|parent| parent.borrow().children[1 - side as usize].clone())\n}\n\npub fn rb_tree_node_uncle<T: Clone + PartialEq>(node: Rc<RefCell<RBTreeNode<T>>>) -> Option<Rc<RefCell<RBTreeNode<T>>>> {\n    rb_tree_node_sibling(node.borrow().parent.as_ref().unwrap().clone())\n}\n\npub fn rb_tree_insert_case4<T: Clone + PartialEq>(tree: &mut RBTree<T>, node: Rc<RefCell<RBTreeNode<T>>>) {\n    let parent = node.borrow().parent.as_ref().unwrap().clone();\n    let grandparent = parent.borrow().parent.as_ref().unwrap().clone();\n    let side = rb_tree_node_side(node.clone());\n\n    if side != rb_tree_node_side(parent.clone()) {\n        let next_node = parent.clone();\n        rb_tree_rotate(tree, parent, match side {\n            RBTreeNodeSide::RbTreeNodeLeft => RBTreeNodeSide::RbTreeNodeRight,\n            RBTreeNodeSide::RbTreeNodeRight => RBTreeNodeSide::RbTreeNodeLeft,\n        });\n        rb_tree_insert_case5(tree, next_node);\n    } else {\n        rb_tree_insert_case5(tree, node);\n    }\n}\n\npub fn rb_tree_insert_case1<T: Clone + PartialEq>(tree: &mut RBTree<T>, node: Rc<RefCell<RBTreeNode<T>>>) {\n    if node.borrow().parent.is_none() {\n        node.borrow_mut().color = RBTreeNodeColor::RbTreeNodeBlack;\n    } else {\n        rb_tree_insert_case2(tree, node);\n    }\n}\n\npub fn rb_tree_node_side<T: Clone + PartialEq>(node: Rc<RefCell<RBTreeNode<T>>>) -> RBTreeNodeSide {\n    let parent = node.borrow().parent.as_ref().unwrap().clone();\n    if parent.borrow().children[0].as_ref().map_or(false, |child| Rc::ptr_eq(child, &node)) {\n        RBTreeNodeSide::RbTreeNodeLeft\n    } else {\n        RBTreeNodeSide::RbTreeNodeRight\n    }\n}\n\npub fn rb_tree_insert_case5<T: Clone + PartialEq>(tree: &mut RBTree<T>, node: Rc<RefCell<RBTreeNode<T>>>) {\n    let parent = node.borrow().parent.as_ref().unwrap().clone();\n    let grandparent = parent.borrow().parent.as_ref().unwrap().clone();\n    let side = rb_tree_node_side(node.clone());\n\n    rb_tree_rotate(tree, grandparent, match side {\n        RBTreeNodeSide::RbTreeNodeLeft => RBTreeNodeSide::RbTreeNodeRight,\n        RBTreeNodeSide::RbTreeNodeRight => RBTreeNodeSide::RbTreeNodeLeft,\n    });\n\n    parent.borrow_mut().color = RBTreeNodeColor::RbTreeNodeBlack;\n    grandparent.borrow_mut().color = RBTreeNodeColor::RbTreeNodeRed;\n}\n\nfn main(){}\n //编译报错信息：warning: unused variable: `grandparent`\n   --> ../tmp/temp.rs:138:9\n    |\n138 |     let grandparent = parent.borrow().parent.as_ref().unwrap().clone();\n    |         ^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_grandparent`\n    |\n"
    },
    "test-rb-tree": {
        "test_rb_tree_insert_lookup": "use std::rc::Rc;\nuse std::cell::RefCell;\n\npub enum RBTreeNodeColor {\n    Red,\n    Black,\n}\n\nimpl PartialEq for RBTreeNodeColor {\n    fn eq(&self, other: &Self) -> bool {\n        match (self, other) {\n            (RBTreeNodeColor::Red, RBTreeNodeColor::Red) => true,\n            (RBTreeNodeColor::Black, RBTreeNodeColor::Black) => true,\n            _ => false,\n        }\n    }\n}\n\nimpl Clone for RBTreeNodeColor {\n    fn clone(&self) -> Self {\n        match self {\n            RBTreeNodeColor::Red => RBTreeNodeColor::Red,\n            RBTreeNodeColor::Black => RBTreeNodeColor::Black,\n        }\n    }\n}\n\npub enum RBTreeNodeSide {\n    Left,\n    Right,\n}\n\nimpl PartialEq for RBTreeNodeSide {\n    fn eq(&self, other: &Self) -> bool {\n        match (self, other) {\n            (RBTreeNodeSide::Left, RBTreeNodeSide::Left) => true,\n            (RBTreeNodeSide::Right, RBTreeNodeSide::Right) => true,\n            _ => false,\n        }\n    }\n}\n\npub struct RBTreeNode<T: Clone + PartialEq> {\n    pub color: RBTreeNodeColor,\n    pub key: T,\n    pub value: T,\n    pub parent: Option<Rc<RefCell<RBTreeNode<T>>>>,\n    pub children: [Option<Rc<RefCell<RBTreeNode<T>>>>; 2],\n}\n\nimpl<T: Clone + PartialEq> Clone for RBTreeNode<T> {\n    fn clone(&self) -> Self {\n        RBTreeNode {\n            color: self.color.clone(),\n            key: self.key.clone(),\n            value: self.value.clone(),\n            parent: self.parent.clone(),\n            children: self.children.clone(),\n        }\n    }\n}\n\npub struct RBTree<T: Clone + PartialEq> {\n    pub root_node: Option<Rc<RefCell<RBTreeNode<T>>>>,\n    pub compare_func: fn(&T, &T) -> i32,\n    pub num_nodes: i32,\n}\n\npub const NUM_TEST_VALUES: usize = 1000;\n\npub fn rb_tree_num_entries<T: Clone + PartialEq>(tree: &RBTree<T>) -> i32 {\n    tree.num_nodes\n}\n\npub fn validate_tree<T: Clone + PartialEq>(tree: &RBTree<T>) {\n}\n\nfn rb_tree_node_sibling<T: Clone + PartialEq>(node: Rc<RefCell<RBTreeNode<T>>>) -> Option<Rc<RefCell<RBTreeNode<T>>>> {\n    let side = rb_tree_node_side(node.clone());\n\n    match side {\n        RBTreeNodeSide::Left => node.borrow().parent.as_ref().and_then(|parent| parent.borrow().children[1].clone()),\n        RBTreeNodeSide::Right => node.borrow().parent.as_ref().and_then(|parent| parent.borrow().children[0].clone()),\n    }\n}\n\npub fn find_subtree_height<T: Clone + PartialEq>(node: Option<Rc<RefCell<RBTreeNode<T>>>>) -> i32 {\n    if let Some(n) = node {\n        let left_subtree = rb_tree_node_child(&n.borrow(), RBTreeNodeSide::Left);\n        let right_subtree = rb_tree_node_child(&n.borrow(), RBTreeNodeSide::Right);\n        let left_height = find_subtree_height(left_subtree);\n        let right_height = find_subtree_height(right_subtree);\n\n        if left_height > right_height {\n            return left_height + 1;\n        } else {\n            return right_height + 1;\n        }\n    } else {\n        return 0;\n    }\n}\n\npub fn rb_tree_new<T: Clone + PartialEq>(compare_func: fn(&T, &T) -> i32) -> Option<RBTree<T>> {\n    let mut new_tree = RBTree {\n        root_node: None,\n        compare_func,\n        num_nodes: 0,\n    };\n\n    Some(new_tree)\n}\n\npub fn rb_tree_node_child<T: Clone + PartialEq>(node: &RBTreeNode<T>, side: RBTreeNodeSide) -> Option<Rc<RefCell<RBTreeNode<T>>>> {\n    if side == RBTreeNodeSide::Left || side == RBTreeNodeSide::Right {\n        return node.children[side as usize].clone();\n    } else {\n        return None;\n    }\n}\n\npub fn rb_tree_free_subtree<T: Clone + PartialEq>(node: Option<Rc<RefCell<RBTreeNode<T>>>>) {\n    if let Some(n) = node {\n        rb_tree_free_subtree(n.borrow().children[RBTreeNodeSide::Left as usize].clone());\n        rb_tree_free_subtree(n.borrow().children[RBTreeNodeSide::Right as usize].clone());\n    }\n}\n\npub fn rb_tree_root_node<T: Clone + PartialEq>(tree: &RBTree<T>) -> Option<Rc<RefCell<RBTreeNode<T>>>> {\n    tree.root_node.clone()\n}\n\npub fn rb_tree_lookup_node<T: Clone + PartialEq>(tree: &RBTree<T>, key: T) -> Option<Rc<RefCell<RBTreeNode<T>>>> {\n    let mut node = tree.root_node.clone();\n    let mut diff: i32;\n\n    while let Some(current_node) = node {\n        let current_node_borrow = current_node.borrow();\n        diff = (tree.compare_func)(&key, &current_node_borrow.key);\n\n        if diff == 0 {\n            return Some(current_node.clone());\n        } else if diff < 0 {\n            node = current_node_borrow.children[0].clone();\n        } else {\n            node = current_node_borrow.children[1].clone();\n        }\n    }\n\n    None\n}\n\npub fn rb_tree_node_replace<T: Clone + PartialEq>(tree: &mut RBTree<T>, node1: Rc<RefCell<RBTreeNode<T>>>, node2: Option<Rc<RefCell<RBTreeNode<T>>>>) {\n    if let Some(ref node2) = node2 {\n        node2.borrow_mut().parent = node1.borrow().parent.clone();\n    }\n\n    if node1.borrow().parent.is_none() {\n        tree.root_node = node2;\n    } else {\n        let side = rb_tree_node_side(node1.clone());\n        node1.borrow().parent.as_ref().unwrap().borrow_mut().children[side as usize] = node2;\n    }\n}\n\npub fn test_rb_tree_insert_lookup() {\n    let mut tree = rb_tree_new(|a: &i32, b: &i32| a.cmp(b) as i32).unwrap();\n    let mut test_values = [0; NUM_TEST_VALUES];\n\n    for i in 0..NUM_TEST_VALUES {\n        test_values[i] = i as i32;\n        rb_tree_insert(&mut tree, test_values[i], test_values[i]);\n        assert_eq!(rb_tree_num_entries(&tree), i as i32 + 1);\n        validate_tree(&tree);\n    }\n\n    assert!(rb_tree_root_node(&tree).is_some());\n\n    for i in 0..NUM_TEST_VALUES {\n        let node = rb_tree_lookup_node(&tree, i as i32);\n        assert!(node.is_some());\n        let node = node.unwrap();\n        let key = rb_tree_node_key(&node.borrow());\n        assert_eq!(key, i as i32);\n        let value = rb_tree_node_value(node);\n        assert_eq!(value, i as i32);\n    }\n\n    let i = -1;\n    assert!(rb_tree_lookup_node(&tree, i).is_none());\n    let i = NUM_TEST_VALUES as i32 + 100;\n    assert!(rb_tree_lookup_node(&tree, i).is_none());\n\n    rb_tree_free(&mut tree);\n}\n\nfn main() {}\n\npub fn rb_tree_node_value<T: Clone + PartialEq>(node: Rc<RefCell<RBTreeNode<T>>>) -> T {\n    node.borrow().value.clone()\n}\n\npub fn rb_tree_node_key<T: Clone + PartialEq>(node: &RBTreeNode<T>) -> T {\n    node.key.clone()\n}\n\npub fn rb_tree_insert_case4<T: Clone + PartialEq>(tree: &mut RBTree<T>, node: Rc<RefCell<RBTreeNode<T>>>) {\n    let mut next_node = node.clone();\n    let side = rb_tree_node_side(node.clone());\n\n    if side != rb_tree_node_side(node.borrow().parent.as_ref().unwrap().clone()) {\n        next_node = node.borrow().parent.as_ref().unwrap().clone();\n        rb_tree_rotate(tree, next_node.clone(), 1 - side as usize);\n    }\n\n    rb_tree_insert_case5(tree, next_node);\n}\n\npub fn rb_tree_free<T: Clone + PartialEq>(tree: &mut RBTree<T>) {\n    rb_tree_free_subtree(tree.root_node.take());\n}\n\npub fn rb_tree_insert_case3<T: Clone + PartialEq>(tree: &mut RBTree<T>, node: Rc<RefCell<RBTreeNode<T>>>) {\n    let grandparent = node.borrow().parent.as_ref().unwrap().borrow().parent.as_ref().unwrap().clone();\n    let uncle = rb_tree_node_uncle(node.clone());\n\n    if let Some(uncle) = uncle {\n        if uncle.borrow().color == RBTreeNodeColor::Red {\n            node.borrow_mut().parent.as_ref().unwrap().borrow_mut().color = RBTreeNodeColor::Black;\n            uncle.borrow_mut().color = RBTreeNodeColor::Black;\n            grandparent.borrow_mut().color = RBTreeNodeColor::Red;\n\n            rb_tree_insert_case1(tree, grandparent);\n        } else {\n            rb_tree_insert_case4(tree, node);\n        }\n    } else {\n        rb_tree_insert_case4(tree, node);\n    }\n}\n\npub fn rb_tree_insert_case5<T: Clone + PartialEq>(tree: &mut RBTree<T>, node: Rc<RefCell<RBTreeNode<T>>>) {\n    let parent = node.borrow().parent.as_ref().unwrap().clone();\n    let grandparent = parent.borrow().parent.as_ref().unwrap().clone();\n    let side = rb_tree_node_side(node.clone());\n\n    rb_tree_rotate(tree, grandparent.clone(), 1 - side as usize);\n\n    parent.borrow_mut().color = RBTreeNodeColor::Black;\n    grandparent.borrow_mut().color = RBTreeNodeColor::Red;\n}\n\npub fn rb_tree_insert_case1<T: Clone + PartialEq>(tree: &mut RBTree<T>, node: Rc<RefCell<RBTreeNode<T>>>) {\n    if node.borrow().parent.is_none() {\n        node.borrow_mut().color = RBTreeNodeColor::Black;\n    } else {\n        rb_tree_insert_case2(tree, node);\n    }\n}\n\npub fn rb_tree_rotate<T: Clone + PartialEq>(tree: &mut RBTree<T>, node: Rc<RefCell<RBTreeNode<T>>>, direction: usize) -> Rc<RefCell<RBTreeNode<T>>> {\n    let new_root = node.borrow().children[1 - direction].as_ref().unwrap().clone();\n\n    rb_tree_node_replace(tree, node.clone(), Some(new_root.clone()));\n\n    node.borrow_mut().children[1 - direction] = new_root.borrow().children[direction].clone();\n    new_root.borrow_mut().children[direction] = Some(node.clone());\n\n    node.borrow_mut().parent = Some(new_root.clone());\n\n    if let Some(ref mut child) = node.borrow_mut().children[1 - direction] {\n        child.borrow_mut().parent = Some(node.clone());\n    }\n\n    new_root\n}\n\npub fn rb_tree_insert_case2<T: Clone + PartialEq>(tree: &mut RBTree<T>, node: Rc<RefCell<RBTreeNode<T>>>) {\n    if node.borrow().parent.as_ref().unwrap().borrow().color != RBTreeNodeColor::Black {\n        rb_tree_insert_case3(tree, node);\n    }\n}\n\npub fn rb_tree_insert<T: Clone + PartialEq>(tree: &mut RBTree<T>, key: T, value: T) -> Option<Rc<RefCell<RBTreeNode<T>>>> {\n    let node = Rc::new(RefCell::new(RBTreeNode {\n        color: RBTreeNodeColor::Red,\n        key: key.clone(),\n        value: value.clone(),\n        parent: None,\n        children: [None, None],\n    }));\n\n    let mut parent = None;\n    let mut rover = tree.root_node.clone();\n\n    while let Some(current_node) = rover {\n        parent = Some(current_node.clone());\n        let side = if (tree.compare_func)(&value, &current_node.borrow().value) < 0 {\n            RBTreeNodeSide::Left\n        } else {\n            RBTreeNodeSide::Right\n        };\n        rover = current_node.borrow().children[side as usize].clone();\n    }\n\n    if let Some(parent_node) = parent {\n        node.borrow_mut().parent = Some(parent_node.clone());\n        parent_node.borrow_mut().children[rb_tree_node_side(node.clone()) as usize] = Some(node.clone());\n    } else {\n        tree.root_node = Some(node.clone());\n    }\n\n    rb_tree_insert_case1(tree, node.clone());\n\n    tree.num_nodes += 1;\n\n    Some(node)\n}\n\nfn rb_tree_node_uncle<T: Clone + PartialEq>(node: Rc<RefCell<RBTreeNode<T>>>) -> Option<Rc<RefCell<RBTreeNode<T>>>> {\n    rb_tree_node_sibling(node.clone())\n}\n\nfn rb_tree_node_side<T: Clone + PartialEq>(node: Rc<RefCell<RBTreeNode<T>>>) -> RBTreeNodeSide {\n    if let Some(parent) = node.borrow().parent.clone() {\n        if parent.borrow().children[0].as_ref().map_or(false, |left_child| Rc::ptr_eq(&left_child, &node)) {\n            return RBTreeNodeSide::Left;\n        } else {\n            return RBTreeNodeSide::Right;\n        }\n    }\n    panic!(\"Node does not have a parent\");\n}\n //编译报错信息："
    },
    "test-avl-tree": {
        "validate_subtree": "use std::rc::{Rc, Weak};\n\npub fn avl_tree_subtree_height<T>(node: &Option<Box<AVLTreeNode<T>>>) -> i32 {\n    if let Some(n) = node {\n        n.height\n    } else {\n        0\n    }\n}\n\npub enum AVLTreeNodeSide {\n    AvlTreeNodeLeft,\n    AvlTreeNodeRight,\n}\n\npub struct AVLTreeNode<T> {\n    pub children: [Option<Box<AVLTreeNode<T>>>; 2],\n    pub parent: Option<Weak<AVLTreeNode<T>>>,\n    pub key: T,\n    pub value: T,\n    pub height: i32,\n}\n\nimpl<T: Clone> Clone for AVLTreeNode<T> {\n    fn clone(&self) -> Self {\n        AVLTreeNode {\n            children: self.children.clone(),\n            parent: self.parent.clone(),\n            key: self.key.clone(),\n            value: self.value.clone(),\n            height: self.height,\n        }\n    }\n}\n\npub struct AVLTree<T> {\n    pub root_node: Option<Box<AVLTreeNode<T>>>,\n    pub compare_func: fn(T, T) -> i32,\n    pub num_nodes: u32,\n}\n\npub fn avl_tree_node_child<T>(node: &AVLTreeNode<T>, side: AVLTreeNodeSide) -> &Option<Box<AVLTreeNode<T>>> {\n    match side {\n        AVLTreeNodeSide::AvlTreeNodeLeft => &node.children[0],\n        AVLTreeNodeSide::AvlTreeNodeRight => &node.children[1],\n    }\n}\n\npub fn validate_subtree<T: Ord + Clone>(node: &Option<Box<AVLTreeNode<T>>>, counter: &mut T) -> i32 {\n    if let Some(n) = node {\n        let mut left_height = 0;\n        let mut right_height = 0;\n\n        let left_node = avl_tree_node_child(n, AVLTreeNodeSide::AvlTreeNodeLeft);\n        let right_node = avl_tree_node_child(n, AVLTreeNodeSide::AvlTreeNodeRight);\n\n        if let Some(ln) = left_node {\n            assert_eq!(avl_tree_node_parent(ln).map(|p| p.as_ref()), Some(Rc::as_ptr(n)));\n        }\n        if let Some(rn) = right_node {\n            assert_eq!(avl_tree_node_parent(rn).map(|p| p.as_ref()), Some(Rc::as_ptr(n)));\n        }\n\n        left_height = validate_subtree(left_node, counter);\n\n        let key = avl_tree_node_key(n);\n\n        assert!(key > counter);\n        *counter = key.clone();\n\n        right_height = validate_subtree(right_node, counter);\n\n        assert_eq!(avl_tree_subtree_height(left_node), left_height);\n        assert_eq!(avl_tree_subtree_height(right_node), right_height);\n\n        assert!((left_height - right_height).abs() < 2);\n\n        if left_height > right_height {\n            return left_height + 1;\n        } else {\n            return right_height + 1;\n        }\n    } else {\n        return 0;\n    }\n}\n\npub fn avl_tree_node_parent<T>(node: &AVLTreeNode<T>) -> Option<Rc<AVLTreeNode<T>>> {\n    node.parent.as_ref().and_then(|p| p.upgrade())\n}\n\npub fn avl_tree_node_key<T>(node: &AVLTreeNode<T>) -> &T {\n    &node.key\n}\n\nfn main(){}\n //编译报错信息：error[E0308]: mismatched types\n    --> ../tmp/temp.rs:58:86\n     |\n58   |             assert_eq!(avl_tree_node_parent(ln).map(|p| p.as_ref()), Some(Rc::as_ptr(n)));\n     |                                                                           ---------- ^ expected `&Rc<_, _>`, found `&Box<AVLTreeNode<T>>`\n     |                                                                           |\n     |                                                                           arguments to this function are incorrect\n     |\n     = note: expected reference `&Rc<_, _>`\n                found reference `&Box<AVLTreeNode<T>>`\nnote: associated function defined here\n    --> /home/mins01/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/rc.rs:1459:12\n     |\n1459 |     pub fn as_ptr(this: &Self) -> *const T {\n     |            ^^^^^^\n\nerror[E0369]: binary operation `==` cannot be applied to type `Option<&AVLTreeNode<T>>`\n   --> ../tmp/temp.rs:58:13\n    |\n58  |             assert_eq!(avl_tree_node_parent(ln).map(|p| p.as_ref()), Some(Rc::as_ptr(n)));\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |             |\n    |             Option<&AVLTreeNode<T>>\n    |             Option<*const _>\n    |\nnote: the foreign item type `Option<&AVLTreeNode<T>>` doesn't implement `PartialEq<Option<*const _>>`\n   --> /home/mins01/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:572:1\n    |\n572 | pub enum Option<T> {\n    | ^^^^^^^^^^^^^^^^^^ not implement `PartialEq<Option<*const _>>`\n",
        "create_tree": "pub fn avl_tree_insert<T: Clone + PartialOrd>(tree: &mut AVLTree<T>, key: T, value: T) -> Option<Box<AVLTreeNode<T>>> {\n    let mut rover = &mut tree.root_node;\n    let mut previous_node = None;\n\n    while let Some(node) = rover {\n        previous_node = Some(Rc::new(RefCell::new(*node.clone())));\n        if (tree.compare_func)(key.clone(), node.key.clone()) < 0 {\n            rover = &mut node.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize];\n        } else {\n            rover = &mut node.children[AVLTreeNodeSide::AvlTreeNodeRight as usize];\n        }\n    }\n\n    let new_node = Box::new(AVLTreeNode {\n        children: [None, None],\n        parent: previous_node.clone(),\n        key,\n        value,\n        height: 1,\n    });\n\n    *rover = Some(new_node.clone());\n\n    if let Some(previous) = previous_node {\n        avl_tree_balance_to_root(tree, &mut *previous.borrow_mut());\n    }\n\n    tree.num_nodes += 1;\n\n    Some(new_node)\n}\n\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\npub enum AVLTreeNodeSide {\n    AvlTreeNodeLeft,\n    AvlTreeNodeRight,\n}\n\nimpl Clone for AVLTreeNodeSide {\n    fn clone(&self) -> Self {\n        match self {\n            AVLTreeNodeSide::AvlTreeNodeLeft => AVLTreeNodeSide::AvlTreeNodeLeft,\n            AVLTreeNodeSide::AvlTreeNodeRight => AVLTreeNodeSide::AvlTreeNodeRight,\n        }\n    }\n}\n\npub struct AVLTreeNode<T> {\n    pub children: [Option<Box<AVLTreeNode<T>>>; 2],\n    pub parent: Option<Rc<RefCell<AVLTreeNode<T>>>>,\n    pub key: T,\n    pub value: T,\n    pub height: i32,\n}\n\nimpl<T: Clone> Clone for AVLTreeNode<T> {\n    fn clone(&self) -> Self {\n        AVLTreeNode {\n            children: self.children.clone(),\n            parent: self.parent.clone(),\n            key: self.key.clone(),\n            value: self.value.clone(),\n            height: self.height,\n        }\n    }\n}\n\npub struct AVLTree<T> {\n    pub root_node: Option<Box<AVLTreeNode<T>>>, \n    pub compare_func: fn(T, T) -> i32,\n    pub num_nodes: u32,\n}\n\npub fn avl_tree_update_height<T>(node: &mut AVLTreeNode<T>) {\n    let left_height = avl_tree_subtree_height(&node.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize]);\n    let right_height = avl_tree_subtree_height(&node.children[AVLTreeNodeSide::AvlTreeNodeRight as usize]);\n\n    if left_height > right_height {\n        node.height = left_height + 1;\n    } else {\n        node.height = right_height + 1;\n    }\n}\n\npub fn avl_tree_rotate<T: Clone>(tree: &mut AVLTree<T>, node: &mut AVLTreeNode<T>, direction: AVLTreeNodeSide) -> Option<Box<AVLTreeNode<T>>> {\n    let direction_index = direction as usize;\n    let new_root = node.children[1 - direction_index].take();\n\n    if let Some(mut new_root) = new_root {\n        avl_tree_node_replace(tree, node, Some(&*new_root));\n\n        node.children[1 - direction_index] = new_root.children[direction_index].take();\n        new_root.children[direction_index] = Some(Box::new(node.clone()));\n\n        let node_clone = node.clone();\n        node.parent = Some(Rc::new(RefCell::new(*new_root.clone())));\n\n        if let Some(child) = node.children[1 - direction_index].as_mut() {\n            child.parent = Some(Rc::new(RefCell::new(node_clone)));\n        }\n\n        avl_tree_update_height(&mut *new_root);\n        avl_tree_update_height(node);\n\n        Some(new_root)\n    } else {\n        None\n    }\n}\n\npub fn avl_tree_node_balance<'a, T: Clone>(tree: &'a mut AVLTree<T>, node: &'a mut AVLTreeNode<T>) -> &'a mut AVLTreeNode<T> {\n    let left_subtree = &node.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize];\n    let right_subtree = &node.children[AVLTreeNodeSide::AvlTreeNodeRight as usize];\n    let diff = avl_tree_subtree_height(right_subtree) - avl_tree_subtree_height(left_subtree);\n\n    if diff >= 2 {\n        let child = node.children[AVLTreeNodeSide::AvlTreeNodeRight as usize].as_mut().unwrap();\n\n        if avl_tree_subtree_height(&child.children[AVLTreeNodeSide::AvlTreeNodeRight as usize])\n            < avl_tree_subtree_height(&child.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize]) {\n            avl_tree_rotate(tree, child, AVLTreeNodeSide::AvlTreeNodeRight);\n        }\n\n        let rotated_node = avl_tree_rotate(tree, node, AVLTreeNodeSide::AvlTreeNodeLeft).unwrap();\n        *node = *rotated_node;\n    } else if diff <= -2 {\n        let child = node.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize].as_mut().unwrap();\n\n        if avl_tree_subtree_height(&child.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize])\n            < avl_tree_subtree_height(&child.children[AVLTreeNodeSide::AvlTreeNodeRight as usize]) {\n            avl_tree_rotate(tree, child, AVLTreeNodeSide::AvlTreeNodeLeft);\n        }\n\n        let rotated_node = avl_tree_rotate(tree, node, AVLTreeNodeSide::AvlTreeNodeRight).unwrap();\n        *node = *rotated_node;\n    }\n\n    avl_tree_update_height(node);\n    node\n}\n\npub fn avl_tree_node_parent_side<T>(node: &AVLTreeNode<T>) -> AVLTreeNodeSide {\n    if let Some(parent) = &node.parent {\n        let parent_borrowed = parent.borrow();\n        if parent_borrowed.children[0].as_ref().map_or(false, |child| child.as_ref() as *const AVLTreeNode<T> == node) {\n            return AVLTreeNodeSide::AvlTreeNodeLeft;\n        } else if parent_borrowed.children[1].as_ref().map_or(false, |child| child.as_ref() as *const AVLTreeNode<T> == node) {\n            return AVLTreeNodeSide::AvlTreeNodeRight;\n        }\n    }\n    panic!(\"Node does not have a valid parent or is not a child of its parent\");\n}\n\npub fn avl_tree_node_replace<T: Clone>(tree: &mut AVLTree<T>, node1: &mut AVLTreeNode<T>, node2: Option<&AVLTreeNode<T>>) {\n    let side;\n\n    if let Some(node2) = node2 {\n        let node2_clone = node2.clone();\n        if let Some(parent) = node1.parent.clone() {\n            let mut parent_borrowed = parent.borrow_mut();\n            side = avl_tree_node_parent_side(node1);\n            parent_borrowed.children[side as usize] = Some(Box::new(node2_clone));\n\n            avl_tree_update_height(&mut *parent_borrowed);\n        }\n    }\n\n    if node1.parent.is_none() {\n        tree.root_node = node2.cloned().map(|n| Box::new(n));\n    }\n}\n\npub fn avl_tree_subtree_height<T>(node: &Option<Box<AVLTreeNode<T>>>) -> i32 {\n    if let Some(n) = node {\n        n.height\n    } else {\n        0\n    }\n}\n\npub fn avl_tree_new<T>(compare_func: fn(T, T) -> i32) -> Option<AVLTree<T>> {\n    let new_tree = AVLTree {\n        root_node: None,\n        compare_func,\n        num_nodes: 0,\n    };\n\n    Some(new_tree)\n}\n\npub fn avl_tree_balance_to_root<T: Clone>(tree: &mut AVLTree<T>, node: &mut AVLTreeNode<T>) {\n    let mut rover = Some(Rc::new(RefCell::new(node.clone())));\n\n    while let Some(current_rover) = rover {\n        let mut current_rover_borrowed = current_rover.borrow_mut();\n\n        let balanced_node = avl_tree_node_balance(tree, &mut *current_rover_borrowed);\n        rover = balanced_node.parent.clone();\n\n        rover = rover.map(|parent| Rc::clone(&parent));\n    }\n}\n\npub fn create_tree<T: Clone + PartialEq + From<usize>>(compare_func: fn(T, T) -> i32) -> Option<AVLTree<T>> {\n    let mut tree = avl_tree_new(compare_func)?;\n    let mut test_array: Vec<T> = Vec::new();\n\n    const NUM_TEST_VALUES: usize = 10;\n\n    for i in 0..NUM_TEST_VALUES {\n        let value = T::from(i);\n        test_array.push(value.clone());\n        avl_tree_insert(&mut tree, value.clone(), value.clone());\n    }\n\n    Some(tree)\n}\n\nfn main(){}\n //编译报错信息：error[E0277]: can't compare `T` with `T`\n   --> ../tmp/temp.rs:215:9\n    |\n215 |         avl_tree_insert(&mut tree, value.clone(), value.clone());\n    |         ^^^^^^^^^^^^^^^ no implementation for `T < T` and `T > T`\n    |\nnote: required by a bound in `avl_tree_insert`\n   --> ../tmp/temp.rs:1:35\n    |\n1   | pub fn avl_tree_insert<T: Clone + PartialOrd>(tree: &mut AVLTree<T>, key: T, value: T) -> Option<Box...\n    |                                   ^^^^^^^^^^ required by this bound in `avl_tree_insert`\n",
        "validate_tree": "use std::rc::Rc;\nuse std::cell::RefCell;\n\npub enum AVLTreeNodeSide {\n    AvlTreeNodeLeft,\n    AvlTreeNodeRight,\n}\n\nimpl Clone for AVLTreeNodeSide {\n    fn clone(&self) -> Self {\n        match self {\n            AVLTreeNodeSide::AvlTreeNodeLeft => AVLTreeNodeSide::AvlTreeNodeLeft,\n            AVLTreeNodeSide::AvlTreeNodeRight => AVLTreeNodeSide::AvlTreeNodeRight,\n        }\n    }\n}\n\npub struct AVLTreeNode<T> {\n    pub children: [Option<Box<AVLTreeNode<T>>>; 2],\n    pub parent: Option<Rc<RefCell<AVLTreeNode<T>>>>,\n    pub key: T,\n    pub value: T,\n    pub height: i32,\n}\n\nimpl<T: Clone + Eq> Clone for AVLTreeNode<T> {\n    fn clone(&self) -> Self {\n        AVLTreeNode {\n            children: self.children.clone(),\n            parent: self.parent.clone(),\n            key: self.key.clone(),\n            value: self.value.clone(),\n            height: self.height,\n        }\n    }\n}\n\npub struct AVLTree<T> {\n    pub root_node: Option<Box<AVLTreeNode<T>>>, \n    pub compare_func: fn(T, T) -> i32,\n    pub num_nodes: u32,\n}\n\npub fn avl_tree_node_key<T>(node: &AVLTreeNode<T>) -> &T {\n    &node.key\n}\n\npub fn avl_tree_root_node<T>(tree: &AVLTree<T>) -> &Option<Box<AVLTreeNode<T>>> {\n    &tree.root_node\n}\n\npub fn avl_tree_node_child<T>(node: &AVLTreeNode<T>, side: AVLTreeNodeSide) -> Option<&Box<AVLTreeNode<T>>> {\n    match side {\n        AVLTreeNodeSide::AvlTreeNodeLeft | AVLTreeNodeSide::AvlTreeNodeRight => node.children[side as usize].as_ref(),\n    }\n}\n\npub fn avl_tree_node_parent<T>(node: &AVLTreeNode<T>) -> Option<Rc<RefCell<AVLTreeNode<T>>>> {\n    node.parent.clone()\n}\n\npub fn avl_tree_subtree_height<T>(node: &Option<Box<AVLTreeNode<T>>>) -> i32 {\n    if let Some(n) = node {\n        n.height\n    } else {\n        0\n    }\n}\n\npub fn validate_tree<T: Clone + Eq>(tree: &AVLTree<T>) {\n    let root_node = avl_tree_root_node(tree);\n    let mut height = 0;\n\n    if let Some(node) = root_node {\n        height = find_subtree_height(node);\n        assert_eq!(avl_tree_subtree_height(root_node), height);\n    }\n\n    let mut counter = -1;\n    validate_subtree(root_node, &mut counter);\n}\n\npub fn validate_subtree<T: Clone + Eq>(node: &Option<Box<AVLTreeNode<T>>>, counter: &mut i32) -> i32 {\n    if let Some(node) = node {\n        let left_node = avl_tree_node_child(node, AVLTreeNodeSide::AvlTreeNodeLeft);\n        let right_node = avl_tree_node_child(node, AVLTreeNodeSide::AvlTreeNodeRight);\n\n        if let Some(left) = left_node {\n            assert_eq!(avl_tree_node_parent(left).unwrap().borrow().key, node.key);\n        }\n        if let Some(right) = right_node {\n            assert_eq!(avl_tree_node_parent(right).unwrap().borrow().key, node.key);\n        }\n\n        let left_height = validate_subtree(left_node, counter);\n        let key = avl_tree_node_key(node);\n\n        assert!(*key > *counter);\n        *counter = *key;\n\n        let right_height = validate_subtree(right_node, counter);\n\n        assert_eq!(avl_tree_subtree_height(left_node), left_height);\n        assert_eq!(avl_tree_subtree_height(right_node), right_height);\n\n        assert!((left_height - right_height).abs() < 2);\n\n        if left_height > right_height {\n            return left_height + 1;\n        } else {\n            return right_height + 1;\n        }\n    } else {\n        return 0;\n    }\n}\n\npub fn find_subtree_height<T: Clone + Eq>(node: &Box<AVLTreeNode<T>>) -> i32 {\n    let left_subtree = avl_tree_node_child(node, AVLTreeNodeSide::AvlTreeNodeLeft);\n    let right_subtree = avl_tree_node_child(node, AVLTreeNodeSide::AvlTreeNodeRight);\n    let left_height = if let Some(left) = left_subtree { find_subtree_height(left) } else { 0 };\n    let right_height = if let Some(right) = right_subtree { find_subtree_height(right) } else { 0 };\n\n    if left_height > right_height {\n        return left_height + 1;\n    } else {\n        return right_height + 1;\n    }\n}\n\nfn main(){}\n //编译报错信息：error[E0277]: `T` doesn't implement `Debug`\n  --> ../tmp/temp.rs:89:13\n   |\n89 |             assert_eq!(avl_tree_node_parent(left).unwrap().borrow().key, node.key);\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `T` cannot be formatted using `{:?}` because it doesn't implement `Debug`\n   |\n   = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n",
        "test_avl_tree_child": "use std::rc::Rc;\nuse std::cell::RefCell;\n\npub enum AVLTreeNodeSide {\n    AvlTreeNodeLeft,\n    AvlTreeNodeRight,\n}\n\nimpl Clone for AVLTreeNodeSide {\n    fn clone(&self) -> Self {\n        match self {\n            AVLTreeNodeSide::AvlTreeNodeLeft => AVLTreeNodeSide::AvlTreeNodeLeft,\n            AVLTreeNodeSide::AvlTreeNodeRight => AVLTreeNodeSide::AvlTreeNodeRight,\n        }\n    }\n}\n\npub struct AVLTreeNode<T> {\n    pub children: [Option<Box<AVLTreeNode<T>>>; 2],\n    pub parent: Option<Rc<RefCell<AVLTreeNode<T>>>>,\n    pub key: T,\n    pub value: T,\n    pub height: i32,\n}\n\nimpl<T: Clone> Clone for AVLTreeNode<T> {\n    fn clone(&self) -> Self {\n        AVLTreeNode {\n            children: self.children.clone(),\n            parent: self.parent.clone(),\n            key: self.key.clone(),\n            value: self.value.clone(),\n            height: self.height,\n        }\n    }\n}\n\npub struct AVLTree<T> {\n    pub root_node: Option<Box<AVLTreeNode<T>>>,\n    pub compare_func: fn(&T, &T) -> i32,\n    pub num_nodes: u32,\n}\n\npub fn avl_tree_node_value<T>(node: &AVLTreeNode<T>) -> &T {\n    &node.value\n}\n\npub fn avl_tree_insert<T: Clone>(tree: &mut AVLTree<T>, key: T, value: T) -> Option<Box<AVLTreeNode<T>>> {\n    let mut rover = &mut tree.root_node;\n    let mut previous_node = None;\n\n    while let Some(node) = rover {\n        previous_node = Some(Rc::new(RefCell::new(node.clone())));\n        if (tree.compare_func)(&key, &node.key) < 0 {\n            rover = &mut node.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize];\n        } else {\n            rover = &mut node.children[AVLTreeNodeSide::AvlTreeNodeRight as usize];\n        }\n    }\n\n    let new_node = Box::new(AVLTreeNode {\n        children: [None, None],\n        parent: previous_node.as_ref().map(|rc| Rc::new(RefCell::new(rc.borrow().clone()))),\n        key,\n        value,\n        height: 1,\n    });\n\n    *rover = Some(new_node.clone());\n\n    if let Some(previous) = previous_node {\n        avl_tree_balance_to_root(tree, &mut *previous.borrow_mut());\n    }\n\n    tree.num_nodes += 1;\n\n    Some(new_node)\n}\n\npub fn avl_tree_update_height<T>(node: &mut AVLTreeNode<T>) {\n    let left_height = avl_tree_subtree_height(&node.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize]);\n    let right_height = avl_tree_subtree_height(&node.children[AVLTreeNodeSide::AvlTreeNodeRight as usize]);\n\n    if left_height > right_height {\n        node.height = left_height + 1;\n    } else {\n        node.height = right_height + 1;\n    }\n}\n\npub fn avl_tree_rotate<T: Clone>(tree: &mut AVLTree<T>, node: &mut AVLTreeNode<T>, direction: AVLTreeNodeSide) -> Option<Box<AVLTreeNode<T>>> {\n    let direction_index = direction as usize;\n    let new_root = node.children[1 - direction_index].take();\n\n    if let Some(mut new_root) = new_root {\n        avl_tree_node_replace(tree, node, Some(&*new_root));\n\n        node.children[1 - direction_index] = new_root.children[direction_index].take();\n        new_root.children[direction_index] = Some(Box::new(node.clone()));\n\n        let node_clone = node.clone();\n        node.parent = Some(Rc::new(RefCell::new(*new_root.clone())));\n\n        if let Some(child) = node.children[1 - direction_index].as_mut() {\n            child.parent = Some(Rc::new(RefCell::new(node_clone)));\n        }\n\n        avl_tree_update_height(&mut *new_root);\n        avl_tree_update_height(node);\n\n        Some(new_root)\n    } else {\n        None\n    }\n}\n\npub fn avl_tree_node_balance<'a, T: Clone>(tree: &'a mut AVLTree<T>, node: &'a mut AVLTreeNode<T>) -> &'a mut AVLTreeNode<T> {\n    let left_subtree = &node.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize];\n    let right_subtree = &node.children[AVLTreeNodeSide::AvlTreeNodeRight as usize];\n    let diff = avl_tree_subtree_height(right_subtree) - avl_tree_subtree_height(left_subtree);\n\n    if diff >= 2 {\n        let child = node.children[AVLTreeNodeSide::AvlTreeNodeRight as usize].as_mut().unwrap();\n\n        if avl_tree_subtree_height(&child.children[AVLTreeNodeSide::AvlTreeNodeRight as usize])\n            < avl_tree_subtree_height(&child.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize]) {\n            avl_tree_rotate(tree, child, AVLTreeNodeSide::AvlTreeNodeRight);\n        }\n\n        let rotated_node = avl_tree_rotate(tree, node, AVLTreeNodeSide::AvlTreeNodeLeft).unwrap();\n        *node = *rotated_node;\n    } else if diff <= -2 {\n        let child = node.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize].as_mut().unwrap();\n\n        if avl_tree_subtree_height(&child.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize])\n            < avl_tree_subtree_height(&child.children[AVLTreeNodeSide::AvlTreeNodeRight as usize]) {\n            avl_tree_rotate(tree, child, AVLTreeNodeSide::AvlTreeNodeLeft);\n        }\n\n        let rotated_node = avl_tree_rotate(tree, node, AVLTreeNodeSide::AvlTreeNodeRight).unwrap();\n        *node = *rotated_node;\n    }\n\n    avl_tree_update_height(node);\n    node\n}\n\npub fn avl_tree_node_parent_side<T>(node: &AVLTreeNode<T>) -> AVLTreeNodeSide {\n    if let Some(parent) = &node.parent {\n        let parent_borrowed = parent.borrow();\n        if parent_borrowed.children[0].as_ref().map_or(false, |child| child.as_ref() as *const AVLTreeNode<T> == node) {\n            return AVLTreeNodeSide::AvlTreeNodeLeft;\n        } else if parent_borrowed.children[1].as_ref().map_or(false, |child| child.as_ref() as *const AVLTreeNode<T> == node) {\n            return AVLTreeNodeSide::AvlTreeNodeRight;\n        }\n    }\n    panic!(\"Node does not have a valid parent or is not a child of its parent\");\n}\n\npub fn avl_tree_root_node<T>(tree: &AVLTree<T>) -> Option<&Box<AVLTreeNode<T>>> {\n    tree.root_node.as_ref()\n}\n\npub fn avl_tree_node_child<T>(node: &AVLTreeNode<T>, side: AVLTreeNodeSide) -> Option<&Box<AVLTreeNode<T>>> {\n    match side {\n        AVLTreeNodeSide::AvlTreeNodeLeft | AVLTreeNodeSide::AvlTreeNodeRight => node.children[side as usize].as_ref(),\n    }\n}\n\npub fn avl_tree_free_subtree<T>(node: Option<Box<AVLTreeNode<T>>>) {\n    if let Some(mut n) = node {\n        avl_tree_free_subtree(n.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize].take());\n        avl_tree_free_subtree(n.children[AVLTreeNodeSide::AvlTreeNodeRight as usize].take());\n    }\n}\n\npub fn avl_tree_node_replace<T: Clone>(tree: &mut AVLTree<T>, node1: &mut AVLTreeNode<T>, node2: Option<&AVLTreeNode<T>>) {\n    let side;\n\n    if let Some(node2) = node2 {\n        let node2_clone = node2.clone();\n        if let Some(parent) = node1.parent.clone() {\n            let mut parent_borrowed = parent.borrow_mut();\n            side = avl_tree_node_parent_side(node1);\n            parent_borrowed.children[side as usize] = Some(Box::new(node2_clone));\n\n            avl_tree_update_height(&mut *parent_borrowed);\n        }\n    }\n\n    if node1.parent.is_none() {\n        tree.root_node = node2.cloned().map(|n| Box::new(n));\n    }\n}\n\npub fn avl_tree_subtree_height<T>(node: &Option<Box<AVLTreeNode<T>>>) -> i32 {\n    if let Some(n) = node {\n        n.height\n    } else {\n        0\n    }\n}\n\npub fn avl_tree_new<T>(compare_func: fn(&T, &T) -> i32) -> AVLTree<T> {\n    AVLTree {\n        root_node: None,\n        compare_func,\n        num_nodes: 0,\n    }\n}\n\npub fn avl_tree_free<T>(tree: &mut AVLTree<T>) {\n    avl_tree_free_subtree(tree.root_node.take());\n}\n\npub fn avl_tree_balance_to_root<T: Clone>(tree: &mut AVLTree<T>, node: &mut AVLTreeNode<T>) {\n    let mut rover = Some(Rc::new(RefCell::new(node.clone())));\n\n    while let Some(current_rover) = rover {\n        let mut current_rover_borrowed = current_rover.borrow_mut();\n\n        // Balance this node if necessary\n        let balanced_node = avl_tree_node_balance(tree, &mut *current_rover_borrowed);\n        rover = balanced_node.parent.clone();\n\n        // Go to this node's parent\n        rover = rover.map(|parent| Rc::clone(&parent));\n    }\n}\n\npub fn test_avl_tree_child() {\n    let mut tree = avl_tree_new(|a: &i32, b: &i32| a.cmp(b) as i32);\n    let values = [1, 2, 3];\n    let mut i = 0;\n\n    while i < 3 {\n        avl_tree_insert(&mut tree, values[i], values[i]);\n        i += 1;\n    }\n\n    let root = avl_tree_root_node(&tree).unwrap();\n    assert_eq!(*avl_tree_node_value(root), 2);\n\n    let left = avl_tree_node_child(root, AVLTreeNodeSide::AvlTreeNodeLeft).unwrap();\n    assert_eq!(*avl_tree_node_value(left), 1);\n\n    let right = avl_tree_node_child(root, AVLTreeNodeSide::AvlTreeNodeRight).unwrap();\n    assert_eq!(*avl_tree_node_value(right), 3);\n\n    assert!(avl_tree_node_child(root, AVLTreeNodeSide::AvlTreeNodeLeft).is_some());\n    assert!(avl_tree_node_child(root, AVLTreeNodeSide::AvlTreeNodeRight).is_some());\n\n    avl_tree_free(&mut tree);\n}\n\nfn main() {}\n //编译报错信息：error[E0308]: mismatched types\n  --> ../tmp/temp.rs:63:17\n   |\n63 |         parent: previous_node.as_ref().map(|rc| Rc::new(RefCell::new(rc.borrow().clone()))),\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `AVLTreeNode<_>`, found `Box<AVLTreeNode<T>>`\n   |\n   = note: expected enum `Option<Rc<RefCell<AVLTreeNode<_>>>>`\n              found enum `Option<Rc<RefCell<Box<AVLTreeNode<T>>>>>`\n\nerror: aborting due to 1 previous error\n\nFor more information about this error, try `rustc --explain E0308`.\n",
        "test_avl_tree_insert_lookup": "use std::rc::Rc;\nuse std::cell::RefCell;\n\npub enum AVLTreeNodeSide {\n    AvlTreeNodeLeft,\n    AvlTreeNodeRight,\n}\n\nimpl Clone for AVLTreeNodeSide {\n    fn clone(&self) -> Self {\n        match self {\n            AVLTreeNodeSide::AvlTreeNodeLeft => AVLTreeNodeSide::AvlTreeNodeLeft,\n            AVLTreeNodeSide::AvlTreeNodeRight => AVLTreeNodeSide::AvlTreeNodeRight,\n        }\n    }\n}\n\npub struct AVLTreeNode<T> {\n    pub children: [Option<Box<AVLTreeNode<T>>>; 2],\n    pub parent: Option<Rc<RefCell<AVLTreeNode<T>>>>,\n    pub key: T,\n    pub value: T,\n    pub height: i32,\n}\n\nimpl<T: Clone> Clone for AVLTreeNode<T> {\n    fn clone(&self) -> Self {\n        AVLTreeNode {\n            children: self.children.clone(),\n            parent: self.parent.clone(),\n            key: self.key.clone(),\n            value: self.value.clone(),\n            height: self.height,\n        }\n    }\n}\n\npub struct AVLTree<T> {\n    pub root_node: Option<Box<AVLTreeNode<T>>>, \n    pub compare_func: fn(T, T) -> i32,\n    pub num_nodes: u32,\n}\n\npub fn avl_tree_insert<T: Clone>(tree: &mut AVLTree<T>, key: T, value: T) -> Option<Box<AVLTreeNode<T>>> {\n    let mut rover = &mut tree.root_node;\n    let mut previous_node = None;\n\n    while let Some(node) = rover {\n        previous_node = Some(Rc::new(RefCell::new(node.clone())));\n        if (tree.compare_func)(key.clone(), node.key.clone()) < 0 {\n            rover = &mut node.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize];\n        } else {\n            rover = &mut node.children[AVLTreeNodeSide::AvlTreeNodeRight as usize];\n        }\n    }\n\n    let new_node = Box::new(AVLTreeNode {\n        children: [None, None],\n        parent: previous_node.clone(),\n        key,\n        value,\n        height: 1,\n    });\n\n    *rover = Some(new_node.clone());\n\n    if let Some(previous) = previous_node {\n        avl_tree_balance_to_root(tree, &mut *previous.borrow_mut());\n    }\n\n    tree.num_nodes += 1;\n\n    Some(new_node)\n}\n\npub fn avl_tree_node_key<T>(node: &AVLTreeNode<T>) -> &T {\n    &node.key\n}\n\npub fn avl_tree_rotate<T: Clone>(tree: &mut AVLTree<T>, node: &mut AVLTreeNode<T>, direction: AVLTreeNodeSide) -> Option<Box<AVLTreeNode<T>>> {\n    let direction_index = direction as usize;\n    let new_root = node.children[1 - direction_index].take();\n\n    if let Some(mut new_root) = new_root {\n        avl_tree_node_replace(tree, node, Some(&*new_root));\n\n        node.children[1 - direction_index] = new_root.children[direction_index].take();\n        new_root.children[direction_index] = Some(Box::new(node.clone()));\n\n        let node_clone = node.clone();\n        node.parent = Some(Rc::new(RefCell::new(*new_root.clone())));\n\n        if let Some(child) = node.children[1 - direction_index].as_mut() {\n            child.parent = Some(Rc::new(RefCell::new(node_clone)));\n        }\n\n        avl_tree_update_height(&mut *new_root);\n        avl_tree_update_height(node);\n\n        Some(new_root)\n    } else {\n        None\n    }\n}\n\npub fn avl_tree_node_child<T>(node: &AVLTreeNode<T>, side: AVLTreeNodeSide) -> Option<&Box<AVLTreeNode<T>>> {\n    match side {\n        AVLTreeNodeSide::AvlTreeNodeLeft | AVLTreeNodeSide::AvlTreeNodeRight => node.children[side as usize].as_ref(),\n    }\n}\n\npub fn avl_tree_subtree_height<T>(node: &Option<Box<AVLTreeNode<T>>>) -> i32 {\n    if let Some(n) = node {\n        n.height\n    } else {\n        0\n    }\n}\n\npub fn avl_tree_balance_to_root<T: Clone>(tree: &mut AVLTree<T>, node: &mut AVLTreeNode<T>) {\n    let mut rover = Some(Rc::new(RefCell::new(node.clone())));\n\n    while let Some(current_rover) = rover {\n        let mut current_rover_borrowed = current_rover.borrow_mut();\n\n        // Balance this node if necessary\n        let balanced_node = avl_tree_node_balance(tree, &mut *current_rover_borrowed);\n        rover = balanced_node.parent.clone();\n\n        // Go to this node's parent\n        rover = rover.map(|parent| Rc::clone(&parent));\n    }\n}\n\npub fn avl_tree_new<T>(compare_func: fn(T, T) -> i32) -> Option<AVLTree<T>> {\n    let new_tree = AVLTree {\n        root_node: None,\n        compare_func,\n        num_nodes: 0,\n    };\n\n    Some(new_tree)\n}\n\npub fn avl_tree_free<T>(tree: &mut AVLTree<T>) {\n    avl_tree_free_subtree(tree.root_node.take());\n}\n\npub fn avl_tree_update_height<T>(node: &mut AVLTreeNode<T>) {\n    let left_height = avl_tree_subtree_height(&node.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize]);\n    let right_height = avl_tree_subtree_height(&node.children[AVLTreeNodeSide::AvlTreeNodeRight as usize]);\n\n    if left_height > right_height {\n        node.height = left_height + 1;\n    } else {\n        node.height = right_height + 1;\n    }\n}\n\npub fn avl_tree_node_balance<'a, T: Clone>(tree: &'a mut AVLTree<T>, node: &'a mut AVLTreeNode<T>) -> &'a mut AVLTreeNode<T> {\n    let left_subtree = &node.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize];\n    let right_subtree = &node.children[AVLTreeNodeSide::AvlTreeNodeRight as usize];\n    let mut diff = avl_tree_subtree_height(right_subtree) - avl_tree_subtree_height(left_subtree);\n\n    if diff >= 2 {\n        let child = node.children[AVLTreeNodeSide::AvlTreeNodeRight as usize].as_mut().unwrap();\n\n        if avl_tree_subtree_height(&child.children[AVLTreeNodeSide::AvlTreeNodeRight as usize])\n            < avl_tree_subtree_height(&child.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize]) {\n            avl_tree_rotate(tree, child, AVLTreeNodeSide::AvlTreeNodeRight);\n        }\n\n        let rotated_node = avl_tree_rotate(tree, node, AVLTreeNodeSide::AvlTreeNodeLeft).unwrap();\n        *node = *rotated_node;\n    } else if diff <= -2 {\n        let child = node.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize].as_mut().unwrap();\n\n        if avl_tree_subtree_height(&child.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize])\n            < avl_tree_subtree_height(&child.children[AVLTreeNodeSide::AvlTreeNodeRight as usize]) {\n            avl_tree_rotate(tree, child, AVLTreeNodeSide::AvlTreeNodeLeft);\n        }\n\n        let rotated_node = avl_tree_rotate(tree, node, AVLTreeNodeSide::AvlTreeNodeRight).unwrap();\n        *node = *rotated_node;\n    }\n\n    avl_tree_update_height(node);\n    node\n}\n\npub fn avl_tree_lookup_node<T: Clone>(tree: &AVLTree<T>, key: T) -> Option<&AVLTreeNode<T>> {\n    let mut node = tree.root_node.as_ref();\n\n    while let Some(n) = node {\n        let diff = (tree.compare_func)(key.clone(), n.key.clone());\n\n        if diff == 0 {\n            return Some(n);\n        } else if diff < 0 {\n            node = n.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize].as_ref();\n        } else {\n            node = n.children[AVLTreeNodeSide::AvlTreeNodeRight as usize].as_ref();\n        }\n    }\n\n    None\n}\n\npub fn avl_tree_node_value<T>(node: &AVLTreeNode<T>) -> &T {\n    &node.value\n}\n\npub fn avl_tree_root_node<T>(tree: &AVLTree<T>) -> Option<&Box<AVLTreeNode<T>>> {\n    tree.root_node.as_ref()\n}\n\npub fn avl_tree_node_parent_side<T>(node: &AVLTreeNode<T>) -> AVLTreeNodeSide {\n    if let Some(parent) = &node.parent {\n        let parent_borrowed = parent.borrow();\n        if parent_borrowed.children[0].as_ref().map_or(false, |child| child.as_ref() as *const AVLTreeNode<T> == node) {\n            return AVLTreeNodeSide::AvlTreeNodeLeft;\n        } else if parent_borrowed.children[1].as_ref().map_or(false, |child| child.as_ref() as *const AVLTreeNode<T> == node) {\n            return AVLTreeNodeSide::AvlTreeNodeRight;\n        }\n    }\n    panic!(\"Node does not have a valid parent or is not a child of its parent\");\n}\n\npub fn avl_tree_num_entries<T>(tree: &AVLTree<T>) -> u32 {\n    tree.num_nodes\n}\n\npub fn avl_tree_node_replace<T: Clone>(tree: &mut AVLTree<T>, node1: &mut AVLTreeNode<T>, node2: Option<&AVLTreeNode<T>>) {\n    let side;\n\n    if let Some(node2) = node2 {\n        let node2_clone = node2.clone();\n        if let Some(parent) = node1.parent.clone() {\n            let mut parent_borrowed = parent.borrow_mut();\n            side = avl_tree_node_parent_side(node1);\n            parent_borrowed.children[side as usize] = Some(Box::new(node2_clone));\n\n            avl_tree_update_height(&mut *parent_borrowed);\n        }\n    }\n\n    if node1.parent.is_none() {\n        tree.root_node = node2.cloned().map(|n| Box::new(n));\n    }\n}\n\npub fn avl_tree_node_parent<T>(node: &AVLTreeNode<T>) -> Option<Rc<RefCell<AVLTreeNode<T>>>> {\n    node.parent.clone()\n}\n\npub fn avl_tree_free_subtree<T>(node: Option<Box<AVLTreeNode<T>>>) {\n    if let Some(mut n) = node {\n        avl_tree_free_subtree(n.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize].take());\n        avl_tree_free_subtree(n.children[AVLTreeNodeSide::AvlTreeNodeRight as usize].take());\n    }\n}\n\npub fn test_avl_tree_insert_lookup() {\n    let mut tree = avl_tree_new(int_compare).unwrap();\n    let mut test_array = vec![0; NUM_TEST_VALUES];\n\n    for i in 0..NUM_TEST_VALUES {\n        test_array[i] = i as i32;\n        avl_tree_insert(&mut tree, i as i32, i as i32);\n\n        assert_eq!(avl_tree_num_entries(&tree), i as u32 + 1);\n        unsafe { validate_tree(&tree); }\n    }\n\n    assert!(avl_tree_root_node(&tree).is_some());\n\n    for i in 0..NUM_TEST_VALUES {\n        let node = avl_tree_lookup_node(&tree, i as i32).unwrap();\n        let value = avl_tree_node_key(node);\n        assert_eq!(*value, i as i32);\n        let value = avl_tree_node_value(node);\n        assert_eq!(*value, i as i32);\n    }\n\n    let i = NUM_TEST_VALUES + 100;\n    assert!(avl_tree_lookup_node(&tree, i as i32).is_none());\n\n    avl_tree_free(&mut tree);\n}\n\npub fn find_subtree_height<T>(node: &Option<Box<AVLTreeNode<T>>>) -> i32 {\n    if let Some(n) = node {\n        let left_subtree = &n.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize];\n        let right_subtree = &n.children[AVLTreeNodeSide::AvlTreeNodeRight as usize];\n        let left_height = find_subtree_height(left_subtree);\n        let right_height = find_subtree_height(right_subtree);\n\n        if left_height > right_height {\n            left_height + 1\n        } else {\n            right_height + 1\n        }\n    } else {\n        0\n    }\n}\n\npub fn validate_subtree<T>(node: &Option<Box<AVLTreeNode<T>>>) -> i32 {\n    if let Some(n) = node {\n        let left_node = &n.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize];\n        let right_node = &n.children[AVLTreeNodeSide::AvlTreeNodeRight as usize];\n\n        if let Some(ln) = left_node {\n            assert_eq!(avl_tree_node_parent(ln).as_ref().map(|p| p.as_ref()), Some(n));\n        }\n        if let Some(rn) = right_node {\n            assert_eq!(avl_tree_node_parent(rn).as_ref().map(|p| p.as_ref()), Some(n));\n        }\n\n        let left_height = validate_subtree(left_node);\n        let key = avl_tree_node_key(n);\n\n        unsafe {\n            assert!(*key > counter);\n            counter = *key;\n        }\n\n        let right_height = validate_subtree(right_node);\n\n        assert_eq!(avl_tree_subtree_height(left_node), left_height);\n        assert_eq!(avl_tree_subtree_height(right_node), right_height);\n\n        assert!((left_height - right_height).abs() < 2);\n\n        if left_height > right_height {\n            left_height + 1\n        } else {\n            right_height + 1\n        }\n    } else {\n        0\n    }\n}\n\npub fn validate_tree<T>(tree: &AVLTree<T>) {\n    let root_node = avl_tree_root_node(tree);\n\n    if let Some(root) = root_node {\n        let height = find_subtree_height(root);\n        assert_eq!(avl_tree_subtree_height(root), height);\n    }\n\n    unsafe {\n        counter = -1;\n        validate_subtree(root_node);\n    }\n}\n\npub const NUM_TEST_VALUES: usize = 1000;\npub static mut counter: i32 = -1;\n\npub fn int_compare(a: i32, b: i32) -> i32 {\n    a.cmp(&b) as i32\n}\n\nfn main() {}\n //编译报错信息：error[E0308]: mismatched types\n  --> ../tmp/temp.rs:59:17\n   |\n59 |         parent: previous_node.clone(),\n   |                 ^^^^^^^^^^^^^^^^^^^^^ expected `AVLTreeNode<_>`, found `Box<AVLTreeNode<T>>`\n   |\n   = note: expected enum `Option<Rc<RefCell<AVLTreeNode<_>>>>`\n              found enum `Option<Rc<RefCell<Box<AVLTreeNode<T>>>>>`\n\nerror[E0369]: binary operation `==` cannot be applied to type `Option<&RefCell<AVLTreeNode<T>>>`\n   --> ../tmp/temp.rs:314:13\n    |\n314 |             assert_eq!(avl_tree_node_parent(ln).as_ref().map(|p| p.as_ref()), Some(n));\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |             |\n    |             Option<&RefCell<AVLTreeNode<T>>>\n    |             Option<&Box<AVLTreeNode<T>>>\n    |\nnote: the foreign item type `Option<&RefCell<AVLTreeNode<T>>>` doesn't implement `PartialEq<Option<&Box<AVLTreeNode<T>>>>`\n   --> /home/mins01/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:572:1\n    |\n572 | pub enum Option<T> {\n    | ^^^^^^^^^^^^^^^^^^ not implement `PartialEq<Option<&Box<AVLTreeNode<T>>>>`\n",
        "test_out_of_memory": "use std::rc::Rc;\nuse std::cell::RefCell;\n\npub enum AVLTreeNodeSide {\n    AvlTreeNodeLeft,\n    AvlTreeNodeRight,\n}\n\nimpl Clone for AVLTreeNodeSide {\n    fn clone(&self) -> Self {\n        match self {\n            AVLTreeNodeSide::AvlTreeNodeLeft => AVLTreeNodeSide::AvlTreeNodeLeft,\n            AVLTreeNodeSide::AvlTreeNodeRight => AVLTreeNodeSide::AvlTreeNodeRight,\n        }\n    }\n}\n\npub struct AVLTreeNode<T> {\n    pub children: [Option<Box<AVLTreeNode<T>>>; 2],\n    pub parent: Option<Rc<RefCell<AVLTreeNode<T>>>>,\n    pub key: T,\n    pub value: T,\n    pub height: i32,\n}\n\nimpl<T: Clone> Clone for AVLTreeNode<T> {\n    fn clone(&self) -> Self {\n        AVLTreeNode {\n            children: self.children.clone(),\n            parent: self.parent.clone(),\n            key: self.key.clone(),\n            value: self.value.clone(),\n            height: self.height,\n        }\n    }\n}\n\npub struct AVLTree<T> {\n    pub root_node: Option<Box<AVLTreeNode<T>>>, \n    pub compare_func: fn(T, T) -> i32,\n    pub num_nodes: u32,\n}\n\npub fn avl_tree_insert<T: Clone>(tree: &mut AVLTree<T>, key: T, value: T) -> Option<Box<AVLTreeNode<T>>> {\n    let mut rover = &mut tree.root_node;\n    let mut previous_node = None;\n\n    while let Some(node) = rover {\n        previous_node = Some(Rc::new(RefCell::new(node.clone())));\n        if (tree.compare_func)(key.clone(), node.key.clone()) < 0 {\n            rover = &mut node.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize];\n        } else {\n            rover = &mut node.children[AVLTreeNodeSide::AvlTreeNodeRight as usize];\n        }\n    }\n\n    let new_node = Box::new(AVLTreeNode {\n        children: [None, None],\n        parent: previous_node.clone(),\n        key,\n        value,\n        height: 1,\n    });\n\n    *rover = Some(new_node.clone());\n\n    if let Some(previous) = previous_node {\n        avl_tree_balance_to_root(tree, &mut *previous.borrow_mut());\n    }\n\n    tree.num_nodes += 1;\n\n    Some(new_node)\n}\n\npub fn avl_tree_update_height<T>(node: &mut AVLTreeNode<T>) {\n    let left_height = avl_tree_subtree_height(&node.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize]);\n    let right_height = avl_tree_subtree_height(&node.children[AVLTreeNodeSide::AvlTreeNodeRight as usize]);\n\n    if left_height > right_height {\n        node.height = left_height + 1;\n    } else {\n        node.height = right_height + 1;\n    }\n}\n\npub fn avl_tree_node_key<T>(node: &AVLTreeNode<T>) -> &T {\n    &node.key\n}\n\npub fn avl_tree_rotate<T: Clone>(tree: &mut AVLTree<T>, node: &mut AVLTreeNode<T>, direction: AVLTreeNodeSide) -> Option<Box<AVLTreeNode<T>>> {\n    let direction_index = direction as usize;\n    let new_root = node.children[1 - direction_index].take();\n\n    if let Some(mut new_root) = new_root {\n        avl_tree_node_replace(tree, node, Some(&*new_root));\n\n        node.children[1 - direction_index] = new_root.children[direction_index].take();\n        new_root.children[direction_index] = Some(Box::new(node.clone()));\n\n        let node_clone = node.clone();\n        node.parent = Some(Rc::new(RefCell::new(new_root.clone())));\n\n        if let Some(child) = node.children[1 - direction_index].as_mut() {\n            child.parent = Some(Rc::new(RefCell::new(node_clone)));\n        }\n\n        avl_tree_update_height(&mut *new_root);\n        avl_tree_update_height(node);\n\n        Some(new_root)\n    } else {\n        None\n    }\n}\n\npub fn avl_tree_node_balance<'a, T: Clone>(tree: &'a mut AVLTree<T>, node: &'a mut AVLTreeNode<T>) -> &'a mut AVLTreeNode<T> {\n    let left_subtree = &node.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize];\n    let right_subtree = &node.children[AVLTreeNodeSide::AvlTreeNodeRight as usize];\n    let mut diff = avl_tree_subtree_height(right_subtree) - avl_tree_subtree_height(left_subtree);\n\n    if diff >= 2 {\n        let child = node.children[AVLTreeNodeSide::AvlTreeNodeRight as usize].as_mut().unwrap();\n\n        if avl_tree_subtree_height(&child.children[AVLTreeNodeSide::AvlTreeNodeRight as usize])\n            < avl_tree_subtree_height(&child.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize]) {\n            avl_tree_rotate(tree, child, AVLTreeNodeSide::AvlTreeNodeRight);\n        }\n\n        let rotated_node = avl_tree_rotate(tree, node, AVLTreeNodeSide::AvlTreeNodeLeft).unwrap();\n        *node = *rotated_node;\n    } else if diff <= -2 {\n        let child = node.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize].as_mut().unwrap();\n\n        if avl_tree_subtree_height(&child.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize])\n            < avl_tree_subtree_height(&child.children[AVLTreeNodeSide::AvlTreeNodeRight as usize]) {\n            avl_tree_rotate(tree, child, AVLTreeNodeSide::AvlTreeNodeLeft);\n        }\n\n        let rotated_node = avl_tree_rotate(tree, node, AVLTreeNodeSide::AvlTreeNodeRight).unwrap();\n        *node = *rotated_node;\n    }\n\n    avl_tree_update_height(node);\n    node\n}\n\npub fn avl_tree_node_parent_side<T>(node: &AVLTreeNode<T>) -> AVLTreeNodeSide {\n    if let Some(parent) = &node.parent {\n        let parent_borrowed = parent.borrow();\n        if parent_borrowed.children[0].as_ref().map_or(false, |child| child.as_ref() as *const AVLTreeNode<T> == node) {\n            return AVLTreeNodeSide::AvlTreeNodeLeft;\n        } else if parent_borrowed.children[1].as_ref().map_or(false, |child| child.as_ref() as *const AVLTreeNode<T> == node) {\n            return AVLTreeNodeSide::AvlTreeNodeRight;\n        }\n    }\n    panic!(\"Node does not have a valid parent or is not a child of its parent\");\n}\n\npub fn avl_tree_root_node<T>(tree: &AVLTree<T>) -> Option<&Box<AVLTreeNode<T>>> {\n    tree.root_node.as_ref()\n}\n\npub fn avl_tree_node_child<T>(node: &AVLTreeNode<T>, side: AVLTreeNodeSide) -> Option<&Box<AVLTreeNode<T>>> {\n    match side {\n        AVLTreeNodeSide::AvlTreeNodeLeft | AVLTreeNodeSide::AvlTreeNodeRight => node.children[side as usize].as_ref(),\n    }\n}\n\npub fn avl_tree_node_replace<T: Clone>(tree: &mut AVLTree<T>, node1: &mut AVLTreeNode<T>, node2: Option<&AVLTreeNode<T>>) {\n    let side;\n\n    if let Some(node2) = node2 {\n        let node2_clone = node2.clone();\n        if let Some(parent) = node1.parent.clone() {\n            let mut parent_borrowed = parent.borrow_mut();\n            side = avl_tree_node_parent_side(node1);\n            parent_borrowed.children[side as usize] = Some(Box::new(node2_clone));\n\n            avl_tree_update_height(&mut *parent_borrowed);\n        }\n    }\n\n    if node1.parent.is_none() {\n        tree.root_node = node2.cloned().map(|n| Box::new(n));\n    }\n}\n\npub fn avl_tree_node_parent<T>(node: &AVLTreeNode<T>) -> Option<Rc<RefCell<AVLTreeNode<T>>>> {\n    node.parent.clone()\n}\n\npub fn avl_tree_free_subtree<T>(node: Option<Box<AVLTreeNode<T>>>) {\n    if let Some(mut n) = node {\n        avl_tree_free_subtree(n.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize].take());\n        avl_tree_free_subtree(n.children[AVLTreeNodeSide::AvlTreeNodeRight as usize].take());\n    }\n}\n\npub fn avl_tree_subtree_height<T>(node: &Option<Box<AVLTreeNode<T>>>) -> i32 {\n    if let Some(n) = node {\n        n.height\n    } else {\n        0\n    }\n}\n\npub fn avl_tree_new<T>(compare_func: fn(T, T) -> i32) -> Option<AVLTree<T>> {\n    let new_tree = AVLTree {\n        root_node: None,\n        compare_func,\n        num_nodes: 0,\n    };\n\n    Some(new_tree)\n}\n\npub fn avl_tree_free<T>(tree: &mut AVLTree<T>) {\n    avl_tree_free_subtree(tree.root_node.take());\n}\n\npub fn avl_tree_balance_to_root<T: Clone>(tree: &mut AVLTree<T>, node: &mut AVLTreeNode<T>) {\n    let mut rover = Some(Rc::new(RefCell::new(node.clone())));\n\n    while let Some(current_rover) = rover {\n        let mut current_rover_borrowed = current_rover.borrow_mut();\n\n        // Balance this node if necessary\n        let balanced_node = avl_tree_node_balance(tree, &mut *current_rover_borrowed);\n        rover = balanced_node.parent.clone();\n\n        // Go to this node's parent\n        rover = rover.map(|parent| Rc::clone(&parent));\n    }\n}\n\npub fn test_out_of_memory() {\n    let mut tree = create_tree().unwrap();\n\n    // Try to add some more nodes and verify that this fails.\n    for i in 10000..20000 {\n        let node = avl_tree_insert(&mut tree, i, i);\n        assert!(node.is_none());\n        validate_tree(&tree);\n    }\n\n    avl_tree_free(&mut tree);\n}\n\npub fn find_subtree_height<T>(node: Option<&Box<AVLTreeNode<T>>>) -> i32 {\n    if let Some(n) = node {\n        let left_subtree = avl_tree_node_child(n, AVLTreeNodeSide::AvlTreeNodeLeft);\n        let right_subtree = avl_tree_node_child(n, AVLTreeNodeSide::AvlTreeNodeRight);\n        let left_height = find_subtree_height(left_subtree);\n        let right_height = find_subtree_height(right_subtree);\n\n        if left_height > right_height {\n            left_height + 1\n        } else {\n            right_height + 1\n        }\n    } else {\n        0\n    }\n}\n\npub fn validate_subtree<T: Clone + PartialEq>(node: Option<&Box<AVLTreeNode<T>>>) -> i32 {\n    if let Some(n) = node {\n        let left_node = avl_tree_node_child(n, AVLTreeNodeSide::AvlTreeNodeLeft);\n        let right_node = avl_tree_node_child(n, AVLTreeNodeSide::AvlTreeNodeRight);\n\n        // Check the parent references of the children\n        if let Some(ln) = left_node {\n            assert_eq!(avl_tree_node_parent(ln).as_ref().map(|p| p.borrow().key.clone()), Some(n.key.clone()));\n        }\n        if let Some(rn) = right_node {\n            assert_eq!(avl_tree_node_parent(rn).as_ref().map(|p| p.borrow().key.clone()), Some(n.key.clone()));\n        }\n\n        // Recursively validate the left and right subtrees,\n        // obtaining the height at the same time.\n        let left_height = validate_subtree(left_node);\n\n        // Check that the keys are in the correct order\n        let key = avl_tree_node_key(n);\n        unsafe {\n            assert!(*key > counter);\n            counter = *key;\n        }\n\n        let right_height = validate_subtree(right_node);\n\n        // Check that the returned height value matches the\n        // result of avl_tree_subtree_height().\n        assert_eq!(avl_tree_subtree_height(left_node), left_height);\n        assert_eq!(avl_tree_subtree_height(right_node), right_height);\n\n        // Check this node is balanced\n        assert!((left_height - right_height).abs() < 2);\n\n        // Calculate the height of this node\n        if left_height > right_height {\n            left_height + 1\n        } else {\n            right_height + 1\n        }\n    } else {\n        0\n    }\n}\n\npub fn validate_tree<T: Clone + PartialEq>(tree: &AVLTree<T>) {\n    let root_node = avl_tree_root_node(tree);\n\n    if let Some(root) = root_node {\n        let height = find_subtree_height(Some(root));\n        assert_eq!(avl_tree_subtree_height(root_node), height);\n    }\n\n    unsafe {\n        counter = -1;\n    }\n    validate_subtree(root_node);\n}\n\npub fn create_tree() -> Option<AVLTree<i32>> {\n    let mut tree = avl_tree_new(int_compare)?;\n\n    for i in 0..NUM_TEST_VALUES {\n        unsafe {\n            test_array[i] = i;\n        }\n        avl_tree_insert(&mut tree, unsafe { test_array[i] }, unsafe { test_array[i] });\n    }\n\n    Some(tree)\n}\n\npub static mut test_array: [i32; NUM_TEST_VALUES] = [0; NUM_TEST_VALUES];\npub static mut counter: i32 = -1;\npub const NUM_TEST_VALUES: usize = 1000;\n\npub fn int_compare(a: i32, b: i32) -> i32 {\n    a.cmp(&b) as i32\n}\n\nfn main(){}\n //编译报错信息：error[E0308]: mismatched types\n  --> ../tmp/temp.rs:59:17\n   |\n59 |         parent: previous_node.clone(),\n   |                 ^^^^^^^^^^^^^^^^^^^^^ expected `AVLTreeNode<_>`, found `Box<AVLTreeNode<T>>`\n   |\n   = note: expected enum `Option<Rc<RefCell<AVLTreeNode<_>>>>`\n              found enum `Option<Rc<RefCell<Box<AVLTreeNode<T>>>>>`\n\nerror[E0308]: mismatched types\n   --> ../tmp/temp.rs:102:49\n    |\n102 |         node.parent = Some(Rc::new(RefCell::new(new_root.clone())));\n    |                                    ------------ ^^^^^^^^^^^^^^^^ expected `AVLTreeNode<T>`, found `Box<AVLTreeNode<T>>`\n    |                                    |\n    |                                    arguments to this function are incorrect\n    |\n",
        "test_avl_tree_remove": "use std::rc::Rc;\nuse std::cell::RefCell;\n\npub enum AVLTreeNodeSide {\n    AvlTreeNodeLeft,\n    AvlTreeNodeRight,\n}\n\nimpl Clone for AVLTreeNodeSide {\n    fn clone(&self) -> Self {\n        match self {\n            AVLTreeNodeSide::AvlTreeNodeLeft => AVLTreeNodeSide::AvlTreeNodeLeft,\n            AVLTreeNodeSide::AvlTreeNodeRight => AVLTreeNodeSide::AvlTreeNodeRight,\n        }\n    }\n}\n\npub struct AVLTreeNode<T> {\n    pub children: [Option<Box<AVLTreeNode<T>>>; 2],\n    pub parent: Option<Rc<RefCell<AVLTreeNode<T>>>>,\n    pub key: T,\n    pub value: T,\n    pub height: i32,\n}\n\nimpl<T: Clone> Clone for AVLTreeNode<T> {\n    fn clone(&self) -> Self {\n        AVLTreeNode {\n            children: self.children.clone(),\n            parent: self.parent.clone(),\n            key: self.key.clone(),\n            value: self.value.clone(),\n            height: self.height,\n        }\n    }\n}\n\npub struct AVLTree<T> {\n    pub root_node: Option<Box<AVLTreeNode<T>>>, \n    pub compare_func: fn(T, T) -> i32,\n    pub num_nodes: u32,\n}\n\npub fn avl_tree_new<T>(compare_func: fn(T, T) -> i32) -> Option<AVLTree<T>> {\n    let new_tree = AVLTree {\n        root_node: None,\n        compare_func,\n        num_nodes: 0,\n    };\n\n    Some(new_tree)\n}\n\npub fn avl_tree_free<T>(tree: &mut AVLTree<T>) {\n    avl_tree_free_subtree(tree.root_node.take());\n}\n\npub fn avl_tree_update_height<T>(node: &mut AVLTreeNode<T>) {\n    let left_height = avl_tree_subtree_height(&node.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize]);\n    let right_height = avl_tree_subtree_height(&node.children[AVLTreeNodeSide::AvlTreeNodeRight as usize]);\n\n    if left_height > right_height {\n        node.height = left_height + 1;\n    } else {\n        node.height = right_height + 1;\n    }\n}\n\npub fn avl_tree_node_balance<'a, T: Clone>(tree: &'a mut AVLTree<T>, node: &'a mut AVLTreeNode<T>) -> &'a mut AVLTreeNode<T> {\n    let left_subtree = &node.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize];\n    let right_subtree = &node.children[AVLTreeNodeSide::AvlTreeNodeRight as usize];\n    let mut diff = avl_tree_subtree_height(right_subtree) - avl_tree_subtree_height(left_subtree);\n\n    if diff >= 2 {\n        let child = node.children[AVLTreeNodeSide::AvlTreeNodeRight as usize].as_mut().unwrap();\n\n        if avl_tree_subtree_height(&child.children[AVLTreeNodeSide::AvlTreeNodeRight as usize])\n            < avl_tree_subtree_height(&child.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize]) {\n            avl_tree_rotate(tree, child, AVLTreeNodeSide::AvlTreeNodeRight);\n        }\n\n        let rotated_node = avl_tree_rotate(tree, node, AVLTreeNodeSide::AvlTreeNodeLeft).unwrap();\n        *node = *rotated_node;\n    } else if diff <= -2 {\n        let child = node.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize].as_mut().unwrap();\n\n        if avl_tree_subtree_height(&child.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize])\n            < avl_tree_subtree_height(&child.children[AVLTreeNodeSide::AvlTreeNodeRight as usize]) {\n            avl_tree_rotate(tree, child, AVLTreeNodeSide::AvlTreeNodeLeft);\n        }\n\n        let rotated_node = avl_tree_rotate(tree, node, AVLTreeNodeSide::AvlTreeNodeRight).unwrap();\n        *node = *rotated_node;\n    }\n\n    avl_tree_update_height(node);\n    node\n}\n\npub fn avl_tree_lookup_node<T: Clone>(tree: &AVLTree<T>, key: T) -> Option<&AVLTreeNode<T>> {\n    let mut node = tree.root_node.as_ref();\n\n    while let Some(n) = node {\n        let diff = (tree.compare_func)(key.clone(), n.key.clone());\n\n        if diff == 0 {\n            return Some(n);\n        } else if diff < 0 {\n            node = n.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize].as_ref();\n        } else {\n            node = n.children[AVLTreeNodeSide::AvlTreeNodeRight as usize].as_ref();\n        }\n    }\n\n    None\n}\n\npub const NUM_TEST_VALUES: usize = 1000;\npub static mut test_array: [i32; NUM_TEST_VALUES] = [0; NUM_TEST_VALUES];\n\npub fn avl_tree_root_node<T>(tree: &AVLTree<T>) -> Option<&Box<AVLTreeNode<T>>> {\n    tree.root_node.as_ref()\n}\n\npub fn avl_tree_node_parent_side<T>(node: &AVLTreeNode<T>) -> AVLTreeNodeSide {\n    if let Some(parent) = &node.parent {\n        let parent_borrowed = parent.borrow();\n        if parent_borrowed.children[0].as_ref().map_or(false, |child| child.as_ref() as *const AVLTreeNode<T> == node) {\n            return AVLTreeNodeSide::AvlTreeNodeLeft;\n        } else if parent_borrowed.children[1].as_ref().map_or(false, |child| child.as_ref() as *const AVLTreeNode<T> == node) {\n            return AVLTreeNodeSide::AvlTreeNodeRight;\n        }\n    }\n    panic!(\"Node does not have a valid parent or is not a child of its parent\");\n}\n\npub fn avl_tree_num_entries<T>(tree: &AVLTree<T>) -> u32 {\n    tree.num_nodes\n}\n\npub fn avl_tree_node_replace<T: Clone>(tree: &mut AVLTree<T>, node1: &mut AVLTreeNode<T>, node2: Option<&AVLTreeNode<T>>) {\n    let side;\n\n    if let Some(node2) = node2 {\n        let node2_clone = node2.clone();\n        if let Some(parent) = node1.parent.clone() {\n            let mut parent_borrowed = parent.borrow_mut();\n            side = avl_tree_node_parent_side(node1);\n            parent_borrowed.children[side as usize] = Some(Box::new(node2_clone));\n\n            avl_tree_update_height(&mut *parent_borrowed);\n        }\n    }\n\n    if node1.parent.is_none() {\n        tree.root_node = node2.cloned().map(|n| Box::new(n));\n    }\n}\n\npub fn avl_tree_node_parent<T>(node: &AVLTreeNode<T>) -> Option<Rc<RefCell<AVLTreeNode<T>>>> {\n    node.parent.clone()\n}\n\npub fn avl_tree_free_subtree<T>(node: Option<Box<AVLTreeNode<T>>>) {\n    if let Some(mut n) = node {\n        avl_tree_free_subtree(n.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize].take());\n        avl_tree_free_subtree(n.children[AVLTreeNodeSide::AvlTreeNodeRight as usize].take());\n    }\n}\n\npub fn test_avl_tree_remove() {\n    let mut tree = create_tree();\n    let mut i: i32;\n    let mut x: i32;\n    let mut y: i32;\n    let mut z: i32;\n    let mut value: i32;\n    let mut expected_entries: u32;\n\n    // Try removing invalid entries\n    i = NUM_TEST_VALUES as i32 + 100;\n    assert_eq!(avl_tree_remove(&mut tree, i), 0);\n    i = -1;\n    assert_eq!(avl_tree_remove(&mut tree, i), 0);\n\n    // Delete the nodes from the tree\n    expected_entries = NUM_TEST_VALUES as u32;\n\n    // This looping arrangement causes nodes to be removed in a\n    // randomish fashion from all over the tree.\n    for x in 0..10 {\n        for y in 0..10 {\n            for z in 0..10 {\n                value = z * 100 + (9 - y) * 10 + x;\n                assert_ne!(avl_tree_remove(&mut tree, value), 0);\n                validate_tree(&mut tree);\n                expected_entries -= 1;\n                assert_eq!(avl_tree_num_entries(&tree), expected_entries);\n            }\n        }\n    }\n\n    // All entries removed, should be empty now\n    assert!(avl_tree_root_node(&tree).is_none());\n\n    avl_tree_free(&mut tree);\n}\n\npub fn avl_tree_node_get_replacement<T: Clone>(tree: &mut AVLTree<T>, node: &AVLTreeNode<T>) -> Option<Rc<RefCell<AVLTreeNode<T>>>> {\n    let left_subtree = node.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize].as_ref();\n    let right_subtree = node.children[AVLTreeNodeSide::AvlTreeNodeRight as usize].as_ref();\n\n    // No children?\n    if left_subtree.is_none() && right_subtree.is_none() {\n        return None;\n    }\n\n    // Pick a node from whichever subtree is taller.  This helps to\n    // keep the tree balanced.\n    let left_height = avl_tree_subtree_height(left_subtree);\n    let right_height = avl_tree_subtree_height(right_subtree);\n    let mut side = AVLTreeNodeSide::AvlTreeNodeLeft;\n\n    if left_height < right_height {\n        side = AVLTreeNodeSide::AvlTreeNodeRight;\n    }\n\n    // Search down the tree, back towards the center.\n    let mut result = node.children[side as usize].as_ref().unwrap().clone();\n    let mut result_borrowed = result.borrow();\n\n    while result_borrowed.children[1 - side as usize].is_some() {\n        result = result_borrowed.children[1 - side as usize].as_ref().unwrap().clone();\n        result_borrowed = result.borrow();\n    }\n\n    // Unlink the result node, and hook in its remaining child\n    // (if it has one) to replace it.\n    let child = result_borrowed.children[side as usize].clone();\n    avl_tree_node_replace(tree, &mut *result_borrowed, child.as_deref());\n\n    // Update the subtree height for the result node's old parent.\n    avl_tree_update_height(result_borrowed.parent.as_ref().unwrap().borrow_mut().deref_mut());\n\n    Some(result)\n}\n\npub fn find_subtree_height<T>(node: &Option<Box<AVLTreeNode<T>>>) -> i32 {\n    if let Some(n) = node {\n        let left_subtree = avl_tree_node_child(n, AVLTreeNodeSide::AvlTreeNodeLeft);\n        let right_subtree = avl_tree_node_child(n, AVLTreeNodeSide::AvlTreeNodeRight);\n        let left_height = find_subtree_height(left_subtree);\n        let right_height = find_subtree_height(right_subtree);\n\n        if left_height > right_height {\n            left_height + 1\n        } else {\n            right_height + 1\n        }\n    } else {\n        0\n    }\n}\n\npub fn avl_tree_remove<T: Clone>(tree: &mut AVLTree<T>, key: T) -> i32 {\n    let node = avl_tree_lookup_node(tree, key);\n\n    if node.is_none() {\n        // Not found in tree\n        0\n    } else {\n        // Remove the node\n        avl_tree_remove_node(tree, node.unwrap());\n        1\n    }\n}\n\npub fn avl_tree_remove_node<T: Clone>(tree: &mut AVLTree<T>, node: &AVLTreeNode<T>) {\n    let mut swap_node = avl_tree_node_get_replacement(tree, node);\n    let mut balance_startpoint = node.parent.clone();\n\n    if swap_node.is_none() {\n        // This is a leaf node and has no children, therefore\n        // it can be immediately removed.\n\n        // Unlink this node from its parent.\n        avl_tree_node_replace(tree, node, None);\n\n        // Start rebalancing from the parent of the original node\n        if let Some(parent) = &node.parent {\n            balance_startpoint = Some(parent.clone());\n        }\n    } else {\n        // We will start rebalancing from the old parent of the\n        // swap node.  Sometimes, the old parent is the node we\n        // are removing, in which case we must start rebalancing\n        // from the swap node.\n        if swap_node.as_ref().unwrap().borrow().parent.as_ref().unwrap().borrow().deref() == node {\n            balance_startpoint = swap_node.clone();\n        }\n\n        // Copy references in the node into the swap node\n        let mut swap_node_borrowed = swap_node.as_mut().unwrap().borrow_mut();\n        for i in 0..2 {\n            swap_node_borrowed.children[i] = node.children[i].clone();\n\n            if let Some(child) = swap_node_borrowed.children[i].as_mut() {\n                child.parent = Some(swap_node.clone());\n            }\n        }\n\n        swap_node_borrowed.height = node.height;\n\n        // Link the parent's reference to this node\n        avl_tree_node_replace(tree, node, Some(&mut *swap_node_borrowed));\n    }\n\n    // Destroy the node\n    // In Rust, this is handled by dropping the node when it goes out of scope\n\n    // Keep track of the number of nodes\n    tree.num_nodes -= 1;\n\n    // Rebalance the tree\n    if let Some(balance_startpoint) = balance_startpoint {\n        avl_tree_balance_to_root(tree, &mut *balance_startpoint.borrow_mut());\n    }\n}\n\npub fn validate_subtree<T: Clone>(node: &Option<Box<AVLTreeNode<T>>>) -> i32 {\n    if let Some(n) = node {\n        let left_node = avl_tree_node_child(n, AVLTreeNodeSide::AvlTreeNodeLeft);\n        let right_node = avl_tree_node_child(n, AVLTreeNodeSide::AvlTreeNodeRight);\n\n        // Check the parent references of the children\n        if let Some(left) = left_node {\n            assert_eq!(avl_tree_node_parent(left).unwrap().borrow().deref(), n);\n        }\n        if let Some(right) = right_node {\n            assert_eq!(avl_tree_node_parent(right).unwrap().borrow().deref(), n);\n        }\n\n        // Recursively validate the left and right subtrees,\n        // obtaining the height at the same time.\n        let left_height = validate_subtree(left_node);\n        let key = avl_tree_node_key(n);\n\n        // Check that the keys are in the correct order\n        assert!(*key > counter);\n        counter = *key;\n\n        let right_height = validate_subtree(right_node);\n\n        // Check that the returned height value matches the\n        // result of avl_tree_subtree_height().\n        assert_eq!(avl_tree_subtree_height(left_node), left_height);\n        assert_eq!(avl_tree_subtree_height(right_node), right_height);\n\n        // Check this node is balanced\n        assert!(left_height - right_height < 2 && right_height - left_height < 2);\n\n        // Calculate the height of this node\n        if left_height > right_height {\n            left_height + 1\n        } else {\n            right_height + 1\n        }\n    } else {\n        0\n    }\n}\n\npub fn validate_tree<T: Clone>(tree: &mut AVLTree<T>) {\n    let root_node = avl_tree_root_node(tree);\n\n    if let Some(root) = root_node {\n        let height = find_subtree_height(root);\n        assert_eq!(avl_tree_subtree_height(root), height);\n    }\n\n    counter = -1;\n    validate_subtree(root_node);\n}\n\npub static mut counter: i32 = -1;\n\nfn int_compare(a: i32, b: i32) -> i32 {\n    a.cmp(&b) as i32\n}\n\npub fn avl_tree_insert<T: Clone>(tree: &mut AVLTree<T>, key: T, value: T) -> Option<Box<AVLTreeNode<T>>> {\n    let mut rover = &mut tree.root_node;\n    let mut previous_node = None;\n\n    while let Some(node) = rover {\n        previous_node = Some(Rc::new(RefCell::new(node.clone())));\n        if (tree.compare_func)(key.clone(), node.key.clone()) < 0 {\n            rover = &mut node.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize];\n        } else {\n            rover = &mut node.children[AVLTreeNodeSide::AvlTreeNodeRight as usize];\n        }\n    }\n\n    let new_node = Box::new(AVLTreeNode {\n        children: [None, None],\n        parent: previous_node.clone(),\n        key,\n        value,\n        height: 1,\n    });\n\n    *rover = Some(new_node.clone());\n\n    if let Some(previous) = previous_node {\n        avl_tree_balance_to_root(tree, &mut *previous.borrow_mut());\n    }\n\n    tree.num_nodes += 1;\n\n    Some(new_node)\n}\n\npub fn avl_tree_node_key<T>(node: &AVLTreeNode<T>) -> &T {\n    &node.key\n}\n\npub fn avl_tree_rotate<T: Clone>(tree: &mut AVLTree<T>, node: &mut AVLTreeNode<T>, direction: AVLTreeNodeSide) -> Option<Box<AVLTreeNode<T>>> {\n    let direction_index = direction as usize;\n    let new_root = node.children[1 - direction_index].take();\n\n    if let Some(mut new_root) = new_root {\n        avl_tree_node_replace(tree, node, Some(&*new_root));\n\n        node.children[1 - direction_index] = new_root.children[direction_index].take();\n        new_root.children[direction_index] = Some(Box::new(node.clone()));\n\n        let node_clone = node.clone();\n        node.parent = Some(Rc::new(RefCell::new(*new_root.clone())));\n\n        if let Some(child) = node.children[1 - direction_index].as_mut() {\n            child.parent = Some(Rc::new(RefCell::new(node_clone)));\n        }\n\n        avl_tree_update_height(&mut *new_root);\n        avl_tree_update_height(node);\n\n        Some(new_root)\n    } else {\n        None\n    }\n}\n\npub fn avl_tree_node_child<T>(node: &AVLTreeNode<T>, side: AVLTreeNodeSide) -> Option<&Box<AVLTreeNode<T>>> {\n    match side {\n        AVLTreeNodeSide::AvlTreeNodeLeft | AVLTreeNodeSide::AvlTreeNodeRight => node.children[side as usize].as_ref(),\n    }\n}\n\npub fn avl_tree_subtree_height<T>(node: &Option<Box<AVLTreeNode<T>>>) -> i32 {\n    if let Some(n) = node {\n        n.height\n    } else {\n        0\n    }\n}\n\npub fn create_tree() -> AVLTree<i32> {\n    let mut tree = avl_tree_new(int_compare).unwrap();\n\n    for i in 0..NUM_TEST_VALUES {\n        unsafe { test_array[i] = i as i32; }\n        avl_tree_insert(&mut tree, unsafe { test_array[i] }, unsafe { test_array[i] });\n    }\n\n    tree\n}\n\npub fn avl_tree_balance_to_root<T: Clone>(tree: &mut AVLTree<T>, node: &mut AVLTreeNode<T>) {\n    let mut rover = Some(Rc::new(RefCell::new(node.clone())));\n\n    while let Some(current_rover) = rover {\n        let mut current_rover_borrowed = current_rover.borrow_mut();\n\n        // Balance this node if necessary\n        let balanced_node = avl_tree_node_balance(tree, &mut *current_rover_borrowed);\n        rover = balanced_node.parent.clone();\n\n        // Go to this node's parent\n        rover = rover.map(|parent| Rc::clone(&parent));\n    }\n}\n\nfn main(){}\n //编译报错信息：error[E0308]: mismatched types\n   --> ../tmp/temp.rs:220:47\n    |\n220 |     let left_height = avl_tree_subtree_height(left_subtree);\n    |                       ----------------------- ^^^^^^^^^^^^ expected `&Option<Box<...>>`, found `Option<&Box<...>>`\n    |                       |\n    |                       arguments to this function are incorrect\n    |\n",
        "test_avl_tree_to_array": "use std::rc::Rc;\nuse std::cell::RefCell;\n\npub enum AVLTreeNodeSide {\n    AvlTreeNodeLeft,\n    AvlTreeNodeRight,\n}\n\nimpl Clone for AVLTreeNodeSide {\n    fn clone(&self) -> Self {\n        match self {\n            AVLTreeNodeSide::AvlTreeNodeLeft => AVLTreeNodeSide::AvlTreeNodeLeft,\n            AVLTreeNodeSide::AvlTreeNodeRight => AVLTreeNodeSide::AvlTreeNodeRight,\n        }\n    }\n}\n\npub struct AVLTreeNode<T> {\n    pub children: [Option<Box<AVLTreeNode<T>>>; 2],\n    pub parent: Option<Rc<RefCell<AVLTreeNode<T>>>>,\n    pub key: T,\n    pub value: T,\n    pub height: i32,\n}\n\nimpl<T: Clone> Clone for AVLTreeNode<T> {\n    fn clone(&self) -> Self {\n        AVLTreeNode {\n            children: self.children.clone(),\n            parent: self.parent.clone(),\n            key: self.key.clone(),\n            value: self.value.clone(),\n            height: self.height,\n        }\n    }\n}\n\npub struct AVLTree<T> {\n    pub root_node: Option<Box<AVLTreeNode<T>>>, \n    pub compare_func: fn(T, T) -> i32,\n    pub num_nodes: u32,\n}\n\npub fn avl_tree_insert<T: Clone + Ord>(tree: &mut AVLTree<T>, key: T, value: T) -> Option<Box<AVLTreeNode<T>>> {\n    let mut rover = &mut tree.root_node;\n    let mut previous_node = None;\n\n    while let Some(node) = rover {\n        previous_node = Some(Rc::new(RefCell::new(node.clone())));\n        if key.clone() < node.key.clone() {\n            rover = &mut node.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize];\n        } else {\n            rover = &mut node.children[AVLTreeNodeSide::AvlTreeNodeRight as usize];\n        }\n    }\n\n    let new_node = Box::new(AVLTreeNode {\n        children: [None, None],\n        parent: previous_node.clone(),\n        key,\n        value,\n        height: 1,\n    });\n\n    *rover = Some(new_node.clone());\n\n    if let Some(previous) = previous_node {\n        avl_tree_balance_to_root(tree, &mut *previous.borrow_mut());\n    }\n\n    tree.num_nodes += 1;\n\n    Some(new_node)\n}\n\npub fn avl_tree_node_key<T>(node: &AVLTreeNode<T>) -> &T {\n    &node.key\n}\n\npub fn avl_tree_rotate<T: Clone + Ord>(tree: &mut AVLTree<T>, node: &mut AVLTreeNode<T>, direction: AVLTreeNodeSide) -> Option<Box<AVLTreeNode<T>>> {\n    let direction_index = direction as usize;\n    let new_root = node.children[1 - direction_index].take();\n\n    if let Some(mut new_root) = new_root {\n        avl_tree_node_replace(tree, node, Some(&*new_root));\n\n        node.children[1 - direction_index] = new_root.children[direction_index].take();\n        new_root.children[direction_index] = Some(Box::new(node.clone()));\n\n        let node_clone = node.clone();\n        node.parent = Some(Rc::new(RefCell::new(*new_root.clone())));\n\n        if let Some(child) = node.children[1 - direction_index].as_mut() {\n            child.parent = Some(Rc::new(RefCell::new(node_clone)));\n        }\n\n        avl_tree_update_height(&mut *new_root);\n        avl_tree_update_height(node);\n\n        Some(new_root)\n    } else {\n        None\n    }\n}\n\npub fn avl_tree_node_child<T>(node: &AVLTreeNode<T>, side: AVLTreeNodeSide) -> Option<&Box<AVLTreeNode<T>>> {\n    match side {\n        AVLTreeNodeSide::AvlTreeNodeLeft | AVLTreeNodeSide::AvlTreeNodeRight => node.children[side as usize].as_ref(),\n    }\n}\n\npub fn avl_tree_subtree_height<T>(node: &Option<Box<AVLTreeNode<T>>>) -> i32 {\n    if let Some(n) = node {\n        n.height\n    } else {\n        0\n    }\n}\n\npub fn avl_tree_balance_to_root<T: Clone + Ord>(tree: &mut AVLTree<T>, node: &mut AVLTreeNode<T>) {\n    let mut rover = Some(Rc::new(RefCell::new(node.clone())));\n\n    while let Some(current_rover) = rover {\n        let mut current_rover_borrowed = current_rover.borrow_mut();\n\n        // Balance this node if necessary\n        let balanced_node = avl_tree_node_balance(tree, &mut *current_rover_borrowed);\n        rover = balanced_node.parent.clone();\n\n        // Go to this node's parent\n        rover = rover.map(|parent| Rc::clone(&parent));\n    }\n}\n\npub fn avl_tree_to_array_add_subtree<T: Clone>(subtree: &Option<Box<AVLTreeNode<T>>>, array: &mut [T], index: &mut usize) {\n    if let Some(node) = subtree {\n        avl_tree_to_array_add_subtree(&node.children[0], array, index);\n        array[*index] = node.key.clone();\n        *index += 1;\n        avl_tree_to_array_add_subtree(&node.children[1], array, index);\n    }\n}\n\npub fn avl_tree_to_array<T: Clone>(tree: &AVLTree<T>) -> Vec<T> {\n    let mut array = vec![tree.root_node.as_ref().unwrap().key.clone(); tree.num_nodes as usize];\n    let mut index = 0;\n\n    /* Add all keys */\n    avl_tree_to_array_add_subtree(&tree.root_node, &mut array, &mut index);\n\n    array\n}\n\npub fn avl_tree_new<T>(compare_func: fn(T, T) -> i32) -> Option<AVLTree<T>> {\n    let new_tree = AVLTree {\n        root_node: None,\n        compare_func,\n        num_nodes: 0,\n    };\n\n    Some(new_tree)\n}\n\npub fn avl_tree_free<T>(tree: &mut AVLTree<T>) {\n    avl_tree_free_subtree(tree.root_node.take());\n}\n\npub fn avl_tree_update_height<T>(node: &mut AVLTreeNode<T>) {\n    let left_height = avl_tree_subtree_height(&node.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize]);\n    let right_height = avl_tree_subtree_height(&node.children[AVLTreeNodeSide::AvlTreeNodeRight as usize]);\n\n    if left_height > right_height {\n        node.height = left_height + 1;\n    } else {\n        node.height = right_height + 1;\n    }\n}\n\npub fn avl_tree_node_balance<'a, T: Clone + Ord>(tree: &'a mut AVLTree<T>, node: &'a mut AVLTreeNode<T>) -> &'a mut AVLTreeNode<T> {\n    let left_subtree = &node.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize];\n    let right_subtree = &node.children[AVLTreeNodeSide::AvlTreeNodeRight as usize];\n    let mut diff = avl_tree_subtree_height(right_subtree) - avl_tree_subtree_height(left_subtree);\n\n    if diff >= 2 {\n        let child = node.children[AVLTreeNodeSide::AvlTreeNodeRight as usize].as_mut().unwrap();\n\n        if avl_tree_subtree_height(&child.children[AVLTreeNodeSide::AvlTreeNodeRight as usize])\n            < avl_tree_subtree_height(&child.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize]) {\n            avl_tree_rotate(tree, child, AVLTreeNodeSide::AvlTreeNodeRight);\n        }\n\n        let rotated_node = avl_tree_rotate(tree, node, AVLTreeNodeSide::AvlTreeNodeLeft).unwrap();\n        *node = *rotated_node;\n    } else if diff <= -2 {\n        let child = node.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize].as_mut().unwrap();\n\n        if avl_tree_subtree_height(&child.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize])\n            < avl_tree_subtree_height(&child.children[AVLTreeNodeSide::AvlTreeNodeRight as usize]) {\n            avl_tree_rotate(tree, child, AVLTreeNodeSide::AvlTreeNodeLeft);\n        }\n\n        let rotated_node = avl_tree_rotate(tree, node, AVLTreeNodeSide::AvlTreeNodeRight).unwrap();\n        *node = *rotated_node;\n    }\n\n    avl_tree_update_height(node);\n    node\n}\n\npub const NUM_TEST_VALUES: usize = 1000;\npub static mut test_array: [i32; NUM_TEST_VALUES] = [0; NUM_TEST_VALUES];\n\npub fn avl_tree_root_node<T>(tree: &AVLTree<T>) -> Option<&Box<AVLTreeNode<T>>> {\n    tree.root_node.as_ref()\n}\n\npub fn avl_tree_node_parent_side<T>(node: &AVLTreeNode<T>) -> AVLTreeNodeSide {\n    if let Some(parent) = &node.parent {\n        let parent_borrowed = parent.borrow();\n        if parent_borrowed.children[0].as_ref().map_or(false, |child| child.as_ref() as *const AVLTreeNode<T> == node) {\n            return AVLTreeNodeSide::AvlTreeNodeLeft;\n        } else if parent_borrowed.children[1].as_ref().map_or(false, |child| child.as_ref() as *const AVLTreeNode<T> == node) {\n            return AVLTreeNodeSide::AvlTreeNodeRight;\n        }\n    }\n    panic!(\"Node does not have a valid parent or is not a child of its parent\");\n}\n\npub fn avl_tree_num_entries<T>(tree: &AVLTree<T>) -> u32 {\n    tree.num_nodes\n}\n\npub fn avl_tree_node_replace<T: Clone>(tree: &mut AVLTree<T>, node1: &mut AVLTreeNode<T>, node2: Option<&AVLTreeNode<T>>) {\n    let side;\n\n    if let Some(node2) = node2 {\n        let node2_clone = node2.clone();\n        if let Some(parent) = node1.parent.clone() {\n            let mut parent_borrowed = parent.borrow_mut();\n            side = avl_tree_node_parent_side(node1);\n            parent_borrowed.children[side as usize] = Some(Box::new(node2_clone));\n\n            avl_tree_update_height(&mut *parent_borrowed);\n        }\n    }\n\n    if node1.parent.is_none() {\n        tree.root_node = node2.cloned().map(|n| Box::new(n));\n    }\n}\n\npub fn avl_tree_node_parent<T>(node: &AVLTreeNode<T>) -> Option<Rc<RefCell<AVLTreeNode<T>>>> {\n    node.parent.clone()\n}\n\npub fn avl_tree_free_subtree<T>(node: Option<Box<AVLTreeNode<T>>>) {\n    if let Some(mut n) = node {\n        avl_tree_free_subtree(n.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize].take());\n        avl_tree_free_subtree(n.children[AVLTreeNodeSide::AvlTreeNodeRight as usize].take());\n    }\n}\n\nfn int_compare(a: i32, b: i32) -> i32 {\n    a.cmp(&b) as i32\n}\n\npub fn test_avl_tree_to_array() {\n    let mut tree = avl_tree_new(int_compare).unwrap();\n    let entries = vec![89, 23, 42, 4, 16, 15, 8, 99, 50, 30];\n    let sorted = vec![4, 8, 15, 16, 23, 30, 42, 50, 89, 99];\n    let num_entries = entries.len();\n\n    for entry in entries.iter() {\n        avl_tree_insert(&mut tree, entry.clone(), entry.clone());\n    }\n\n    assert_eq!(avl_tree_num_entries(&tree), num_entries as u32);\n\n    let array = avl_tree_to_array(&tree);\n\n    for (i, &value) in array.iter().enumerate() {\n        assert_eq!(value, sorted[i]);\n    }\n\n    avl_tree_free(&mut tree);\n}\n\npub fn find_subtree_height<T: Clone + Ord>(node: &Option<Box<AVLTreeNode<T>>>) -> i32 {\n    if let Some(n) = node {\n        let left_height = find_subtree_height(&n.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize]);\n        let right_height = find_subtree_height(&n.children[AVLTreeNodeSide::AvlTreeNodeRight as usize]);\n\n        if left_height > right_height {\n            left_height + 1\n        } else {\n            right_height + 1\n        }\n    } else {\n        0\n    }\n}\n\npub fn validate_subtree<T: Clone + Ord>(node: &Option<Box<AVLTreeNode<T>>>, counter: &mut i32) -> i32 {\n    if let Some(n) = node {\n        let left_node = avl_tree_node_child(n, AVLTreeNodeSide::AvlTreeNodeLeft);\n        let right_node = avl_tree_node_child(n, AVLTreeNodeSide::AvlTreeNodeRight);\n\n        if let Some(left) = left_node {\n            assert_eq!(avl_tree_node_parent(left).unwrap().as_ref() as *const AVLTreeNode<T>, n as *const AVLTreeNode<T>);\n        }\n        if let Some(right) = right_node {\n            assert_eq!(avl_tree_node_parent(right).unwrap().as_ref() as *const AVLTreeNode<T>, n as *const AVLTreeNode<T>);\n        }\n\n        let left_height = validate_subtree(left_node, counter);\n        let key = avl_tree_node_key(n);\n\n        assert!(*key > *counter);\n        *counter = *key;\n\n        let right_height = validate_subtree(right_node, counter);\n\n        assert_eq!(avl_tree_subtree_height(left_node), left_height);\n        assert_eq!(avl_tree_subtree_height(right_node), right_height);\n\n        assert!(left_height - right_height < 2 && right_height - left_height < 2);\n\n        if left_height > right_height {\n            left_height + 1\n        } else {\n            right_height + 1\n        }\n    } else {\n        0\n    }\n}\n\npub fn validate_tree<T: Clone + Ord>(tree: &AVLTree<T>) {\n    let root_node = avl_tree_root_node(tree);\n    let mut counter = -1;\n\n    if let Some(root) = root_node {\n        let height = find_subtree_height(root);\n        assert_eq!(avl_tree_subtree_height(root), height);\n    }\n\n    validate_subtree(root_node, &mut counter);\n}\n\nfn main(){}\n //编译报错信息：error[E0308]: mismatched types\n  --> ../tmp/temp.rs:59:17\n   |\n59 |         parent: previous_node.clone(),\n   |                 ^^^^^^^^^^^^^^^^^^^^^ expected `AVLTreeNode<_>`, found `Box<AVLTreeNode<T>>`\n   |\n   = note: expected enum `Option<Rc<RefCell<AVLTreeNode<_>>>>`\n              found enum `Option<Rc<RefCell<Box<AVLTreeNode<T>>>>>`\n\nerror[E0308]: mismatched types\n   --> ../tmp/temp.rs:315:44\n    |\n315 |         let left_height = validate_subtree(left_node, counter);\n    |                           ---------------- ^^^^^^^^^ expected `&Option<Box<...>>`, found `Option<&Box<...>>`\n    |                           |\n    |                           arguments to this function are incorrect\n    |\n",
        "test_avl_tree_free": "\npub const NUM_TEST_VALUES: usize = 1000;\npub static mut test_array: [i32; NUM_TEST_VALUES] = [0; NUM_TEST_VALUES];\n\npub fn avl_tree_insert<T: Clone>(tree: &mut AVLTree<T>, key: T, value: T) -> Option<Box<AVLTreeNode<T>>> {\n    let mut rover = &mut tree.root_node;\n    let mut previous_node = None;\n\n    while let Some(node) = rover {\n        previous_node = Some(Rc::new(RefCell::new(node.clone())));\n        if (tree.compare_func)(key.clone(), node.key.clone()) < 0 {\n            rover = &mut node.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize];\n        } else {\n            rover = &mut node.children[AVLTreeNodeSide::AvlTreeNodeRight as usize];\n        }\n    }\n\n    let new_node = Box::new(AVLTreeNode {\n        children: [None, None],\n        parent: previous_node.clone(),\n        key,\n        value,\n        height: 1,\n    });\n\n    *rover = Some(new_node.clone());\n\n    if let Some(previous) = previous_node {\n        avl_tree_balance_to_root(tree, &mut *previous.borrow_mut());\n    }\n\n    tree.num_nodes += 1;\n\n    Some(new_node)\n}\n\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\npub enum AVLTreeNodeSide {\n    AvlTreeNodeLeft,\n    AvlTreeNodeRight,\n}\n\nimpl Clone for AVLTreeNodeSide {\n    fn clone(&self) -> Self {\n        match self {\n            AVLTreeNodeSide::AvlTreeNodeLeft => AVLTreeNodeSide::AvlTreeNodeLeft,\n            AVLTreeNodeSide::AvlTreeNodeRight => AVLTreeNodeSide::AvlTreeNodeRight,\n        }\n    }\n}\n\npub struct AVLTreeNode<T> {\n    pub children: [Option<Box<AVLTreeNode<T>>>; 2],\n    pub parent: Option<Rc<RefCell<AVLTreeNode<T>>>>,\n    pub key: T,\n    pub value: T,\n    pub height: i32,\n}\n\nimpl<T: Clone> Clone for AVLTreeNode<T> {\n    fn clone(&self) -> Self {\n        AVLTreeNode {\n            children: self.children.clone(),\n            parent: self.parent.clone(),\n            key: self.key.clone(),\n            value: self.value.clone(),\n            height: self.height,\n        }\n    }\n}\n\npub struct AVLTree<T> {\n    pub root_node: Option<Box<AVLTreeNode<T>>>,\n    pub compare_func: fn(T, T) -> i32,\n    pub num_nodes: u32,\n}\n\npub fn avl_tree_update_height<T>(node: &mut AVLTreeNode<T>) {\n    let left_height = avl_tree_subtree_height(&node.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize]);\n    let right_height = avl_tree_subtree_height(&node.children[AVLTreeNodeSide::AvlTreeNodeRight as usize]);\n\n    if left_height > right_height {\n        node.height = left_height + 1;\n    } else {\n        node.height = right_height + 1;\n    }\n}\n\npub fn avl_tree_rotate<T: Clone>(tree: &mut AVLTree<T>, node: &mut AVLTreeNode<T>, direction: AVLTreeNodeSide) -> Option<Box<AVLTreeNode<T>>> {\n    let direction_index = direction as usize;\n    let new_root = node.children[1 - direction_index].take();\n\n    if let Some(mut new_root) = new_root {\n        avl_tree_node_replace(tree, node, Some(&*new_root));\n\n        node.children[1 - direction_index] = new_root.children[direction_index].take();\n        new_root.children[direction_index] = Some(Box::new(node.clone()));\n\n        let node_clone = node.clone();\n        node.parent = Some(Rc::new(RefCell::new(*new_root.clone())));\n\n        if let Some(child) = node.children[1 - direction_index].as_mut() {\n            child.parent = Some(Rc::new(RefCell::new(node_clone)));\n        }\n\n        avl_tree_update_height(&mut *new_root);\n        avl_tree_update_height(node);\n\n        Some(new_root)\n    } else {\n        None\n    }\n}\n\npub fn avl_tree_node_balance<'a, T: Clone>(tree: &'a mut AVLTree<T>, node: &'a mut AVLTreeNode<T>) -> &'a mut AVLTreeNode<T> {\n    let left_subtree = &node.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize];\n    let right_subtree = &node.children[AVLTreeNodeSide::AvlTreeNodeRight as usize];\n    let diff = avl_tree_subtree_height(right_subtree) - avl_tree_subtree_height(left_subtree);\n\n    if diff >= 2 {\n        let child = node.children[AVLTreeNodeSide::AvlTreeNodeRight as usize].as_mut().unwrap();\n\n        if avl_tree_subtree_height(&child.children[AVLTreeNodeSide::AvlTreeNodeRight as usize])\n            < avl_tree_subtree_height(&child.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize]) {\n            avl_tree_rotate(tree, child, AVLTreeNodeSide::AvlTreeNodeRight);\n        }\n\n        let rotated_node = avl_tree_rotate(tree, node, AVLTreeNodeSide::AvlTreeNodeLeft).unwrap();\n        *node = *rotated_node;\n    } else if diff <= -2 {\n        let child = node.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize].as_mut().unwrap();\n\n        if avl_tree_subtree_height(&child.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize])\n            < avl_tree_subtree_height(&child.children[AVLTreeNodeSide::AvlTreeNodeRight as usize]) {\n            avl_tree_rotate(tree, child, AVLTreeNodeSide::AvlTreeNodeLeft);\n        }\n\n        let rotated_node = avl_tree_rotate(tree, node, AVLTreeNodeSide::AvlTreeNodeRight).unwrap();\n        *node = *rotated_node;\n    }\n\n    avl_tree_update_height(node);\n    node\n}\n\npub fn avl_tree_node_parent_side<T>(node: &AVLTreeNode<T>) -> AVLTreeNodeSide {\n    if let Some(parent) = &node.parent {\n        let parent_borrowed = parent.borrow();\n        if parent_borrowed.children[0].as_ref().map_or(false, |child| child.as_ref() as *const AVLTreeNode<T> == node) {\n            return AVLTreeNodeSide::AvlTreeNodeLeft;\n        } else if parent_borrowed.children[1].as_ref().map_or(false, |child| child.as_ref() as *const AVLTreeNode<T> == node) {\n            return AVLTreeNodeSide::AvlTreeNodeRight;\n        }\n    }\n    panic!(\"Node does not have a valid parent or is not a child of its parent\");\n}\n\npub fn avl_tree_node_replace<T: Clone>(tree: &mut AVLTree<T>, node1: &mut AVLTreeNode<T>, node2: Option<&AVLTreeNode<T>>) {\n    let side;\n\n    if let Some(node2) = node2 {\n        let node2_clone = node2.clone();\n        if let Some(parent) = node1.parent.clone() {\n            let mut parent_borrowed = parent.borrow_mut();\n            side = avl_tree_node_parent_side(node1);\n            parent_borrowed.children[side as usize] = Some(Box::new(node2_clone));\n\n            avl_tree_update_height(&mut *parent_borrowed);\n        }\n    }\n\n    if node1.parent.is_none() {\n        tree.root_node = node2.cloned().map(|n| Box::new(n));\n    }\n}\n\npub fn avl_tree_free_subtree<T>(node: Option<Box<AVLTreeNode<T>>>) {\n    if let Some(mut n) = node {\n        avl_tree_free_subtree(n.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize].take());\n        avl_tree_free_subtree(n.children[AVLTreeNodeSide::AvlTreeNodeRight as usize].take());\n    }\n}\n\npub fn avl_tree_subtree_height<T>(node: &Option<Box<AVLTreeNode<T>>>) -> i32 {\n    if let Some(n) = node {\n        n.height\n    } else {\n        0\n    }\n}\n\npub fn avl_tree_new<T>(compare_func: fn(T, T) -> i32) -> Option<AVLTree<T>> {\n    let new_tree = AVLTree {\n        root_node: None,\n        compare_func,\n        num_nodes: 0,\n    };\n\n    Some(new_tree)\n}\n\npub fn avl_tree_free<T>(tree: &mut AVLTree<T>) {\n    avl_tree_free_subtree(tree.root_node.take());\n}\n\npub fn create_tree() -> AVLTree<i32> {\n    let mut tree = avl_tree_new(int_compare).unwrap();\n\n    for i in 0..NUM_TEST_VALUES {\n        unsafe { test_array[i] = i as i32; }\n        avl_tree_insert(&mut tree, unsafe { test_array[i] }, unsafe { test_array[i] });\n    }\n\n    tree\n}\n\npub fn avl_tree_balance_to_root<T: Clone>(tree: &mut AVLTree<T>, node: &mut AVLTreeNode<T>) {\n    let mut rover = Some(Rc::new(RefCell::new(node.clone())));\n\n    while let Some(current_rover) = rover {\n        let mut current_rover_borrowed = current_rover.borrow_mut();\n\n        // Balance this node if necessary\n        let balanced_node = avl_tree_node_balance(tree, &mut *current_rover_borrowed);\n        rover = balanced_node.parent.clone();\n\n        // Go to this node's parent\n        rover = rover.map(|parent| Rc::clone(&parent));\n    }\n}\n\npub fn test_avl_tree_free() {\n    let mut tree: Option<AVLTree<i32>>;\n\n    // Try freeing an empty tree\n    tree = avl_tree_new(int_compare);\n    if let Some(mut_tree) = tree {\n        avl_tree_free(&mut mut_tree);\n    }\n\n    // Create a big tree and free it\n    tree = Some(create_tree());\n    if let Some(mut mut_tree) = tree {\n        avl_tree_free(&mut mut_tree);\n    }\n}\n\npub fn int_compare(a: i32, b: i32) -> i32 {\n    match a.cmp(&b) {\n        std::cmp::Ordering::Less => -1,\n        std::cmp::Ordering::Equal => 0,\n        std::cmp::Ordering::Greater => 1,\n    }\n}\n\nfn main() {}\n\n //编译报错信息：error[E0308]: mismatched types\n  --> ../tmp/temp.rs:20:17\n   |\n20 |         parent: previous_node.clone(),\n   |                 ^^^^^^^^^^^^^^^^^^^^^ expected `AVLTreeNode<_>`, found `Box<AVLTreeNode<T>>`\n   |\n   = note: expected enum `Option<Rc<RefCell<AVLTreeNode<_>>>>`\n              found enum `Option<Rc<RefCell<Box<AVLTreeNode<T>>>>>`\n\nerror[E0596]: cannot borrow `mut_tree` as mutable, as it is not declared as mutable\n   --> ../tmp/temp.rs:240:23\n    |\n240 |         avl_tree_free(&mut mut_tree);\n    |                       ^^^^^^^^^^^^^ cannot borrow as mutable\n    |\n"
    },
    "avl-tree": {
        "avl_tree_node_get_replacement": "use std::rc::Rc;\nuse std::cell::RefCell;\n\npub enum AVLTreeNodeSide {\n    AvlTreeNodeLeft,\n    AvlTreeNodeRight,\n}\n\nimpl Clone for AVLTreeNodeSide {\n    fn clone(&self) -> Self {\n        match self {\n            AVLTreeNodeSide::AvlTreeNodeLeft => AVLTreeNodeSide::AvlTreeNodeLeft,\n            AVLTreeNodeSide::AvlTreeNodeRight => AVLTreeNodeSide::AvlTreeNodeRight,\n        }\n    }\n}\n\npub struct AVLTreeNode<T> {\n    pub children: [Option<Box<AVLTreeNode<T>>>; 2],\n    pub parent: Option<Rc<RefCell<AVLTreeNode<T>>>>,\n    pub key: T,\n    pub value: T,\n    pub height: i32,\n}\n\nimpl<T: Clone> Clone for AVLTreeNode<T> {\n    fn clone(&self) -> Self {\n        AVLTreeNode {\n            children: self.children.clone(),\n            parent: self.parent.clone(),\n            key: self.key.clone(),\n            value: self.value.clone(),\n            height: self.height,\n        }\n    }\n}\n\npub struct AVLTree<T> {\n    pub root_node: Option<Box<AVLTreeNode<T>>>, \n    pub compare_func: fn(T, T) -> i32,\n    pub num_nodes: u32,\n}\n\npub fn avl_tree_update_height<T>(node: &mut AVLTreeNode<T>) {\n    let left_height = avl_tree_subtree_height(&node.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize]);\n    let right_height = avl_tree_subtree_height(&node.children[AVLTreeNodeSide::AvlTreeNodeRight as usize]);\n\n    if left_height > right_height {\n        node.height = left_height + 1;\n    } else {\n        node.height = right_height + 1;\n    }\n}\n\npub fn avl_tree_node_parent_side<T>(node: &AVLTreeNode<T>) -> AVLTreeNodeSide {\n    if let Some(parent) = &node.parent {\n        let parent_borrowed = parent.borrow();\n        if parent_borrowed.children[0].as_ref().map_or(false, |child| child.as_ref() as *const AVLTreeNode<T> == node) {\n            return AVLTreeNodeSide::AvlTreeNodeLeft;\n        } else if parent_borrowed.children[1].as_ref().map_or(false, |child| child.as_ref() as *const AVLTreeNode<T> == node) {\n            return AVLTreeNodeSide::AvlTreeNodeRight;\n        }\n    }\n    panic!(\"Node does not have a valid parent or is not a child of its parent\");\n}\n\npub fn avl_tree_node_replace<T: Clone>(tree: &mut AVLTree<T>, node1: &mut AVLTreeNode<T>, node2: Option<&AVLTreeNode<T>>) {\n    let side;\n\n    if let Some(node2) = node2 {\n        let node2_clone = node2.clone();\n        if let Some(parent) = node1.parent.clone() {\n            let mut parent_borrowed = parent.borrow_mut();\n            side = avl_tree_node_parent_side(node1);\n            parent_borrowed.children[side as usize] = Some(Box::new(node2_clone));\n\n            avl_tree_update_height(&mut *parent_borrowed);\n        }\n    }\n\n    if node1.parent.is_none() {\n        tree.root_node = node2.cloned().map(|n| Box::new(n));\n    }\n}\n\npub fn avl_tree_subtree_height<T>(node: &Option<Box<AVLTreeNode<T>>>) -> i32 {\n    if let Some(n) = node {\n        n.height\n    } else {\n        0\n    }\n}\n\npub fn avl_tree_node_get_replacement<T: Clone>(tree: &mut AVLTree<T>, node: &mut AVLTreeNode<T>) -> Option<Box<AVLTreeNode<T>>> {\n    let left_subtree = node.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize].take();\n    let right_subtree = node.children[AVLTreeNodeSide::AvlTreeNodeRight as usize].take();\n\n    if left_subtree.is_none() && right_subtree.is_none() {\n        return None;\n    }\n\n    let left_height = avl_tree_subtree_height(&left_subtree);\n    let right_height = avl_tree_subtree_height(&right_subtree);\n\n    let side = if left_height < right_height {\n        AVLTreeNodeSide::AvlTreeNodeRight\n    } else {\n        AVLTreeNodeSide::AvlTreeNodeLeft\n    };\n\n    let mut result = node.children[side as usize].take().unwrap();\n\n    while result.children[1 - side as usize].is_some() {\n        result = result.children[1 - side as usize].take().unwrap();\n    }\n\n    let child = result.children[side as usize].take();\n    avl_tree_node_replace(tree, &mut *result, child.as_deref());\n\n    if let Some(parent) = result.parent.clone() {\n        avl_tree_update_height(&mut parent.borrow_mut());\n    }\n\n    Some(result)\n}\n\nfn main(){}\n //编译报错信息：error[E0382]: use of moved value: `side`\n   --> ../tmp/temp.rs:113:31\n    |\n105 |     let side = if left_height < right_height {\n    |         ---- move occurs because `side` has type `AVLTreeNodeSide`, which does not implement the `Copy` trait\n...\n111 |     let mut result = node.children[side as usize].take().unwrap();\n    |                                    ---- value moved here\n112 |\n113 |     while result.children[1 - side as usize].is_some() {\n    |                               ^^^^ value used here after move\n    |\n",
        "avl_tree_remove_node": "use std::rc::Rc;\nuse std::cell::RefCell;\n\npub enum AVLTreeNodeSide {\n    AvlTreeNodeLeft,\n    AvlTreeNodeRight,\n}\n\nimpl Clone for AVLTreeNodeSide {\n    fn clone(&self) -> Self {\n        match self {\n            AVLTreeNodeSide::AvlTreeNodeLeft => AVLTreeNodeSide::AvlTreeNodeLeft,\n            AVLTreeNodeSide::AvlTreeNodeRight => AVLTreeNodeSide::AvlTreeNodeRight,\n        }\n    }\n}\n\npub struct AVLTreeNode<T> {\n    pub children: [Option<Box<AVLTreeNode<T>>>; 2],\n    pub parent: Option<Rc<RefCell<AVLTreeNode<T>>>>,\n    pub key: T,\n    pub value: T,\n    pub height: i32,\n}\n\nimpl<T: Clone> Clone for AVLTreeNode<T> {\n    fn clone(&self) -> Self {\n        AVLTreeNode {\n            children: self.children.clone(),\n            parent: self.parent.clone(),\n            key: self.key.clone(),\n            value: self.value.clone(),\n            height: self.height,\n        }\n    }\n}\n\npub struct AVLTree<T> {\n    pub root_node: Option<Box<AVLTreeNode<T>>>, \n    pub compare_func: fn(T, T) -> i32,\n    pub num_nodes: u32,\n}\n\npub fn avl_tree_update_height<T>(node: &mut AVLTreeNode<T>) {\n    let left_height = avl_tree_subtree_height(&node.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize]);\n    let right_height = avl_tree_subtree_height(&node.children[AVLTreeNodeSide::AvlTreeNodeRight as usize]);\n\n    if left_height > right_height {\n        node.height = left_height + 1;\n    } else {\n        node.height = right_height + 1;\n    }\n}\n\npub fn avl_tree_rotate<T: Clone>(tree: &mut AVLTree<T>, node: &mut AVLTreeNode<T>, direction: AVLTreeNodeSide) -> Option<Box<AVLTreeNode<T>>> {\n    let direction_index = direction as usize;\n    let new_root = node.children[1 - direction_index].take();\n\n    if let Some(mut new_root) = new_root {\n        avl_tree_node_replace(tree, node, Some(&*new_root));\n\n        node.children[1 - direction_index] = new_root.children[direction_index].take();\n        new_root.children[direction_index] = Some(Box::new(node.clone()));\n\n        let node_clone = node.clone();\n        node.parent = new_root.parent.clone();\n        new_root.parent = Some(Rc::new(RefCell::new(node_clone)));\n\n        if let Some(child) = node.children[1 - direction_index].as_mut() {\n            child.parent = Some(Rc::new(RefCell::new(node.clone())));\n        }\n\n        avl_tree_update_height(&mut *new_root);\n        avl_tree_update_height(node);\n\n        Some(new_root)\n    } else {\n        None\n    }\n}\n\npub fn avl_tree_node_balance<'a, T: Clone>(tree: &'a mut AVLTree<T>, node: &'a mut AVLTreeNode<T>) -> &'a mut AVLTreeNode<T> {\n    let left_subtree = &node.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize];\n    let right_subtree = &node.children[AVLTreeNodeSide::AvlTreeNodeRight as usize];\n    let mut diff = avl_tree_subtree_height(right_subtree) - avl_tree_subtree_height(left_subtree);\n\n    if diff >= 2 {\n        let child = node.children[AVLTreeNodeSide::AvlTreeNodeRight as usize].as_mut().unwrap();\n\n        if avl_tree_subtree_height(&child.children[AVLTreeNodeSide::AvlTreeNodeRight as usize])\n            < avl_tree_subtree_height(&child.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize]) {\n            avl_tree_rotate(tree, child, AVLTreeNodeSide::AvlTreeNodeRight);\n        }\n\n        let rotated_node = avl_tree_rotate(tree, node, AVLTreeNodeSide::AvlTreeNodeLeft).unwrap();\n        *node = *rotated_node;\n    } else if diff <= -2 {\n        let child = node.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize].as_mut().unwrap();\n\n        if avl_tree_subtree_height(&child.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize])\n            < avl_tree_subtree_height(&child.children[AVLTreeNodeSide::AvlTreeNodeRight as usize]) {\n            avl_tree_rotate(tree, child, AVLTreeNodeSide::AvlTreeNodeLeft);\n        }\n\n        let rotated_node = avl_tree_rotate(tree, node, AVLTreeNodeSide::AvlTreeNodeRight).unwrap();\n        *node = *rotated_node;\n    }\n\n    avl_tree_update_height(node);\n    node\n}\n\npub fn avl_tree_node_parent_side<T>(node: &AVLTreeNode<T>) -> AVLTreeNodeSide {\n    if let Some(parent) = &node.parent {\n        let parent_borrowed = parent.borrow();\n        if parent_borrowed.children[0].as_ref().map_or(false, |child| child.as_ref() as *const AVLTreeNode<T> == node) {\n            return AVLTreeNodeSide::AvlTreeNodeLeft;\n        } else if parent_borrowed.children[1].as_ref().map_or(false, |child| child.as_ref() as *const AVLTreeNode<T> == node) {\n            return AVLTreeNodeSide::AvlTreeNodeRight;\n        }\n    }\n    panic!(\"Node does not have a valid parent or is not a child of its parent\");\n}\n\npub fn avl_tree_node_replace<T: Clone>(tree: &mut AVLTree<T>, node1: &mut AVLTreeNode<T>, node2: Option<&AVLTreeNode<T>>) {\n    let side;\n\n    if let Some(node2) = node2 {\n        let node2_clone = node2.clone();\n        if let Some(parent) = node1.parent.clone() {\n            let mut parent_borrowed = parent.borrow_mut();\n            side = avl_tree_node_parent_side(node1);\n            parent_borrowed.children[side as usize] = Some(Box::new(node2_clone));\n\n            avl_tree_update_height(&mut *parent_borrowed);\n        }\n    }\n\n    if node1.parent.is_none() {\n        tree.root_node = node2.cloned().map(|n| Box::new(n));\n    }\n}\n\npub fn avl_tree_subtree_height<T>(node: &Option<Box<AVLTreeNode<T>>>) -> i32 {\n    if let Some(n) = node {\n        n.height\n    } else {\n        0\n    }\n}\n\npub fn avl_tree_balance_to_root<T: Clone>(tree: &mut AVLTree<T>, node: &mut AVLTreeNode<T>) {\n    let mut rover = node.parent.clone();\n\n    while let Some(current_rover) = rover {\n        let mut current_rover_borrowed = current_rover.borrow_mut();\n\n        // Balance this node if necessary\n        let balanced_node = avl_tree_node_balance(tree, &mut *current_rover_borrowed);\n        rover = balanced_node.parent.clone();\n    }\n}\n\npub fn avl_tree_remove_node<T: Clone>(tree: &mut AVLTree<T>, node: &mut AVLTreeNode<T>) {\n    let mut swap_node = avl_tree_node_get_replacement(tree, node);\n    let mut balance_startpoint = None;\n\n    if swap_node.is_none() {\n        avl_tree_node_replace(tree, node, None);\n        balance_startpoint = node.parent.clone();\n    } else {\n        let swap_node_unwrapped = swap_node.as_mut().unwrap();\n        if let Some(parent) = &swap_node_unwrapped.parent {\n            let parent_borrowed = parent.borrow();\n            if Rc::ptr_eq(&parent, &node.parent.as_ref().unwrap()) {\n                balance_startpoint = swap_node.clone();\n            } else {\n                balance_startpoint = swap_node_unwrapped.parent.clone();\n            }\n        }\n\n        for i in 0..2 {\n            swap_node_unwrapped.borrow_mut().children[i] = node.children[i].take();\n            if let Some(child) = &mut swap_node_unwrapped.borrow_mut().children[i] {\n                child.parent = swap_node.clone();\n            }\n        }\n\n        swap_node_unwrapped.borrow_mut().height = node.height;\n\n        avl_tree_node_replace(tree, node, Some(&*swap_node_unwrapped.borrow()));\n    }\n\n    tree.num_nodes -= 1;\n\n    if let Some(balance_startpoint) = balance_startpoint {\n        avl_tree_balance_to_root(tree, &mut *balance_startpoint.borrow_mut());\n    }\n}\n\npub fn avl_tree_node_get_replacement<T: Clone>(tree: &mut AVLTree<T>, node: &mut AVLTreeNode<T>) -> Option<Rc<RefCell<AVLTreeNode<T>>>> {\n    let left_subtree = &node.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize];\n    let right_subtree = &node.children[AVLTreeNodeSide::AvlTreeNodeRight as usize];\n\n    if left_subtree.is_none() && right_subtree.is_none() {\n        return None;\n    }\n\n    let left_height = avl_tree_subtree_height(left_subtree);\n    let right_height = avl_tree_subtree_height(right_subtree);\n\n    let side = if left_height < right_height {\n        AVLTreeNodeSide::AvlTreeNodeRight\n    } else {\n        AVLTreeNodeSide::AvlTreeNodeLeft\n    };\n\n    let mut result = node.children[side as usize].clone().unwrap();\n    let opposite_side = 1 - side as usize;\n\n    while result.borrow().children[opposite_side].is_some() {\n        result = result.borrow().children[opposite_side].clone().unwrap();\n    }\n\n    let child = result.borrow_mut().children[side as usize].take();\n    avl_tree_node_replace(tree, &mut *result.borrow_mut(), child.as_deref());\n\n    if let Some(parent) = &result.borrow().parent {\n        avl_tree_update_height(&mut *parent.borrow_mut());\n    }\n\n    Some(result)\n}\n\nfn main(){}\n //编译报错信息：error[E0609]: no field `parent` on type `&mut Rc<RefCell<AVLTreeNode<T>>>`\n   --> ../tmp/temp.rs:173:52\n    |\n173 |         if let Some(parent) = &swap_node_unwrapped.parent {\n    |                                                    ^^^^^^ unknown field\n\nerror[E0609]: no field `parent` on type `&mut Rc<RefCell<AVLTreeNode<T>>>`\n   --> ../tmp/temp.rs:178:58\n    |\n178 |                 balance_startpoint = swap_node_unwrapped.parent.clone();\n    |                                                          ^^^^^^ unknown field\n\nerror[E0599]: no method named `borrow` found for struct `Box<AVLTreeNode<T>>` in the current scope\n   --> ../tmp/temp.rs:221:18\n    |\n221 |     while result.borrow().children[opposite_side].is_some() {\n    |                  ^^^^^^\n    |\n",
        "avl_tree_remove": "use std::rc::Rc;\nuse std::cell::RefCell;\n\npub enum AVLTreeNodeSide {\n    AvlTreeNodeLeft,\n    AvlTreeNodeRight,\n}\n\nimpl Clone for AVLTreeNodeSide {\n    fn clone(&self) -> Self {\n        match self {\n            AVLTreeNodeSide::AvlTreeNodeLeft => AVLTreeNodeSide::AvlTreeNodeLeft,\n            AVLTreeNodeSide::AvlTreeNodeRight => AVLTreeNodeSide::AvlTreeNodeRight,\n        }\n    }\n}\n\npub struct AVLTreeNode<T> {\n    pub children: [Option<Box<AVLTreeNode<T>>>; 2],\n    pub parent: Option<Rc<RefCell<AVLTreeNode<T>>>>,\n    pub key: T,\n    pub value: T,\n    pub height: i32,\n}\n\nimpl<T: Clone> Clone for AVLTreeNode<T> {\n    fn clone(&self) -> Self {\n        AVLTreeNode {\n            children: self.children.clone(),\n            parent: self.parent.clone(),\n            key: self.key.clone(),\n            value: self.value.clone(),\n            height: self.height,\n        }\n    }\n}\n\npub struct AVLTree<T> {\n    pub root_node: Option<Box<AVLTreeNode<T>>>, \n    pub compare_func: fn(T, T) -> i32,\n    pub num_nodes: u32,\n}\n\npub fn avl_tree_update_height<T>(node: &mut AVLTreeNode<T>) {\n    let left_height = avl_tree_subtree_height(&node.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize]);\n    let right_height = avl_tree_subtree_height(&node.children[AVLTreeNodeSide::AvlTreeNodeRight as usize]);\n\n    if left_height > right_height {\n        node.height = left_height + 1;\n    } else {\n        node.height = right_height + 1;\n    }\n}\n\npub fn avl_tree_rotate<T: Clone>(tree: &mut AVLTree<T>, node: &mut AVLTreeNode<T>, direction: AVLTreeNodeSide) -> Option<Box<AVLTreeNode<T>>> {\n    let direction_index = direction as usize;\n    let new_root = node.children[1 - direction_index].take();\n\n    if let Some(mut new_root) = new_root {\n        avl_tree_node_replace(tree, node, Some(&*new_root));\n\n        node.children[1 - direction_index] = new_root.children[direction_index].take();\n        new_root.children[direction_index] = Some(Box::new(node.clone()));\n\n        let node_clone = node.clone();\n        node.parent = Some(Rc::new(RefCell::new(*new_root.clone())));\n\n        if let Some(child) = node.children[1 - direction_index].as_mut() {\n            child.parent = Some(Rc::new(RefCell::new(node_clone)));\n        }\n\n        avl_tree_update_height(&mut *new_root);\n        avl_tree_update_height(node);\n\n        Some(new_root)\n    } else {\n        None\n    }\n}\n\npub fn avl_tree_node_balance<'a, T: Clone>(tree: &'a mut AVLTree<T>, node: &'a mut AVLTreeNode<T>) -> &'a mut AVLTreeNode<T> {\n    let left_subtree = &node.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize];\n    let right_subtree = &node.children[AVLTreeNodeSide::AvlTreeNodeRight as usize];\n    let mut diff = avl_tree_subtree_height(right_subtree) - avl_tree_subtree_height(left_subtree);\n\n    if diff >= 2 {\n        let child = node.children[AVLTreeNodeSide::AvlTreeNodeRight as usize].as_mut().unwrap();\n\n        if avl_tree_subtree_height(&child.children[AVLTreeNodeSide::AvlTreeNodeRight as usize])\n            < avl_tree_subtree_height(&child.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize]) {\n            avl_tree_rotate(tree, child, AVLTreeNodeSide::AvlTreeNodeRight);\n        }\n\n        let rotated_node = avl_tree_rotate(tree, node, AVLTreeNodeSide::AvlTreeNodeLeft).unwrap();\n        *node = *rotated_node;\n    } else if diff <= -2 {\n        let child = node.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize].as_mut().unwrap();\n\n        if avl_tree_subtree_height(&child.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize])\n            < avl_tree_subtree_height(&child.children[AVLTreeNodeSide::AvlTreeNodeRight as usize]) {\n            avl_tree_rotate(tree, child, AVLTreeNodeSide::AvlTreeNodeLeft);\n        }\n\n        let rotated_node = avl_tree_rotate(tree, node, AVLTreeNodeSide::AvlTreeNodeRight).unwrap();\n        *node = *rotated_node;\n    }\n\n    avl_tree_update_height(node);\n    node\n}\n\npub fn avl_tree_node_parent_side<T>(node: &AVLTreeNode<T>) -> AVLTreeNodeSide {\n    if let Some(parent) = &node.parent {\n        let parent_borrowed = parent.borrow();\n        if parent_borrowed.children[0].as_ref().map_or(false, |child| child.as_ref() as *const AVLTreeNode<T> == node) {\n            return AVLTreeNodeSide::AvlTreeNodeLeft;\n        } else if parent_borrowed.children[1].as_ref().map_or(false, |child| child.as_ref() as *const AVLTreeNode<T> == node) {\n            return AVLTreeNodeSide::AvlTreeNodeRight;\n        }\n    }\n    panic!(\"Node does not have a valid parent or is not a child of its parent\");\n}\n\npub fn avl_tree_lookup_node<T: Clone>(tree: &AVLTree<T>, key: T) -> Option<&AVLTreeNode<T>> {\n    let mut node = tree.root_node.as_ref();\n\n    while let Some(n) = node {\n        let diff = (tree.compare_func)(key.clone(), n.key.clone());\n\n        if diff == 0 {\n            return Some(n);\n        } else if diff < 0 {\n            node = n.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize].as_ref();\n        } else {\n            node = n.children[AVLTreeNodeSide::AvlTreeNodeRight as usize].as_ref();\n        }\n    }\n\n    None\n}\n\npub fn avl_tree_node_replace<T: Clone>(tree: &mut AVLTree<T>, node1: &mut AVLTreeNode<T>, node2: Option<&AVLTreeNode<T>>) {\n    let side;\n\n    if let Some(node2) = node2 {\n        let node2_clone = node2.clone();\n        if let Some(parent) = node1.parent.clone() {\n            let mut parent_borrowed = parent.borrow_mut();\n            side = avl_tree_node_parent_side(node1);\n            parent_borrowed.children[side as usize] = Some(Box::new(node2_clone));\n\n            avl_tree_update_height(&mut *parent_borrowed);\n        }\n    }\n\n    if node1.parent.is_none() {\n        tree.root_node = node2.cloned().map(|n| Box::new(n));\n    }\n}\n\npub fn avl_tree_subtree_height<T>(node: &Option<Box<AVLTreeNode<T>>>) -> i32 {\n    if let Some(n) = node {\n        n.height\n    } else {\n        0\n    }\n}\n\npub fn avl_tree_balance_to_root<T: Clone>(tree: &mut AVLTree<T>, node: &mut AVLTreeNode<T>) {\n    let mut rover = Some(Rc::new(RefCell::new(node.clone())));\n\n    while let Some(current_rover) = rover {\n        let mut current_rover_borrowed = current_rover.borrow_mut();\n\n        // Balance this node if necessary\n        let balanced_node = avl_tree_node_balance(tree, &mut *current_rover_borrowed);\n        rover = balanced_node.parent.clone();\n\n        // Go to this node's parent\n        rover = rover.map(|parent| Rc::clone(&parent));\n    }\n}\n\npub fn avl_tree_remove<T: Clone>(tree: &mut AVLTree<T>, key: T) -> i32 {\n    let mut node = avl_tree_lookup_node(tree, key).cloned();\n\n    if node.is_none() {\n        return 0;\n    }\n\n    avl_tree_remove_node(tree, node.as_mut().unwrap());\n\n    1\n}\n\npub fn avl_tree_node_get_replacement<'a, T: Clone>(tree: &'a mut AVLTree<T>, node: &'a mut AVLTreeNode<T>) -> Option<&'a mut AVLTreeNode<T>> {\n    let left_subtree = node.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize].as_mut();\n    let right_subtree = node.children[AVLTreeNodeSide::AvlTreeNodeRight as usize].as_mut();\n\n    if left_subtree.is_none() && right_subtree.is_none() {\n        return None;\n    }\n\n    let left_height = avl_tree_subtree_height(&node.children[AVLTreeNodeSide::AvlTreeNodeLeft as usize]);\n    let right_height = avl_tree_subtree_height(&node.children[AVLTreeNodeSide::AvlTreeNodeRight as usize]);\n\n    let side = if left_height < right_height {\n        AVLTreeNodeSide::AvlTreeNodeRight\n    } else {\n        AVLTreeNodeSide::AvlTreeNodeLeft\n    };\n\n    let mut result = node.children[side as usize].as_mut().unwrap();\n\n    while result.children[1 - side as usize].is_some() {\n        result = result.children[1 - side as usize].as_mut().unwrap();\n    }\n\n    let child = result.children[side as usize].take();\n    avl_tree_node_replace(tree, result, child.as_deref());\n\n    avl_tree_update_height(&mut *result.parent.as_mut().unwrap().borrow_mut());\n\n    Some(result)\n}\n\npub fn avl_tree_remove_node<T: Clone>(tree: &mut AVLTree<T>, node: &mut AVLTreeNode<T>) {\n    let mut swap_node = avl_tree_node_get_replacement(tree, node).cloned();\n    let mut balance_startpoint = node.parent.clone();\n\n    if swap_node.is_none() {\n        avl_tree_node_replace(tree, node, None);\n    } else {\n        if swap_node.as_ref().unwrap().parent.as_ref().unwrap().borrow() as *const AVLTreeNode<T> == node {\n            balance_startpoint = swap_node.as_ref().unwrap().parent.clone();\n        }\n\n        for i in 0..2 {\n            swap_node.as_mut().unwrap().children[i] = node.children[i].take();\n            if let Some(child) = swap_node.as_mut().unwrap().children[i].as_mut() {\n                child.parent = swap_node.as_ref().unwrap().parent.clone();\n            }\n        }\n\n        swap_node.as_mut().unwrap().height = node.height;\n        avl_tree_node_replace(tree, node, swap_node.as_deref());\n    }\n\n    tree.num_nodes -= 1;\n\n    if let Some(balance_startpoint) = balance_startpoint {\n        avl_tree_balance_to_root(tree, &mut *balance_startpoint.borrow_mut());\n    }\n}\n\nfn main(){}\n //编译报错信息：error[E0599]: the method `as_deref` exists for enum `Option<AVLTreeNode<T>>`, but its trait bounds were not satisfied\n   --> ../tmp/temp.rs:246:53\n    |\n18  | pub struct AVLTreeNode<T> {\n    | ------------------------- doesn't satisfy `AVLTreeNode<T>: Deref`\n...\n246 |         avl_tree_node_replace(tree, node, swap_node.as_deref());\n    |                                                     ^^^^^^^^\n    |\n"
    }
}